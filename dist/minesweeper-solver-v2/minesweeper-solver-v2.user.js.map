{
  "version": 3,
  "sources": ["../../src/main/minesweeper-solver-v2/minesweeper-solver-v2.user.ts"],
  "sourcesContent": ["namespace MinesweeperSolver {\n  //type Cell = -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n  type Cell = [number, number] // [row, col]\n  type Board = number[][]\n\n  interface Rule {\n    numMines: number\n    cells: Set<string> // stringified cell coordinates\n  }\n\n  class InconsistencyError extends Error {\n    constructor(message: string) {\n      super(message)\n      this.name = 'InconsistencyError'\n    }\n  }\n\n  class Solver {\n    private board: Board\n\n    constructor(board: Board) {\n      this.board = board\n    }\n\n    public static cellToString = (cell: Cell): string => {\n      return `${cell[0]},${cell[1]}`\n    }\n\n    public static stringToCell = (str: string): Cell => {\n      const [r, c] = str.split(',').map(Number)\n      return [r, c]\n    }\n\n    private createRule = (numMines: number, cells: Cell[]): Rule => {\n      return {\n        numMines,\n        cells: new Set(cells.map(Solver.cellToString)),\n      }\n    }\n\n    private isRuleTrivial = (rule: Rule): boolean => {\n      return rule.numMines === 0 || rule.numMines === rule.cells.size\n    }\n\n    private getDefiniteCells = (rule: Rule): { mines: Set<string>; safe: Set<string> } => {\n      if (rule.numMines === 0) {\n        return { mines: new Set(), safe: new Set(rule.cells) }\n      } else if (rule.numMines === rule.cells.size) {\n        return { mines: new Set(rule.cells), safe: new Set() }\n      } else {\n        return { mines: new Set(), safe: new Set() }\n      }\n    }\n\n    private subtractRule = (superRule: Rule, subRule: Rule): Rule | null => {\n      // Check if subRule is subset of superRule\n      for (const cell of subRule.cells) {\n        if (!superRule.cells.has(cell)) {\n          return null\n        }\n      }\n\n      const remainingCells = new Set(superRule.cells)\n      for (const cell of subRule.cells) {\n        remainingCells.delete(cell)\n      }\n\n      return {\n        numMines: superRule.numMines - subRule.numMines,\n        cells: remainingCells,\n      }\n    }\n\n    private getNeighbors = (row: number, col: number, maxRow: number, maxCol: number): Cell[] => {\n      const neighbors: Cell[] = []\n\n      for (let dr = -1; dr <= 1; dr++) {\n        for (let dc = -1; dc <= 1; dc++) {\n          if (dr === 0 && dc === 0) continue\n\n          const newRow = row + dr\n          const newCol = col + dc\n\n          if (newRow >= 0 && newRow < maxRow && newCol >= 0 && newCol < maxCol) {\n            neighbors.push([newRow, newCol])\n          }\n        }\n      }\n\n      return neighbors\n    }\n\n    private boardToRules(board: Board): Rule[] {\n      const rows = board.length\n      const cols = board[0].length\n      const rules: Rule[] = []\n\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          const cellValue = board[r][c]\n\n          // Skip if not a numbered cell (0-8)\n          if (cellValue < 0 || cellValue > 8) {\n            continue\n          }\n\n          const neighbors = this.getNeighbors(r, c, rows, cols)\n          const unknownNeighbors: Cell[] = []\n          let knownMines = 0\n\n          // Categorize neighbors\n          for (const [nr, nc] of neighbors) {\n            const neighborValue = board[nr][nc]\n            if (neighborValue === -1) {\n              // Unknown cell\n              unknownNeighbors.push([nr, nc])\n            } else if (neighborValue === 9) {\n              // Known mine\n              knownMines++\n            }\n          }\n          // Cells with values 0-8 are revealed and don't contribute to the constraint\n\n          // Create rule if there are unknown neighbors\n          if (unknownNeighbors.length > 0) {\n            const remainingMines = cellValue - knownMines\n\n            // Validate the rule\n            if (remainingMines < 0) {\n              throw new InconsistencyError(`Invalid board state at (${r},${c}): more known mines than indicated`)\n            }\n            if (remainingMines > unknownNeighbors.length) {\n              throw new InconsistencyError(`Invalid board state at (${r},${c}): not enough cells for required mines`)\n            }\n            rules.push(this.createRule(remainingMines, unknownNeighbors))\n          }\n        }\n      }\n      return rules\n    }\n\n    private solveDefinite = (rules: Rule[]): { mines: Set<string>; safe: Set<string> } => {\n      const ruleSet = new Set(rules)\n      const definiteMines = new Set<string>()\n      const definiteSafe = new Set<string>()\n\n      let changed = true\n      while (changed) {\n        changed = false\n\n        // Find trivial rules\n        const trivialRules: Rule[] = []\n        for (const rule of ruleSet) {\n          if (this.isRuleTrivial(rule)) {\n            const { mines, safe } = this.getDefiniteCells(rule)\n            for (const mine of mines) definiteMines.add(mine)\n            for (const safeCell of safe) definiteSafe.add(safeCell)\n            trivialRules.push(rule)\n            changed = true\n          }\n        }\n\n        // Remove processed trivial rules\n        for (const rule of trivialRules) {\n          ruleSet.delete(rule)\n        }\n\n        // Try to reduce remaining rules by subtracting trivial ones\n        for (const trivialRule of trivialRules) {\n          const rulesToReplace: { old: Rule; new: Rule }[] = []\n\n          for (const rule of ruleSet) {\n            const reduced = this.subtractRule(rule, trivialRule)\n            if (reduced !== null) {\n              // Validate the reduction\n              if (reduced.numMines < 0 || reduced.numMines > reduced.cells.size) {\n                throw new InconsistencyError('Invalid rule after reduction')\n              }\n\n              rulesToReplace.push({ old: rule, new: reduced })\n              changed = true\n            }\n          }\n\n          // Apply replacements\n          for (const { old, new: newRule } of rulesToReplace) {\n            ruleSet.delete(old)\n            ruleSet.add(newRule)\n          }\n        }\n\n        // Try subset reduction\n        const rulesArray = Array.from(ruleSet)\n        let foundSubsetReduction = false\n\n        for (let i = 0; i < rulesArray.length && !foundSubsetReduction; i++) {\n          for (let j = i + 1; j < rulesArray.length && !foundSubsetReduction; j++) {\n            const rule1 = rulesArray[i]\n            const rule2 = rulesArray[j]\n\n            // Check if rule1 is subset of rule2\n            const rule1IsSubset = Array.from(rule1.cells).every(cell => rule2.cells.has(cell))\n            if (rule1IsSubset && rule1.cells.size < rule2.cells.size) {\n              const reduced = this.subtractRule(rule2, rule1)\n              if (reduced !== null && reduced.numMines >= 0) {\n                ruleSet.delete(rule2)\n                ruleSet.add(reduced)\n                changed = true\n                foundSubsetReduction = true\n              }\n            }\n\n            // Check if rule2 is subset of rule1\n            const rule2IsSubset = Array.from(rule2.cells).every(cell => rule1.cells.has(cell))\n            if (rule2IsSubset && rule2.cells.size < rule1.cells.size) {\n              const reduced = this.subtractRule(rule1, rule2)\n              if (reduced !== null && reduced.numMines >= 0) {\n                ruleSet.delete(rule1)\n                ruleSet.add(reduced)\n                changed = true\n                foundSubsetReduction = true\n              }\n            }\n          }\n        }\n      }\n\n      return { mines: definiteMines, safe: definiteSafe }\n    }\n\n    public solve(): { mines: Set<string>; safe: Set<string> } {\n      const rules = this.boardToRules(this.board)\n      const { mines, safe } = this.solveDefinite(rules)\n      return { mines, safe }\n    }\n  }\n\n  const classToValue: Record<string, number> = {\n    hdd_flag: 9,\n    hdd_type0: 0,\n    hdd_type1: 1,\n    hdd_type2: 2,\n    hdd_type3: 3,\n    hdd_type4: 4,\n    hdd_type5: 5,\n    hdd_type6: 6,\n    hdd_type7: 7,\n    hdd_type8: 8,\n  }\n\n  /**\n   * Extracts the cell's position and value from a DOM element.\n   * @param element - The cell DOM element\n   * @returns Position and value, or null if not found\n   */\n  const processChange = (element: Element): { x: number; y: number; value: number } | null => {\n    const xString = element.getAttribute('data-x')\n    const yString = element.getAttribute('data-y')\n    let value: number = -1\n    for (const [cls, val] of Object.entries(classToValue)) {\n      if (element.classList.contains(cls)) {\n        value = val\n        break\n      }\n    }\n    if (xString && yString) {\n      const x = parseInt(xString, 10)\n      const y = parseInt(yString, 10)\n      return { x, y, value }\n    }\n    return null\n  }\n\n  /**\n   * Returns the DOM element for a cell at a given position.\n   * @param pos - The cell position\n   */\n  const getCellElement = (pos: string): HTMLElement | null => {\n    const cell: Cell = Solver.stringToCell(pos)\n    return document.getElementById(`cell_${cell[1]}_${cell[0]}`)\n  }\n\n  /**\n   * Checks if a cell is still closed (not revealed).\n   * @param cell - The cell DOM element\n   */\n  const isCellClosed = (cell: HTMLElement): boolean => {\n    return cell.classList.contains('hdd_closed')\n  }\n\n  let detectionTimeout: number | undefined\n  const DEBOUNCE_MS = 500\n\n  const OVERLAY_ID = 'minesweeper-solver-overlay'\n\n  /**\n   * Creates a highlight div for a cell overlay.\n   * @param pos - The cell position\n   * @param color - Border color\n   */\n  const createHighlightDiv = (pos: string, color: string): HTMLDivElement | null => {\n    const cell = getCellElement(pos)\n    if (!cell) return null\n    if (!isCellClosed(cell)) return null\n    const highlight = document.createElement('div')\n    highlight.style.position = 'absolute'\n    highlight.style.left = `${cell.offsetLeft}px`\n    highlight.style.top = `${cell.offsetTop}px`\n    highlight.style.width = `${cell.offsetWidth}px`\n    highlight.style.height = `${cell.offsetHeight}px`\n    highlight.style.pointerEvents = 'none'\n    highlight.style.boxSizing = 'border-box'\n    highlight.style.border = `2px solid ${color}`\n    highlight.style.borderRadius = '3px'\n    highlight.style.zIndex = '1'\n    return highlight\n  }\n\n  /**\n   * Creates a document fragment containing overlays for known mines and safe cells.\n   * @param knownMines - Array of mine positions\n   * @param knownSafe - Array of safe positions\n   */\n  const createOverlayFragment = (knownMines: Set<string>, knownSafe: Set<string>): DocumentFragment => {\n    const fragment = document.createDocumentFragment()\n    for (const mine of knownMines) {\n      const div = createHighlightDiv(mine, 'red')\n      if (div) fragment.appendChild(div)\n    }\n    for (const safe of knownSafe) {\n      const div = createHighlightDiv(safe, 'green')\n      if (div) fragment.appendChild(div)\n    }\n    return fragment\n  }\n\n  /**\n   * Updates the overlay on the game board to show known mines and safe cells.\n   * @param knownMines - Array of mine positions\n   * @param knownSafe - Array of safe positions\n   */\n  const updateOverlay = (knownMines: Set<string>, knownSafe: Set<string>): void => {\n    removeOverlay()\n    const board = document.getElementById('game')\n    if (!board) return\n    const overlay = document.createElement('div')\n    overlay.id = OVERLAY_ID\n    overlay.style.pointerEvents = 'none'\n    overlay.appendChild(createOverlayFragment(knownMines, knownSafe))\n    board.appendChild(overlay)\n  }\n\n  /**\n   * Removes the overlay from the game board if present.\n   */\n  const removeOverlay = (): void => {\n    const old = document.getElementById(OVERLAY_ID)\n    if (old?.parentElement) old.parentElement.removeChild(old)\n  }\n\n  /**\n   * Creates a 2D grid representing the current state of the board from the DOM.\n   */\n  const createGrid = (): Board => {\n    const grid: Board = []\n    const cells = document.querySelectorAll('#AreaBlock .cell')\n    for (const cell of cells) {\n      const cellData = processChange(cell)\n      if (cellData) {\n        if (!grid[cellData.y]) {\n          grid[cellData.y] = []\n        }\n        grid[cellData.y][cellData.x] = cellData.value\n      }\n    }\n    return grid\n  }\n\n  /**\n   * Schedules a solver run and overlay update, debounced to avoid excessive computation.\n   */\n  function scheduleDetection(): void {\n    if (detectionTimeout !== undefined) {\n      clearTimeout(detectionTimeout)\n    }\n    detectionTimeout = window.setTimeout(runSolverAndUpdateOverlay, DEBOUNCE_MS)\n  }\n\n  /**\n   * Runs the solver and updates the overlay with the results.\n   */\n  function runSolverAndUpdateOverlay(): void {\n    const grid = createGrid()\n    const solver = new Solver(grid)\n    const result = solver.solve()\n    const knownMines = result.mines\n    const knownSafe = result.safe\n    updateOverlay(knownMines, knownSafe)\n    detectionTimeout = undefined\n  }\n\n  /**\n   * Observes DOM mutations to trigger solver updates when the board changes.\n   */\n  const gameObserver = new MutationObserver(records => {\n    for (const record of records) {\n      if (record.attributeName) {\n        const element = record.target as Element\n        if (element.classList.contains('cell')) {\n          scheduleDetection()\n        }\n      }\n    }\n  })\n\n  /**\n   * Entry point: starts observing the board for changes and triggers the solver.\n   */\n  export const main = (): void => {\n    gameObserver.observe(document, {\n      subtree: true,\n      childList: true,\n      attributeFilter: ['class'],\n    })\n  }\n}\nMinesweeperSolver.main()\n"],
  "mappings": "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",
  "names": ["MinesweeperSolver"]
}
