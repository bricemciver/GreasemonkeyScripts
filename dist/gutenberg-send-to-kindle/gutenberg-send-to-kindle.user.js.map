{
  "version": 3,
  "sources": ["../../node_modules/uuid/dist/stringify.js", "../../node_modules/uuid/dist/rng.js", "../../node_modules/uuid/dist/native.js", "../../node_modules/uuid/dist/v4.js", "../../src/main/gutenberg-send-to-kindle/gutenberg-send-to-kindle.user.ts"],
  "sourcesContent": ["import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n", "import { v4 as uuidv4 } from \"uuid\";\nnamespace GutenbergSendToKindle {\n  interface InitResponse {\n    uploadUrl: string;\n    stkToken: string;\n    statusCode: number;\n    expiryTime: number;\n  }\n\n  interface UploadResponse {\n    VersionID: string;\n    AssetType: string;\n    ETag: string;\n    \"Content-Length\": number;\n  }\n\n  interface SendResponse {\n    statusCode?: number;\n    message?: string;\n  }\n\n  interface EpubInfo {\n    url: string;\n    filename: string;\n    title: string | null;\n    author: string | null;\n  }\n\n  enum HttpStatus {\n    OK = 200,\n  }\n\n  const baseHeaders = {\n    Origin: \"https://www.amazon.com\",\n    Referer: \"https://www.amazon.com/sendtokindle\",\n    \"Content-Type\": \"application/json\",\n  };\n\n  const CSRFPattern = /name=[\"']csrfToken[\"'][^>]*value=[\"']([^\"']+)[\"']/i;\n  const ContentLengthPattern = /content-length:\\s*(\\d+)/i;\n  const EPUB_CONTENT_TYPE = \"application/epub+zip\";\n  const TOAST_TIMEOUT_MS = 5000;\n  const AMAZON_SENDTOKINDLE_URL = \"https://www.amazon.com/sendtokindle\";\n  const LevelToClassMap: Record<string, string> = {\n    info: \"gstk-toast--info\",\n    error: \"gstk-toast--error\",\n    success: \"gstk-toast--success\",\n  };\n\n  let cachedCsrfToken: string | null = null;\n\n  // Helper to check HTTP status and throw on error\n  const ensureStatus = (\n    response: Tampermonkey.Response<unknown>,\n    expectedStatus: number = HttpStatus.OK,\n  ): void => {\n    if (response.status !== expectedStatus) {\n      throw new Error(`Request returned status ${response.status}`);\n    }\n  };\n\n  // Helper to parse JSON response with error handling\n  const parseJsonResponse = <T>(responseText: string): T => {\n    try {\n      return JSON.parse(responseText) as T;\n    } catch (e) {\n      throw new Error(`Failed to parse response: ${e}`);\n    }\n  };\n\n  const getCsrfToken = async (): Promise<string> => {\n    if (cachedCsrfToken) {\n      log(\"Using cached CSRF token\");\n      return cachedCsrfToken;\n    }\n\n    log(\"Fetching CSRF token from Amazon sendtokindle page\");\n    const response = await GM.xmlHttpRequest({\n      method: \"GET\",\n      url: AMAZON_SENDTOKINDLE_URL,\n    });\n    const html = response.responseText || \"\";\n\n    // Detect the specific sign-in span used on the Amazon Send-to-Kindle UI.\n    // If the following span exists on the page, the user is not signed in:\n    // <span id=\"s2k-dnd-sign-in-button-text\" class=\"s2k-dnd-button-text\">Sign in</span>\n    const signInSpanPattern =\n      /<span[^>]*id=[\"']s2k-dnd-sign-in-button-text[\"'][^>]*>[\\s\\S]*?Sign\\s*in[\\s\\S]*?<\\/span>/i;\n    if (signInSpanPattern.test(html)) {\n      log(\n        \"getCsrfToken: found s2k sign-in span in amazon page response â€” user not signed in\",\n      );\n      throw new Error(\"NOT_LOGGED_IN\");\n    }\n\n    const m = CSRFPattern.exec(html);\n    if (m?.[1]) {\n      cachedCsrfToken = m[1];\n      log(\"Retrieved CSRF token\", { token: cachedCsrfToken });\n      return cachedCsrfToken;\n    }\n\n    const excerpt = (html.substring(0, 1000) || \"\").split(/\\s+/).join(\" \");\n    log(\"Warning: Could not find CSRF token in Amazon page excerpt:\", excerpt);\n    throw new Error(\"CSRF_NOT_FOUND\");\n  };\n\n  const log = (message: string, data?: unknown) => {\n    const timestamp = new Date().toISOString();\n    if (data) {\n      console.info(`[Gutenberg Send to Kindle ${timestamp}] ${message}`, data);\n    } else {\n      console.info(`[Gutenberg Send to Kindle ${timestamp}] ${message}`);\n    }\n  };\n\n  // Inject stylesheet for UI elements (to avoid recreating inline styles)\n  const injectStyles = () => {\n    const styleId = \"gstk-injected-styles\";\n    if (document.getElementById(styleId)) {\n      return;\n    }\n    const css = `\n      .gstk-toast {\n        position: fixed;\n        top: 20px;\n        right: 20px;\n        padding: 12px 16px;\n        border-radius: 4px;\n        z-index: 10000;\n        font-size: 14px;\n        max-width: 300px;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n        transition: opacity 0.2s ease;\n      }\n      .gstk-toast--error { background-color: #fee; color: #c00; border: 1px solid #fcc; }\n      .gstk-toast--success { background-color: #efe; color: #060; border: 1px solid #cfc; }\n      .gstk-toast--info { background-color: #eef; color: #006; border: 1px solid #ccf; }\n\n      .gstk-button {\n        padding: 8px 16px;\n        background-color: #ff9900;\n        color: white;\n        border: none;\n        border-radius: 4px;\n        cursor: pointer;\n        font-size: 14px;\n        font-weight: bold;\n        transition: background-color 0.2s;\n      }\n      .gstk-button:hover { background-color: #ff9933; }\n    `;\n    const styleEl = document.createElement(\"style\");\n    styleEl.id = styleId;\n    styleEl.textContent = css;\n    document.head?.appendChild(styleEl);\n  };\n\n  const showMessage = (\n    message: string,\n    type: \"info\" | \"error\" | \"success\" = \"info\",\n  ) => {\n    const messageEl = document.createElement(\"div\");\n    const toastClass = LevelToClassMap[type] || \"gstk-toast--info\";\n    messageEl.classList.add(\"gstk-toast\", toastClass);\n    messageEl.textContent = message;\n    document.body.appendChild(messageEl);\n\n    setTimeout(() => {\n      messageEl.remove();\n    }, TOAST_TIMEOUT_MS);\n  };\n\n  const getEpubInfo = (): EpubInfo | null => {\n    // Locate EPUB3 download links: Gutenberg uses hrefs containing '.epub3.'\n    // and the link text for EPUB3 is standardized. Prefer the exact text\n    // \"EPUB3 (E-readers incl. Send-to-Kindle)\" and the href containing\n    // '.epub3.'; fail gracefully if none are present.\n    const epub3Candidates = Array.from(\n      document.querySelectorAll<HTMLAnchorElement>('a[href*=\".epub3.\"]'),\n    );\n\n    let epubLink: HTMLAnchorElement | null = null;\n    const exactEpub3Text = \"EPUB3 (E-readers incl. Send-to-Kindle)\";\n\n    // First, prefer an exact text match combined with .epub3. in href\n    for (const a of epub3Candidates) {\n      if ((a.textContent || \"\").trim() === exactEpub3Text) {\n        epubLink = a;\n        log(\"EPUB3 link selected by exact text and href\", { href: a.href });\n        break;\n      }\n    }\n\n    if (!epubLink) {\n      log(\"No EPUB3 link found on page; aborting\");\n      return null;\n    }\n\n    const epubUrl = epubLink.href;\n    const filename = epubUrl.split(\"/\").pop() || \"book.epub\";\n\n    // Extract title/author from document.title (format: \"Title by Author | Project Gutenberg\")\n    let title: string | null = null;\n    let author: string | null = null;\n    try {\n      const pageTitle = (document.title || \"\").split(\"|\")[0].trim();\n      // Split on the last occurrence of ' by '\n      const lastBy = pageTitle.toLowerCase().lastIndexOf(\" by \");\n      if (lastBy !== -1) {\n        title = pageTitle.substring(0, lastBy).trim();\n        author = pageTitle.substring(lastBy + 4).trim();\n      }\n      log(\"Title/author extracted from document.title\", { title, author });\n    } catch (e) {\n      log(\"Failed to extract title/author from document.title\", e);\n    }\n\n    log(\"Found EPUB info\", {\n      filename,\n      title,\n      author,\n      epubUrl,\n    });\n\n    return { url: epubUrl, filename, title, author };\n  };\n\n  const downloadEpub = async (url: string): Promise<ArrayBuffer> => {\n    log(`Downloading EPUB from ${url}`);\n    const response = await GM.xmlHttpRequest({\n      url,\n      method: \"GET\",\n      responseType: \"arraybuffer\",\n    }).catch((e) => {\n      log(`Failed to download EPUB: ${e}`);\n      throw e;\n    });\n    log(\n      `EPUB downloaded successfully, size: ${response.response.byteLength} bytes`,\n    );\n    return response.response as ArrayBuffer;\n  };\n\n  const headEpub = async (url: string): Promise<number | null> => {\n    log(`Performing HEAD request for EPUB: ${url}`);\n    const response = await GM.xmlHttpRequest({ method: \"HEAD\", url }).catch(\n      (e) => {\n        log(\"HEAD request failed\", e);\n        return null;\n      },\n    );\n    const headers = response?.responseHeaders || \"\";\n    const m = new RegExp(ContentLengthPattern).exec(headers);\n    if (m?.[1]) {\n      const size = Number.parseInt(m[1], 10);\n      log(\"HEAD returned Content-Length\", size);\n      return size;\n    } else {\n      log(\"HEAD did not return Content-Length\");\n      return null;\n    }\n  };\n\n  const initSendToKindle = async (\n    fileSize: number,\n    csrfToken: string,\n  ): Promise<InitResponse> => {\n    log(\"Initializing Send to Kindle\", { fileSize });\n    const payload = {\n      fileSize,\n      contentType: EPUB_CONTENT_TYPE,\n      appVersion: \"1.0\",\n      appName: \"drag_drop_web\",\n      fileExtension: \"epub\",\n    };\n\n    log(\"Sending init request to Amazon (/sendtokindle/init)\");\n    const response = await GM.xmlHttpRequest({\n      method: \"POST\",\n      url: `${AMAZON_SENDTOKINDLE_URL}/init`,\n      headers: {\n        ...baseHeaders,\n        \"anti-csrftoken-a2z\": csrfToken,\n        Accept: \"*/*\",\n      },\n      data: JSON.stringify(payload),\n    }).catch((e) => {\n      log(\"Init request failed\", e);\n      throw e;\n    });\n    log(\"Init response status\", response.status);\n    ensureStatus(response);\n    const data = parseJsonResponse<InitResponse>(response.responseText);\n    log(\"Init response received\", data);\n    if (data.statusCode !== 0) {\n      throw new Error(`Init failed with status code: ${data.statusCode}`);\n    }\n    return data;\n  };\n\n  const uploadEpub = async (\n    uploadUrl: string,\n    epubData: ArrayBuffer,\n    csrfToken: string,\n  ): Promise<UploadResponse> => {\n    log(\"Uploading EPUB to Kindle\", {\n      uploadUrl,\n      dataSize: epubData.byteLength,\n    });\n    log(\"Sending upload request\");\n    const response = await GM.xmlHttpRequest({\n      method: \"PUT\",\n      url: uploadUrl,\n      headers: {\n        ...baseHeaders,\n        \"Content-Type\": EPUB_CONTENT_TYPE,\n        \"anti-csrftoken-a2z\": csrfToken,\n      },\n      data: epubData,\n      responseType: \"arraybuffer\",\n    }).catch((e) => {\n      log(`Upload request failed: ${e}`);\n      throw e;\n    });\n    log(\"Upload response status\", response.status);\n    ensureStatus(response);\n    const text = new TextDecoder().decode(response.response as ArrayBuffer);\n    const data = parseJsonResponse<UploadResponse>(text);\n    log(\"Upload response received\", data);\n    return data;\n  };\n\n  const sendToKindle = async (\n    stkToken: string,\n    title: string,\n    author: string,\n    contentLength: number,\n    filename: string,\n    csrfToken: string,\n  ): Promise<SendResponse> => {\n    log(\"Sending to Kindle\", {\n      stkToken,\n      title,\n      author,\n      contentLength,\n      filename,\n    });\n\n    const payload = {\n      stkToken,\n      title,\n      author,\n      extName: \"drag_drop_web\",\n      inputFormat: \"epub\",\n      extVersion: \"1.0\",\n      dataType: EPUB_CONTENT_TYPE,\n      stkGuid: \"\",\n      archive: true,\n      fileSize: contentLength,\n      forceConvert: \"false\",\n      inputFileName: filename,\n      batchId: uuidv4(),\n    };\n\n    log(\"Sending final send request (/sendtokindle/send-v2)\");\n    const response = await GM.xmlHttpRequest({\n      method: \"POST\",\n      url: `${AMAZON_SENDTOKINDLE_URL}/send-v2`,\n      headers: {\n        ...baseHeaders,\n        \"anti-csrftoken-a2z\": csrfToken,\n        Accept: \"*/*\",\n      },\n      data: JSON.stringify(payload),\n    }).catch((e) => {\n      log(`Send request failed: ${e}`);\n      throw e;\n    });\n    log(\"Send response status\", response.status);\n    ensureStatus(response);\n    const data = parseJsonResponse<SendResponse>(response.responseText);\n    log(\"Send response received\", data);\n    return data;\n  };\n\n  const sendEpubToKindle = async () => {\n    try {\n      showMessage(\"Preparing to send to Kindle...\", \"info\");\n      log(\"Starting send to Kindle process\");\n\n      // FIRST: collect all information from the Gutenberg page (no Amazon calls)\n      log(\"Retrieving EPUB info from page\");\n      const epubInfo = getEpubInfo();\n      if (!epubInfo) {\n        showMessage(\"Could not find EPUB3 version on this page\", \"error\");\n        log(\"Aborting: no EPUB3 found on page\");\n        return;\n      }\n\n      // If title or author is missing or unknown, prompt the user and halt if they cancel\n      if (!epubInfo.title || !epubInfo.author) {\n        showMessage(\"Sending cancelled â€” title/author required.\", \"error\");\n        return;\n      }\n\n      // Attempt HEAD to learn file size without downloading the whole EPUB\n      const headSize = await headEpub(epubInfo.url);\n\n      if (!headSize) {\n        // HEAD didn't provide size â€” fail gracefully\n        log(\"HEAD did not provide Content-Length; aborting send to Kindle.\");\n        showMessage(\n          \"Unable to determine EPUB size; cannot send to Kindle.\",\n          \"error\",\n        );\n        return;\n      }\n\n      // NOW: contact Amazon (CSRF, cookies, init/upload/send)\n      log(\"Fetching CSRF token from Amazon (deferred until metadata ready)\");\n      let csrfToken: string;\n      try {\n        csrfToken = await getCsrfToken();\n      } catch (error) {\n        let msg: string;\n        if (error instanceof Error) {\n          msg = error.message;\n        } else {\n          msg = String(error);\n        }\n        if (msg === \"NOT_LOGGED_IN\") {\n          showMessage(\n            \"You must be signed into Amazon for Send to Kindle to work. Please sign in and try again.\",\n            \"error\",\n          );\n          log(\"User not signed into Amazon (CSRF fetch indicated login page)\");\n          return;\n        }\n        if (msg === \"CSRF_NOT_FOUND\") {\n          showMessage(\n            \"Could not read Amazon's security token. Try refreshing Amazon or logging in.\",\n            \"error\",\n          );\n          log(\"CSRF token not found in Amazon page response\", error);\n          return;\n        }\n\n        showMessage(\n          \"Unable to fetch security token from Amazon. Please refresh and try again.\",\n          \"error\",\n        );\n        log(\"Failed to get CSRF token\", error);\n        return;\n      }\n\n      // Step 1: Initialize\n      log(\"Step 1: Initializing Send to Kindle\", { fileSize: headSize });\n      const initData = await initSendToKindle(headSize, csrfToken);\n\n      log(\"Downloading EPUB after init to prepare upload\");\n      const epubData = await downloadEpub(epubInfo.url);\n\n      // Step 2: Upload\n      log(\"Step 2: Uploading EPUB\");\n      const uploadData = await uploadEpub(\n        initData.uploadUrl,\n        epubData,\n        csrfToken,\n      );\n\n      // Step 3: Send to Kindle\n      log(\"Step 3: Sending to Kindle\");\n      const sendData = await sendToKindle(\n        initData.stkToken,\n        epubInfo.title,\n        epubInfo.author,\n        uploadData[\"Content-Length\"],\n        epubInfo.filename,\n        csrfToken,\n      );\n\n      log(\"Send to Kindle completed successfully\", sendData);\n      showMessage(`Sent \"${epubInfo.title}\" to your Kindle!`, \"success\");\n    } catch (error) {\n      let errorMessage: string;\n      if (error instanceof Error) {\n        errorMessage = error.message;\n      } else {\n        errorMessage = String(error);\n      }\n      log(\"Error sending to Kindle\", error);\n      showMessage(`Error: ${errorMessage}`, \"error\");\n    }\n  };\n\n  const addSendToKindleButton = () => {\n    // Check if EPUB3 is available\n    let epubLink: HTMLAnchorElement | null = null;\n    const epubLinks = document.querySelectorAll<HTMLAnchorElement>(\n      'a[class*=\"link\"][title*=\"Download\"]',\n    );\n    for (const link of Array.from(epubLinks)) {\n      if (link.textContent.includes(\"Send-to-Kindle\")) {\n        epubLink = link;\n        break;\n      }\n    }\n    if (!epubLink) {\n      log(\"No EPUB3 version available on this page\");\n      return;\n    }\n\n    // Create button container\n    const buttonContainer = document.createElement(\"div\");\n    // Add left margin so there's space between the preceding link and the button\n    buttonContainer.style.cssText = `\n      margin: 8px 0 8px 8px;\n      display: inline-block;\n    `;\n\n    // Create send to Kindle button\n    const button = document.createElement(\"button\");\n    button.textContent = \"ðŸ“§ Send to Kindle\";\n    button.classList.add(\"gstk-button\");\n\n    button.addEventListener(\"click\", (e) => {\n      e.preventDefault();\n      button.disabled = true;\n      button.textContent = \"â³ Sending...\";\n      sendEpubToKindle().finally(() => {\n        button.disabled = false;\n        button.textContent = \"ðŸ“§ Send to Kindle\";\n      });\n    });\n\n    buttonContainer.appendChild(button);\n\n    // Insert button into the page as next sibling to epub link\n    epubLink.after(buttonContainer);\n\n    log(\"Send to Kindle button added successfully\");\n  };\n\n  export const main = () => {\n    injectStyles();\n    addSendToKindleButton();\n  };\n}\nGutenbergSendToKindle.main();\n"],
  "mappings": "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",
  "names": ["GutenbergSendToKindle", "HttpStatus"]
}
