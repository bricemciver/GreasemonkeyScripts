{
  "version": 3,
  "sources": ["../../src/main/minesweeper-online/minesweeper-online.user.ts"],
  "sourcesContent": ["namespace MinesweeperOnline {\n  type Cell = -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n  type Grid = Cell[][]\n\n  interface Position {\n    x: number // horizontal axis (column)\n    y: number // vertical axis (row)\n  }\n\n  interface SolverStepResult {\n    newBombs: Position[]\n    newClears: Position[]\n    changed: boolean\n  }\n\n  interface SolverResult extends SolverStepResult {\n    grid: Grid\n  }\n\n  interface ConstraintCell {\n    pos: Position\n    value: number\n    unknowns: Position[]\n    remainingBombs: number\n  }\n\n  interface ConstraintGroup extends Array<ConstraintCell> {}\n\n  interface Constraint {\n    unknowns: string[]\n    remainingBombs: number\n  }\n\n  class MinesweeperSolver {\n    private readonly grid: Grid\n    private readonly rows: number\n    private readonly cols: number\n\n    constructor(grid: Grid) {\n      this.grid = grid.map(row => [...row]) // Deep copy\n      this.rows = grid.length\n      this.cols = grid[0].length\n    }\n\n    /**\n     * Get all adjacent positions for a given cell\n     * @param y - vertical position (row)\n     * @param x - horizontal position (column)\n     */\n    private getAdjacentPositions(y: number, x: number): Position[] {\n      const adjacent: Position[] = []\n\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          if (dy === 0 && dx === 0) continue\n\n          const newY = y + dy\n          const newX = x + dx\n\n          if (newY >= 0 && newY < this.rows && newX >= 0 && newX < this.cols) {\n            adjacent.push({ x: newX, y: newY })\n          }\n        }\n      }\n\n      return adjacent\n    }\n\n    /**\n     * Count bombs and unknowns in adjacent cells\n     * @param y - vertical position (row)\n     * @param x - horizontal position (column)\n     */\n    private analyzeAdjacent(\n      y: number,\n      x: number,\n    ): {\n      bombs: number\n      unknowns: Position[]\n      clears: number\n    } {\n      const adjacent = this.getAdjacentPositions(y, x)\n      let bombs = 0\n      let clears = 0\n      const unknowns: Position[] = []\n\n      for (const pos of adjacent) {\n        const cell = this.grid[pos.y][pos.x]\n        if (cell === 9) {\n          bombs++\n        } else if (cell === -1) {\n          unknowns.push(pos)\n        } else if (cell >= 0 && cell <= 8) {\n          clears++\n        }\n      }\n\n      return { bombs, unknowns, clears }\n    }\n\n    /**\n     * Apply basic minesweeper logic rules\n     */\n    private applyBasicRules(): SolverStepResult {\n      const newBombs: Position[] = []\n      const newClears: Position[] = []\n      let changed = false\n\n      // Check each numbered cell - iterate through rows (y) and columns (x)\n      for (let y = 0; y < this.rows; y++) {\n        for (let x = 0; x < this.cols; x++) {\n          const cell = this.grid[y][x]\n\n          // Only process numbered cells (1-8)\n          if (cell >= 1 && cell <= 8) {\n            const { bombs, unknowns } = this.analyzeAdjacent(y, x)\n\n            // Rule 1: If we've found all bombs, remaining unknowns are clear\n            if (bombs === cell && unknowns.length > 0) {\n              for (const pos of unknowns) {\n                this.grid[pos.y][pos.x] = 0\n                newClears.push(pos)\n                changed = true\n              }\n            }\n\n            // Rule 2: If remaining unknowns equal remaining bombs needed, they're all bombs\n            else if (bombs + unknowns.length === cell && unknowns.length > 0) {\n              for (const pos of unknowns) {\n                this.grid[pos.y][pos.x] = 9\n                newBombs.push(pos)\n                changed = true\n              }\n            }\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed }\n    }\n\n    /**\n     * Apply advanced constraint satisfaction techniques\n     */\n    private applyAdvancedRules(): {\n      newBombs: Position[]\n      newClears: Position[]\n      changed: boolean\n    } {\n      const newBombs: Position[] = []\n      const newClears: Position[] = []\n      let changed = false\n\n      // Find all numbered cells with unknowns\n      const constraintCells = this.getConstraintCells()\n\n      // Look for subset relationships between constraint cells\n      for (let i = 0; i < constraintCells.length; i++) {\n        for (let j = i + 1; j < constraintCells.length; j++) {\n          const result = this.analyzeConstraintPair(constraintCells[i], constraintCells[j])\n          if (result.changed) {\n            newBombs.push(...result.newBombs)\n            newClears.push(...result.newClears)\n            changed = true\n          }\n        }\n      }\n      return { newBombs, newClears, changed }\n    }\n\n    private getConstraintCells(): Array<{\n      pos: Position\n      value: number\n      unknowns: Position[]\n      remainingBombs: number\n    }> {\n      // Find all numbered cells with unknowns\n      const constraintCells: Array<{\n        pos: Position\n        value: number\n        unknowns: Position[]\n        remainingBombs: number\n      }> = []\n      for (let y = 0; y < this.rows; y++) {\n        for (let x = 0; x < this.cols; x++) {\n          const cell = this.grid[y][x]\n          if (cell >= 1 && cell <= 8) {\n            const { bombs, unknowns } = this.analyzeAdjacent(y, x)\n            const remainingBombs = cell - bombs\n            if (unknowns.length > 0 && remainingBombs > 0) {\n              constraintCells.push({\n                pos: { x, y },\n                value: cell,\n                unknowns,\n                remainingBombs,\n              })\n            }\n          }\n        }\n      }\n      return constraintCells\n    }\n\n    private analyzeConstraintPair(cell1: ConstraintCell, cell2: ConstraintCell): SolverStepResult {\n      const newBombs = []\n      const newClears = []\n      let changed = false\n\n      const unknowns1Set = new Set(cell1.unknowns.map(p => `${p.x},${p.y}`))\n      const unknowns2Set = new Set(cell2.unknowns.map(p => `${p.x},${p.y}`))\n\n      // Case 1: cell1 unknowns are subset of cell2 unknowns\n      if (cell1.unknowns.every(p => unknowns2Set.has(`${p.x},${p.y}`))) {\n        const difference = cell2.unknowns.filter(p => !unknowns1Set.has(`${p.x},${p.y}`))\n        const bombDifference = cell2.remainingBombs - cell1.remainingBombs\n\n        if (bombDifference === 0 && difference.length > 0) {\n          // All difference cells are safe\n          for (const pos of difference) {\n            if (this.grid[pos.y][pos.x] === -1) {\n              this.grid[pos.y][pos.x] = 0\n              newClears.push(pos)\n              changed = true\n            }\n          }\n        } else if (bombDifference === difference.length && difference.length > 0) {\n          // All difference cells are mines\n          for (const pos of difference) {\n            if (this.grid[pos.y][pos.x] === -1) {\n              this.grid[pos.y][pos.x] = 9\n              newBombs.push(pos)\n              changed = true\n            }\n          }\n        }\n      }\n\n      // Case 2: cell2 unknowns are subset of cell1 unknowns\n      else if (cell2.unknowns.every(p => unknowns1Set.has(`${p.x},${p.y}`))) {\n        const difference = cell1.unknowns.filter(p => !unknowns2Set.has(`${p.x},${p.y}`))\n        const bombDifference = cell1.remainingBombs - cell2.remainingBombs\n\n        if (bombDifference === 0 && difference.length > 0) {\n          // All difference cells are safe\n          for (const pos of difference) {\n            if (this.grid[pos.y][pos.x] === -1) {\n              this.grid[pos.y][pos.x] = 0\n              newClears.push(pos)\n              changed = true\n            }\n          }\n        } else if (bombDifference === difference.length && difference.length > 0) {\n          // All difference cells are mines\n          for (const pos of difference) {\n            if (this.grid[pos.y][pos.x] === -1) {\n              this.grid[pos.y][pos.x] = 9\n              newBombs.push(pos)\n              changed = true\n            }\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed }\n    }\n\n    // NEW: Advanced constraint satisfaction using equation solving\n    private applyConstraintSatisfaction() {\n      const newBombs: Position[] = []\n      const newClears: Position[] = []\n      let changed = false\n\n      const constraintCells = this.getConstraintCells()\n      if (constraintCells.length === 0) return { newBombs, newClears, changed }\n\n      // Group connected constraint regions to solve them separately\n      const constraintGroups = this.groupConnectedConstraints(constraintCells)\n\n      for (const group of constraintGroups) {\n        const allUnknowns = new Set<string>()\n        group.forEach(cell => {\n          cell.unknowns.forEach(pos => {\n            allUnknowns.add(`${pos.x},${pos.y}`)\n          })\n        })\n\n        const unknownsList = Array.from(allUnknowns)\n        const unknownsMap = new Map()\n        unknownsList.forEach((key, index) => {\n          unknownsMap.set(key, index)\n        })\n\n        // Try all possible combinations for small constraint sets\n        if (unknownsList.length <= 16 && group.length <= 10) {\n          // Limit for performance\n          const result = this.solveBruteForce(group, unknownsList, unknownsMap)\n          if (result.changed) {\n            newBombs.push(...result.newBombs)\n            newClears.push(...result.newClears)\n            changed = true\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed }\n    }\n\n    // Group constraints that share unknowns into connected components\n    private groupConnectedConstraints(constraintCells: ConstraintCell[]): ConstraintGroup[] {\n      const groups: ConstraintGroup[] = []\n      const visited = new Set<number>()\n\n      for (let i = 0; i < constraintCells.length; i++) {\n        if (visited.has(i)) continue\n\n        const group: ConstraintGroup = []\n        const queue: number[] = [i]\n        visited.add(i)\n\n        while (queue.length > 0) {\n          const current = queue.shift() as number\n          group.push(constraintCells[current])\n\n          const currentUnknowns = new Set<string>(constraintCells[current].unknowns.map(p => `${p.x},${p.y}`))\n\n          // Find all other constraints that share unknowns with this one\n          for (let j = 0; j < constraintCells.length; j++) {\n            if (visited.has(j)) continue\n\n            const otherUnknowns = constraintCells[j].unknowns.map(p => `${p.x},${p.y}`)\n            const hasSharedUnknown = otherUnknowns.some(unknown => currentUnknowns.has(unknown))\n\n            if (hasSharedUnknown) {\n              queue.push(j)\n              visited.add(j)\n            }\n          }\n        }\n\n        if (group.length > 0) {\n          groups.push(group)\n        }\n      }\n\n      return groups\n    }\n\n    private solveBruteForce(constraintCells: ConstraintCell[], unknownsList: string[], unknownsMap: Map<string, number>): SolverStepResult {\n      const newBombs: Position[] = []\n      const newClears: Position[] = []\n      let changed = false\n\n      const n = unknownsList.length\n      if (n > 20) return { newBombs, newClears, changed } // Safety limit\n\n      const validSolutions: number[][] = []\n      const maxSolutions = 10000 // Limit to prevent infinite computation\n\n      // Generate all possible mine configurations\n      for (let mask = 0; mask < 1 << n && validSolutions.length < maxSolutions; mask++) {\n        const solution: number[] = new Array(n).fill(0)\n        for (let i = 0; i < n; i++) {\n          if (mask & (1 << i)) {\n            solution[i] = 1 // mine\n          }\n        }\n\n        // Check if this solution satisfies all constraints\n        let valid = true\n        for (const constraint of constraintCells) {\n          let mineCount = 0\n          for (const pos of constraint.unknowns) {\n            const key = `${pos.x},${pos.y}`\n            const index = unknownsMap.get(key)\n            if (index !== undefined && solution[index] === 1) {\n              mineCount++\n            }\n          }\n          if (mineCount !== constraint.remainingBombs) {\n            valid = false\n            break\n          }\n        }\n\n        if (valid) {\n          validSolutions.push(solution)\n        }\n      }\n\n      // Find cells that have the same value in ALL valid solutions\n      if (validSolutions.length > 0) {\n        for (let i = 0; i < n; i++) {\n          const firstValue = validSolutions[0][i]\n          const allSame = validSolutions.every(sol => sol[i] === firstValue)\n\n          if (allSame) {\n            const key = unknownsList[i]\n            const [x, y] = key.split(',').map(Number)\n\n            if (firstValue === 1) {\n              // All solutions have mine here\n              if (this.grid[y][x] === -1) {\n                this.grid[y][x] = 9\n                newBombs.push({ x, y })\n                changed = true\n              }\n            } else {\n              // All solutions have safe cell here\n              if (this.grid[y][x] === -1) {\n                this.grid[y][x] = 0\n                newClears.push({ x, y })\n                changed = true\n              }\n            }\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed }\n    }\n\n    // NEW: Tank solver - advanced pattern recognition\n    private applyTankSolver() {\n      const newBombs = []\n      const newClears = []\n      let changed = false\n\n      // Find border cells (unknowns adjacent to revealed numbers)\n      const borderCells = new Set<string>()\n      const constraints = []\n\n      for (let y = 0; y < this.rows; y++) {\n        for (let x = 0; x < this.cols; x++) {\n          const cell = this.grid[y][x]\n          if (cell >= 1 && cell <= 8) {\n            const { bombs, unknowns } = this.analyzeAdjacent(y, x)\n            const remainingBombs = cell - bombs\n\n            if (unknowns.length > 0 && remainingBombs > 0) {\n              unknowns.forEach(pos => {\n                borderCells.add(`${pos.x},${pos.y}`)\n              })\n              constraints.push({\n                unknowns: unknowns.map(pos => `${pos.x},${pos.y}`),\n                remainingBombs,\n              })\n            }\n          }\n        }\n      }\n\n      // Use Gaussian elimination on constraint matrix\n      if (borderCells.size > 0 && borderCells.size <= 20) {\n        const result = this.solveConstraintMatrix(constraints)\n\n        for (const [cellKey, value] of result.entries()) {\n          const [x, y] = cellKey.split(',').map(Number)\n          if (value === 1 && this.grid[y][x] === -1) {\n            this.grid[y][x] = 9\n            newBombs.push({ x, y })\n            changed = true\n          } else if (value === 0 && this.grid[y][x] === -1) {\n            this.grid[y][x] = 0\n            newClears.push({ x, y })\n            changed = true\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed }\n    }\n\n    private solveConstraintMatrix(constraints: Constraint[]): Map<string, 0 | 1> {\n      const solutions = new Map<string, 0 | 1>()\n\n      // Simple constraint propagation\n      let changed = true\n      while (changed) {\n        changed = false\n\n        for (const constraint of constraints) {\n          const unknownVars = constraint.unknowns.filter(cell => !solutions.has(cell))\n          const knownMines = constraint.unknowns.filter(cell => solutions.get(cell) === 1).length\n          const remainingMines = constraint.remainingBombs - knownMines\n\n          if (remainingMines === 0) {\n            // All remaining unknowns are safe\n            for (const cell of unknownVars) {\n              if (!solutions.has(cell)) {\n                solutions.set(cell, 0)\n                changed = true\n              }\n            }\n          } else if (remainingMines === unknownVars.length) {\n            // All remaining unknowns are mines\n            for (const cell of unknownVars) {\n              if (!solutions.has(cell)) {\n                solutions.set(cell, 1)\n                changed = true\n              }\n            }\n          }\n        }\n      }\n\n      return solutions\n    }\n\n    /**\n     * Solve the minesweeper grid using logical deduction\n     */\n    solve(): SolverResult {\n      const allNewBombs: Position[] = []\n      const allNewClears: Position[] = []\n      let totalChanged = false\n\n      // Keep applying rules until no more changes occur\n      let iterations = 0\n      const maxIterations = 50 // Prevent infinite loops\n\n      while (iterations < maxIterations) {\n        iterations++\n        let iterationChanged = false\n\n        // Apply basic rules\n        const basicResult = this.applyBasicRules()\n        allNewBombs.push(...basicResult.newBombs)\n        allNewClears.push(...basicResult.newClears)\n        iterationChanged = iterationChanged || basicResult.changed\n\n        // Apply advanced subset rules\n        const advancedResult = this.applyAdvancedRules()\n        allNewBombs.push(...advancedResult.newBombs)\n        allNewClears.push(...advancedResult.newClears)\n        iterationChanged = iterationChanged || advancedResult.changed\n\n        // Apply constraint satisfaction\n        const csResult = this.applyConstraintSatisfaction()\n        allNewBombs.push(...csResult.newBombs)\n        allNewClears.push(...csResult.newClears)\n        iterationChanged = iterationChanged || csResult.changed\n\n        // Apply tank solver\n        const tankResult = this.applyTankSolver()\n        allNewBombs.push(...tankResult.newBombs)\n        allNewClears.push(...tankResult.newClears)\n        iterationChanged = iterationChanged || tankResult.changed\n\n        totalChanged = totalChanged || iterationChanged\n\n        if (!iterationChanged) {\n          break\n        }\n      }\n\n      return {\n        grid: this.grid,\n        newBombs: allNewBombs,\n        newClears: allNewClears,\n        changed: totalChanged,\n      }\n    }\n  }\n\n  const classToValue: Record<string, Cell> = {\n    hdd_flag: 9,\n    hdd_type0: 0,\n    hdd_type1: 1,\n    hdd_type2: 2,\n    hdd_type3: 3,\n    hdd_type4: 4,\n    hdd_type5: 5,\n    hdd_type6: 6,\n    hdd_type7: 7,\n    hdd_type8: 8,\n  }\n\n  /**\n   * Extracts the cell's position and value from a DOM element.\n   * @param element - The cell DOM element\n   * @returns Position and value, or null if not found\n   */\n  const processChange = (element: Element): { x: number; y: number; value: Cell } | null => {\n    const xString = element.getAttribute('data-x')\n    const yString = element.getAttribute('data-y')\n    let value: Cell = -1\n    for (const [cls, val] of Object.entries(classToValue)) {\n      if (element.classList.contains(cls)) {\n        value = val\n        break\n      }\n    }\n    if (xString && yString) {\n      const x = parseInt(xString, 10)\n      const y = parseInt(yString, 10)\n      return { x, y, value }\n    }\n    return null\n  }\n\n  /**\n   * Returns the DOM element for a cell at a given position.\n   * @param pos - The cell position\n   */\n  function getCellElement(pos: Position): HTMLElement | null {\n    return document.getElementById(`cell_${pos.x}_${pos.y}`)\n  }\n\n  /**\n   * Checks if a cell is still closed (not revealed).\n   * @param cell - The cell DOM element\n   */\n  function isCellClosed(cell: HTMLElement): boolean {\n    return cell.classList.contains('hdd_closed')\n  }\n  let detectionTimeout: number | undefined\n  const DEBOUNCE_MS = 500\n\n  const OVERLAY_ID = 'minesweeper-solver-overlay'\n\n  /**\n   * Creates a highlight div for a cell overlay.\n   * @param pos - The cell position\n   * @param color - Border color\n   */\n  function createHighlightDiv(pos: Position, color: string): HTMLDivElement | null {\n    const cell = getCellElement(pos)\n    if (!cell) return null\n    if (!isCellClosed(cell)) return null\n    const highlight = document.createElement('div')\n    highlight.style.position = 'absolute'\n    highlight.style.left = `${cell.offsetLeft}px`\n    highlight.style.top = `${cell.offsetTop}px`\n    highlight.style.width = `${cell.offsetWidth}px`\n    highlight.style.height = `${cell.offsetHeight}px`\n    highlight.style.pointerEvents = 'none'\n    highlight.style.boxSizing = 'border-box'\n    highlight.style.border = `2px solid ${color}`\n    highlight.style.borderRadius = '3px'\n    highlight.style.zIndex = '1'\n    return highlight\n  }\n\n  /**\n   * Creates a document fragment containing overlays for known mines and safe cells.\n   * @param knownMines - Array of mine positions\n   * @param knownSafe - Array of safe positions\n   */\n  function createOverlayFragment(knownMines: Position[], knownSafe: Position[]): DocumentFragment {\n    const fragment = document.createDocumentFragment()\n    for (const mine of knownMines) {\n      const div = createHighlightDiv(mine, 'red')\n      if (div) fragment.appendChild(div)\n    }\n    for (const safe of knownSafe) {\n      const div = createHighlightDiv(safe, 'green')\n      if (div) fragment.appendChild(div)\n    }\n    return fragment\n  }\n\n  /**\n   * Updates the overlay on the game board to show known mines and safe cells.\n   * @param knownMines - Array of mine positions\n   * @param knownSafe - Array of safe positions\n   */\n  function updateOverlay(knownMines: Position[], knownSafe: Position[]): void {\n    removeOverlay()\n    const board = document.getElementById('game')\n    if (!board) return\n    const gameBoard = board as HTMLDivElement\n    const overlay = document.createElement('div')\n    overlay.id = OVERLAY_ID\n    overlay.style.position = 'absolute'\n    overlay.style.left = `${gameBoard.offsetLeft}px`\n    overlay.style.top = `${gameBoard.offsetTop}px`\n    overlay.style.width = `${gameBoard.offsetWidth}px`\n    overlay.style.height = `${gameBoard.offsetHeight}px`\n    overlay.style.pointerEvents = 'none'\n    overlay.style.zIndex = '9999'\n    overlay.appendChild(createOverlayFragment(knownMines, knownSafe))\n    board.appendChild(overlay)\n  }\n\n  /**\n   * Removes the overlay from the game board if present.\n   */\n  function removeOverlay(): void {\n    const old = document.getElementById(OVERLAY_ID)\n    if (old?.parentElement) old.parentElement.removeChild(old)\n  }\n\n  /**\n   * Creates a 2D grid representing the current state of the board from the DOM.\n   */\n  function createGrid(): Cell[][] {\n    const grid: Cell[][] = []\n    const cells = document.querySelectorAll('#AreaBlock .cell')\n    for (const cell of cells) {\n      const cellData = processChange(cell)\n      if (cellData) {\n        if (!grid[cellData.y]) {\n          grid[cellData.y] = []\n        }\n        grid[cellData.y][cellData.x] = cellData.value\n      }\n    }\n    return grid\n  }\n\n  /**\n   * Schedules a solver run and overlay update, debounced to avoid excessive computation.\n   */\n  function scheduleDetection(): void {\n    if (detectionTimeout !== undefined) {\n      clearTimeout(detectionTimeout)\n    }\n    detectionTimeout = window.setTimeout(runSolverAndUpdateOverlay, DEBOUNCE_MS)\n  }\n\n  /**\n   * Runs the solver and updates the overlay with the results.\n   */\n  function runSolverAndUpdateOverlay(): void {\n    const grid = createGrid()\n    const solver = new MinesweeperSolver(grid)\n    const result = solver.solve()\n    const knownMines = result.newBombs\n    const knownSafe = result.newClears\n    updateOverlay(knownMines, knownSafe)\n    detectionTimeout = undefined\n  }\n\n  /**\n   * Observes DOM mutations to trigger solver updates when the board changes.\n   */\n  const gameObserver = new MutationObserver(records => {\n    for (const record of records) {\n      if (record.attributeName) {\n        const element = record.target as Element\n        if (element.classList.contains('cell')) {\n          scheduleDetection()\n        }\n      }\n    }\n  })\n\n  /**\n   * Entry point: starts observing the board for changes and triggers the solver.\n   */\n  export const main = (): void => {\n    gameObserver.observe(document, {\n      subtree: true,\n      childList: true,\n      attributeFilter: ['class'],\n    })\n  }\n}\nMinesweeperOnline.main()\n"],
  "mappings": "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",
  "names": ["MinesweeperOnline"]
}
