{
  "version": 3,
  "sources": ["../../src/main/minesweeper-online/minesweeper-online.user.ts"],
  "sourcesContent": ["namespace MinesweeperOnline {\n\ttype Cell = -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n\ttype Grid = Cell[][];\n\n\tinterface Position {\n\t\tx: number; // horizontal axis (column)\n\t\ty: number; // vertical axis (row)\n\t}\n\n\tinterface SolverResult {\n\t\tgrid: Grid;\n\t\tnewBombs: Position[];\n\t\tnewClears: Position[];\n\t\tchanged: boolean;\n\t}\n\n\tinterface ConstraintCell {\n\t\tpos: Position;\n\t\tvalue: number;\n\t\tunknowns: Position[];\n\t\tremainingBombs: number;\n\t}\n\n\tinterface Constraint {\n\t\tunknowns: string[];\n\t\tremainingBombs: number;\n\t}\n\n\tinterface BruteForceResult {\n\t\tnewBombs: Position[];\n\t\tnewClears: Position[];\n\t\tchanged: boolean;\n\t}\n\n\tclass MinesweeperSolver {\n\t\tprivate readonly grid: Grid;\n\t\tprivate readonly rows: number;\n\t\tprivate readonly cols: number;\n\n\t\tconstructor(grid: Grid) {\n\t\t\tthis.grid = grid.map((row) => [...row]); // Deep copy\n\t\t\tthis.rows = grid.length;\n\t\t\tthis.cols = grid[0].length;\n\t\t}\n\n\t\t/**\n\t\t * Get all adjacent positions for a given cell\n\t\t * @param y - vertical position (row)\n\t\t * @param x - horizontal position (column)\n\t\t */\n\t\tprivate getAdjacentPositions(y: number, x: number): Position[] {\n\t\t\tconst adjacent: Position[] = [];\n\n\t\t\tfor (let dy = -1; dy <= 1; dy++) {\n\t\t\t\tfor (let dx = -1; dx <= 1; dx++) {\n\t\t\t\t\tif (dy === 0 && dx === 0) continue;\n\n\t\t\t\t\tconst newY = y + dy;\n\t\t\t\t\tconst newX = x + dx;\n\n\t\t\t\t\tif (newY >= 0 && newY < this.rows && newX >= 0 && newX < this.cols) {\n\t\t\t\t\t\tadjacent.push({ x: newX, y: newY });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn adjacent;\n\t\t}\n\n\t\t/**\n\t\t * Count bombs and unknowns in adjacent cells\n\t\t * @param y - vertical position (row)\n\t\t * @param x - horizontal position (column)\n\t\t */\n\t\tprivate analyzeAdjacent(\n\t\t\ty: number,\n\t\t\tx: number,\n\t\t): {\n\t\t\tbombs: number;\n\t\t\tunknowns: Position[];\n\t\t\tclears: number;\n\t\t} {\n\t\t\tconst adjacent = this.getAdjacentPositions(y, x);\n\t\t\tlet bombs = 0;\n\t\t\tlet clears = 0;\n\t\t\tconst unknowns: Position[] = [];\n\n\t\t\tfor (const pos of adjacent) {\n\t\t\t\tconst cell = this.grid[pos.y][pos.x];\n\t\t\t\tif (cell === 9) {\n\t\t\t\t\tbombs++;\n\t\t\t\t} else if (cell === -1) {\n\t\t\t\t\tunknowns.push(pos);\n\t\t\t\t} else if (cell >= 0 && cell <= 8) {\n\t\t\t\t\tclears++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { bombs, unknowns, clears };\n\t\t}\n\n\t\t/**\n\t\t * Apply basic minesweeper logic rules\n\t\t */\n\t\tprivate applyBasicRules(): {\n\t\t\tnewBombs: Position[];\n\t\t\tnewClears: Position[];\n\t\t\tchanged: boolean;\n\t\t} {\n\t\t\tconst newBombs: Position[] = [];\n\t\t\tconst newClears: Position[] = [];\n\t\t\tlet changed = false;\n\n\t\t\t// Check each numbered cell - iterate through rows (y) and columns (x)\n\t\t\tfor (let y = 0; y < this.rows; y++) {\n\t\t\t\tfor (let x = 0; x < this.cols; x++) {\n\t\t\t\t\tconst cell = this.grid[y][x];\n\n\t\t\t\t\t// Only process numbered cells (1-8)\n\t\t\t\t\tif (cell >= 1 && cell <= 8) {\n\t\t\t\t\t\tconst { bombs, unknowns } = this.analyzeAdjacent(y, x);\n\n\t\t\t\t\t\t// Rule 1: If we've found all bombs, remaining unknowns are clear\n\t\t\t\t\t\tif (bombs === cell && unknowns.length > 0) {\n\t\t\t\t\t\t\tfor (const pos of unknowns) {\n\t\t\t\t\t\t\t\tthis.grid[pos.y][pos.x] = 0;\n\t\t\t\t\t\t\t\tnewClears.push(pos);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Rule 2: If remaining unknowns equal remaining bombs needed, they're all bombs\n\t\t\t\t\t\telse if (bombs + unknowns.length === cell && unknowns.length > 0) {\n\t\t\t\t\t\t\tfor (const pos of unknowns) {\n\t\t\t\t\t\t\t\tthis.grid[pos.y][pos.x] = 9;\n\t\t\t\t\t\t\t\tnewBombs.push(pos);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { newBombs, newClears, changed };\n\t\t}\n\n\t\tprivate getConstraintCells(): Array<{\n\t\t\tpos: Position;\n\t\t\tvalue: number;\n\t\t\tunknowns: Position[];\n\t\t\tremainingBombs: number;\n\t\t}> {\n\t\t\t// Find all numbered cells with unknowns\n\t\t\tconst constraintCells: Array<{\n\t\t\t\tpos: Position;\n\t\t\t\tvalue: number;\n\t\t\t\tunknowns: Position[];\n\t\t\t\tremainingBombs: number;\n\t\t\t}> = [];\n\t\t\tfor (let y = 0; y < this.rows; y++) {\n\t\t\t\tfor (let x = 0; x < this.cols; x++) {\n\t\t\t\t\tconst cell = this.grid[y][x];\n\t\t\t\t\tif (cell >= 1 && cell <= 8) {\n\t\t\t\t\t\tconst { bombs, unknowns } = this.analyzeAdjacent(y, x);\n\t\t\t\t\t\tconst remainingBombs = cell - bombs;\n\t\t\t\t\t\tif (unknowns.length > 0 && remainingBombs > 0) {\n\t\t\t\t\t\t\tconstraintCells.push({\n\t\t\t\t\t\t\t\tpos: { x, y },\n\t\t\t\t\t\t\t\tvalue: cell,\n\t\t\t\t\t\t\t\tunknowns,\n\t\t\t\t\t\t\t\tremainingBombs,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn constraintCells;\n\t\t}\n\n\t\tprivate analyzeConstraintPair(\n\t\t\tcell1: {\n\t\t\t\tpos: Position;\n\t\t\t\tvalue: number;\n\t\t\t\tunknowns: Position[];\n\t\t\t\tremainingBombs: number;\n\t\t\t},\n\t\t\tcell2: {\n\t\t\t\tpos: Position;\n\t\t\t\tvalue: number;\n\t\t\t\tunknowns: Position[];\n\t\t\t\tremainingBombs: number;\n\t\t\t},\n\t\t) {\n\t\t\tconst newBombs = [];\n\t\t\tconst newClears = [];\n\t\t\tlet changed = false;\n\n\t\t\tconst unknowns1Set = new Set(cell1.unknowns.map((p) => `${p.x},${p.y}`));\n\t\t\tconst unknowns2Set = new Set(cell2.unknowns.map((p) => `${p.x},${p.y}`));\n\n\t\t\t// Case 1: cell1 unknowns are subset of cell2 unknowns\n\t\t\tif (cell1.unknowns.every((p) => unknowns2Set.has(`${p.x},${p.y}`))) {\n\t\t\t\tconst difference = cell2.unknowns.filter(\n\t\t\t\t\t(p) => !unknowns1Set.has(`${p.x},${p.y}`),\n\t\t\t\t);\n\t\t\t\tconst bombDifference = cell2.remainingBombs - cell1.remainingBombs;\n\n\t\t\t\tif (bombDifference === 0 && difference.length > 0) {\n\t\t\t\t\t// All difference cells are safe\n\t\t\t\t\tfor (const pos of difference) {\n\t\t\t\t\t\tif (this.grid[pos.y][pos.x] === -1) {\n\t\t\t\t\t\t\tthis.grid[pos.y][pos.x] = 0;\n\t\t\t\t\t\t\tnewClears.push(pos);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tbombDifference === difference.length &&\n\t\t\t\t\tdifference.length > 0\n\t\t\t\t) {\n\t\t\t\t\t// All difference cells are mines\n\t\t\t\t\tfor (const pos of difference) {\n\t\t\t\t\t\tif (this.grid[pos.y][pos.x] === -1) {\n\t\t\t\t\t\t\tthis.grid[pos.y][pos.x] = 9;\n\t\t\t\t\t\t\tnewBombs.push(pos);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Case 2: cell2 unknowns are subset of cell1 unknowns\n\t\t\telse if (cell2.unknowns.every((p) => unknowns1Set.has(`${p.x},${p.y}`))) {\n\t\t\t\tconst difference = cell1.unknowns.filter(\n\t\t\t\t\t(p) => !unknowns2Set.has(`${p.x},${p.y}`),\n\t\t\t\t);\n\t\t\t\tconst bombDifference = cell1.remainingBombs - cell2.remainingBombs;\n\n\t\t\t\tif (bombDifference === 0 && difference.length > 0) {\n\t\t\t\t\t// All difference cells are safe\n\t\t\t\t\tfor (const pos of difference) {\n\t\t\t\t\t\tif (this.grid[pos.y][pos.x] === -1) {\n\t\t\t\t\t\t\tthis.grid[pos.y][pos.x] = 0;\n\t\t\t\t\t\t\tnewClears.push(pos);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tbombDifference === difference.length &&\n\t\t\t\t\tdifference.length > 0\n\t\t\t\t) {\n\t\t\t\t\t// All difference cells are mines\n\t\t\t\t\tfor (const pos of difference) {\n\t\t\t\t\t\tif (this.grid[pos.y][pos.x] === -1) {\n\t\t\t\t\t\t\tthis.grid[pos.y][pos.x] = 9;\n\t\t\t\t\t\t\tnewBombs.push(pos);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { newBombs, newClears, changed };\n\t\t}\n\n\t\t/**\n\t\t * Apply advanced constraint satisfaction techniques\n\t\t */\n\t\tprivate applyAdvancedRules(): {\n\t\t\tnewBombs: Position[];\n\t\t\tnewClears: Position[];\n\t\t\tchanged: boolean;\n\t\t} {\n\t\t\tconst newBombs: Position[] = [];\n\t\t\tconst newClears: Position[] = [];\n\t\t\tlet changed = false;\n\n\t\t\t// Find all numbered cells with unknowns\n\t\t\tconst constraintCells = this.getConstraintCells();\n\n\t\t\t// Look for subset relationships between constraint cells\n\t\t\tfor (let i = 0; i < constraintCells.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < constraintCells.length; j++) {\n\t\t\t\t\tconst result = this.analyzeConstraintPair(\n\t\t\t\t\t\tconstraintCells[i],\n\t\t\t\t\t\tconstraintCells[j],\n\t\t\t\t\t);\n\t\t\t\t\tif (result.changed) {\n\t\t\t\t\t\tnewBombs.push(...result.newBombs);\n\t\t\t\t\t\tnewClears.push(...result.newClears);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { newBombs, newClears, changed };\n\t\t}\n\n\t\tprivate solveBruteForce(\n\t\t\tconstraintCells: ConstraintCell[],\n\t\t\tunknownsList: string[],\n\t\t\tunknownsMap: Map<string, number>,\n\t\t): BruteForceResult {\n\t\t\tconst newBombs: Position[] = [];\n\t\t\tconst newClears: Position[] = [];\n\t\t\tlet changed = false;\n\n\t\t\tconst n = unknownsList.length;\n\t\t\tconst validSolutions: number[][] = [];\n\n\t\t\t// Generate all possible mine configurations\n\t\t\tfor (let mask = 0; mask < 1 << n; mask++) {\n\t\t\t\tconst solution: number[] = new Array(n).fill(0);\n\t\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\t\tif (mask & (1 << i)) {\n\t\t\t\t\t\tsolution[i] = 1; // mine\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check if this solution satisfies all constraints\n\t\t\t\tlet valid = true;\n\t\t\t\tfor (const constraint of constraintCells) {\n\t\t\t\t\tlet mineCount = 0;\n\t\t\t\t\tfor (const pos of constraint.unknowns) {\n\t\t\t\t\t\tconst key = `${pos.x},${pos.y}`;\n\t\t\t\t\t\tconst index = unknownsMap.get(key);\n\t\t\t\t\t\tif (index !== undefined && solution[index] === 1) {\n\t\t\t\t\t\t\tmineCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (mineCount !== constraint.remainingBombs) {\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (valid) {\n\t\t\t\t\tvalidSolutions.push(solution);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Find cells that have the same value in ALL valid solutions\n\t\t\tif (validSolutions.length > 0) {\n\t\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\t\tconst firstValue = validSolutions[0][i];\n\t\t\t\t\tconst allSame = validSolutions.every((sol) => sol[i] === firstValue);\n\n\t\t\t\t\tif (allSame) {\n\t\t\t\t\t\tconst key = unknownsList[i];\n\t\t\t\t\t\tconst [x, y] = key.split(\",\").map(Number);\n\n\t\t\t\t\t\tif (firstValue === 1) {\n\t\t\t\t\t\t\t// All solutions have mine here\n\t\t\t\t\t\t\tif (this.grid[y][x] === -1) {\n\t\t\t\t\t\t\t\tthis.grid[y][x] = 9;\n\t\t\t\t\t\t\t\tnewBombs.push({ x, y });\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// All solutions have safe cell here\n\t\t\t\t\t\t\tif (this.grid[y][x] === -1) {\n\t\t\t\t\t\t\t\tthis.grid[y][x] = 0;\n\t\t\t\t\t\t\t\tnewClears.push({ x, y });\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { newBombs, newClears, changed };\n\t\t}\n\n\t\t// NEW: Advanced constraint satisfaction using equation solving\n\t\tprivate applyConstraintSatisfaction() {\n\t\t\tconst newBombs: Position[] = [];\n\t\t\tconst newClears: Position[] = [];\n\t\t\tlet changed = false;\n\n\t\t\tconst constraintCells = this.getConstraintCells();\n\t\t\tif (constraintCells.length === 0) return { newBombs, newClears, changed };\n\n\t\t\t// Build system of linear constraints\n\t\t\tconst allUnknowns = new Set<string>();\n\t\t\tconstraintCells.forEach((cell) => {\n\t\t\t\tcell.unknowns.forEach((pos) => {\n\t\t\t\t\tallUnknowns.add(`${pos.x},${pos.y}`);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tconst unknownsList = Array.from(allUnknowns);\n\t\t\tconst unknownsMap = new Map();\n\t\t\tunknownsList.forEach((key, index) => {\n\t\t\t\tunknownsMap.set(key, index);\n\t\t\t});\n\n\t\t\t// Try all possible combinations for small constraint sets\n\t\t\tif (unknownsList.length <= 15) {\n\t\t\t\t// Limit for performance\n\t\t\t\tconst result = this.solveBruteForce(\n\t\t\t\t\tconstraintCells,\n\t\t\t\t\tunknownsList,\n\t\t\t\t\tunknownsMap,\n\t\t\t\t);\n\t\t\t\tif (result.changed) {\n\t\t\t\t\tnewBombs.push(...result.newBombs);\n\t\t\t\t\tnewClears.push(...result.newClears);\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { newBombs, newClears, changed };\n\t\t}\n\n\t\tprivate solveConstraintMatrix(\n\t\t\tconstraints: Constraint[]\n\t\t): Map<string, 0 | 1> {\n\t\t\tconst solutions = new Map<string, 0 | 1>();\n\n\t\t\t// Simple constraint propagation\n\t\t\tlet changed = true;\n\t\t\twhile (changed) {\n\t\t\t\tchanged = false;\n\n\t\t\t\tfor (const constraint of constraints) {\n\t\t\t\t\tconst unknownVars = constraint.unknowns.filter(\n\t\t\t\t\t\t(cell) => !solutions.has(cell),\n\t\t\t\t\t);\n\t\t\t\t\tconst knownMines = constraint.unknowns.filter(\n\t\t\t\t\t\t(cell) => solutions.get(cell) === 1,\n\t\t\t\t\t).length;\n\t\t\t\t\tconst remainingMines = constraint.remainingBombs - knownMines;\n\n\t\t\t\t\tif (remainingMines === 0) {\n\t\t\t\t\t\t// All remaining unknowns are safe\n\t\t\t\t\t\tfor (const cell of unknownVars) {\n\t\t\t\t\t\t\tif (!solutions.has(cell)) {\n\t\t\t\t\t\t\t\tsolutions.set(cell, 0);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (remainingMines === unknownVars.length) {\n\t\t\t\t\t\t// All remaining unknowns are mines\n\t\t\t\t\t\tfor (const cell of unknownVars) {\n\t\t\t\t\t\t\tif (!solutions.has(cell)) {\n\t\t\t\t\t\t\t\tsolutions.set(cell, 1);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn solutions;\n\t\t}\n\n\t\t// NEW: Tank solver - advanced pattern recognition\n\t\tprivate applyTankSolver() {\n\t\t\tconst newBombs = [];\n\t\t\tconst newClears = [];\n\t\t\tlet changed = false;\n\n\t\t\t// Find border cells (unknowns adjacent to revealed numbers)\n\t\t\tconst borderCells = new Set<string>();\n\t\t\tconst constraints = [];\n\n\t\t\tfor (let y = 0; y < this.rows; y++) {\n\t\t\t\tfor (let x = 0; x < this.cols; x++) {\n\t\t\t\t\tconst cell = this.grid[y][x];\n\t\t\t\t\tif (cell >= 1 && cell <= 8) {\n\t\t\t\t\t\tconst { bombs, unknowns } = this.analyzeAdjacent(y, x);\n\t\t\t\t\t\tconst remainingBombs = cell - bombs;\n\n\t\t\t\t\t\tif (unknowns.length > 0 && remainingBombs > 0) {\n\t\t\t\t\t\t\tunknowns.forEach((pos) => { borderCells.add(`${pos.x},${pos.y}`); });\n\t\t\t\t\t\t\tconstraints.push({\n\t\t\t\t\t\t\t\tunknowns: unknowns.map((pos) => `${pos.x},${pos.y}`),\n\t\t\t\t\t\t\t\tremainingBombs,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Use Gaussian elimination on constraint matrix\n\t\t\tif (borderCells.size > 0 && borderCells.size <= 20) {\n\t\t\t\tconst result = this.solveConstraintMatrix(constraints);\n\n\t\t\t\tfor (const [cellKey, value] of result.entries()) {\n\t\t\t\t\tconst [x, y] = cellKey.split(\",\").map(Number);\n\t\t\t\t\tif (value === 1 && this.grid[y][x] === -1) {\n\t\t\t\t\t\tthis.grid[y][x] = 9;\n\t\t\t\t\t\tnewBombs.push({ x, y });\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t} else if (value === 0 && this.grid[y][x] === -1) {\n\t\t\t\t\t\tthis.grid[y][x] = 0;\n\t\t\t\t\t\tnewClears.push({ x, y });\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { newBombs, newClears, changed };\n\t\t}\n\n\t\t/**\n\t\t * Solve the minesweeper grid using logical deduction\n\t\t */\n\t\tsolve(): SolverResult {\n\t\t\tconst allNewBombs: Position[] = [];\n\t\t\tconst allNewClears: Position[] = [];\n\t\t\tlet totalChanged = false;\n\n\t\t\t// Keep applying rules until no more changes occur\n\t\t\tlet iterations = 0;\n\t\t\tconst maxIterations = 50; // Prevent infinite loops\n\n\t\t\twhile (iterations < maxIterations) {\n\t\t\t\titerations++;\n\t\t\t\tlet iterationChanged = false;\n\n\t\t\t\t// Apply basic rules\n\t\t\t\tconst basicResult = this.applyBasicRules();\n\t\t\t\tallNewBombs.push(...basicResult.newBombs);\n\t\t\t\tallNewClears.push(...basicResult.newClears);\n\t\t\t\titerationChanged = iterationChanged || basicResult.changed;\n\n\t\t\t\t// Apply advanced subset rules\n\t\t\t\tconst advancedResult = this.applyAdvancedRules();\n\t\t\t\tallNewBombs.push(...advancedResult.newBombs);\n\t\t\t\tallNewClears.push(...advancedResult.newClears);\n\t\t\t\titerationChanged = iterationChanged || advancedResult.changed;\n\n\t\t\t\t// Apply constraint satisfaction\n\t\t\t\tconst csResult = this.applyConstraintSatisfaction();\n\t\t\t\tallNewBombs.push(...csResult.newBombs);\n\t\t\t\tallNewClears.push(...csResult.newClears);\n\t\t\t\titerationChanged = iterationChanged || csResult.changed;\n\n\t\t\t\t// Apply tank solver\n\t\t\t\tconst tankResult = this.applyTankSolver();\n\t\t\t\tallNewBombs.push(...tankResult.newBombs);\n\t\t\t\tallNewClears.push(...tankResult.newClears);\n\t\t\t\titerationChanged = iterationChanged || tankResult.changed;\n\n\t\t\t\ttotalChanged = totalChanged || iterationChanged;\n\n\t\t\t\tif (!iterationChanged) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tgrid: this.grid,\n\t\t\t\tnewBombs: allNewBombs,\n\t\t\t\tnewClears: allNewClears,\n\t\t\t\tchanged: totalChanged,\n\t\t\t};\n\t\t}\n\t}\n\n\tconst classToValue: Record<string, Cell> = {\n\t\thdd_flag: 9,\n\t\thdd_type0: 0,\n\t\thdd_type1: 1,\n\t\thdd_type2: 2,\n\t\thdd_type3: 3,\n\t\thdd_type4: 4,\n\t\thdd_type5: 5,\n\t\thdd_type6: 6,\n\t\thdd_type7: 7,\n\t\thdd_type8: 8,\n\t};\n\n\tconst processChange = (element: Element) => {\n\t\t// example data\n\t\tconst xString = element.getAttribute(\"data-x\");\n\t\tconst yString = element.getAttribute(\"data-y\");\n\t\tlet value: Cell = -1;\n\t\tfor (const [cls, val] of Object.entries(classToValue)) {\n\t\t\tif (element.classList.contains(cls)) {\n\t\t\t\tvalue = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (xString && yString) {\n\t\t\tconst x = parseInt(xString, 10);\n\t\t\tconst y = parseInt(yString, 10);\n\t\t\treturn { x, y, value };\n\t\t}\n\t\treturn null;\n\t};\n\n\tlet detectionTimeout: number | undefined;\n\tconst DEBOUNCE_MS = 500;\n\n\tconst OVERLAY_ID = \"minesweeper-solver-overlay\";\n\n\tfunction createOverlayFragment(\n\t\tknownMines: Position[],\n\t\tknownSafe: Position[],\n\t) {\n\t\tconst fragment = document.createDocumentFragment();\n\n\t\t// Helper to create a highlight div for a cell\n\t\tfunction createHighlightDiv(pos: Position, color: string) {\n\t\t\tconst cell = document.getElementById(`cell_${pos.x}_${pos.y}`);\n\t\t\tif (!cell) return null;\n\n\t\t\t// Make sure it hasn't be revealed already\n\t\t\tif (!cell.classList.contains(\"hdd_closed\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Position relative to the board container\n\t\t\tconst highlight = document.createElement(\"div\");\n\t\t\thighlight.style.position = \"absolute\";\n\t\t\thighlight.style.left = `${cell.offsetLeft}px`;\n\t\t\thighlight.style.top = `${cell.offsetTop}px`;\n\t\t\thighlight.style.width = `${cell.offsetWidth}px`;\n\t\t\thighlight.style.height = `${cell.offsetHeight}px`;\n\t\t\thighlight.style.pointerEvents = \"none\";\n\t\t\thighlight.style.boxSizing = \"border-box\";\n\t\t\thighlight.style.border = `2px solid ${color}`;\n\t\t\thighlight.style.borderRadius = \"3px\";\n\t\t\thighlight.style.zIndex = \"1\";\n\t\t\treturn highlight;\n\t\t}\n\n\t\tfor (const mine of knownMines) {\n\t\t\tconst div = createHighlightDiv(mine, \"red\");\n\t\t\tif (div) fragment.appendChild(div);\n\t\t}\n\t\tfor (const safe of knownSafe) {\n\t\t\tconst div = createHighlightDiv(safe, \"green\");\n\t\t\tif (div) fragment.appendChild(div);\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tfunction updateOverlay(knownMines: Position[], knownSafe: Position[]) {\n\t\t// Remove old overlay if present\n\t\tconst old = document.getElementById(OVERLAY_ID);\n\t\tif (old?.parentElement) old.parentElement.removeChild(old);\n\n\t\t// Find the board container (adjust selector as needed)\n\t\tconst board = document.getElementById(\"game\");\n\t\tif (!board) return;\n\t\tconst gameBoard = board as HTMLDivElement;\n\n\t\t// Create overlay container\n\t\tconst overlay = document.createElement(\"div\");\n\t\toverlay.id = OVERLAY_ID;\n\t\toverlay.style.position = \"absolute\";\n\t\toverlay.style.left = \"0\";\n\t\toverlay.style.top = \"0\";\n\t\toverlay.style.width = \"100%\";\n\t\toverlay.style.height = \"100%\";\n\t\toverlay.style.pointerEvents = \"none\";\n\t\toverlay.style.zIndex = \"9999\";\n\n\t\t// Position overlay absolutely over the board\n\t\toverlay.style.left = `${gameBoard.offsetLeft}px`;\n\t\toverlay.style.top = `${gameBoard.offsetTop}px`;\n\t\toverlay.style.width = `${gameBoard.offsetWidth}px`;\n\t\toverlay.style.height = `${gameBoard.offsetHeight}px`;\n\n\t\t// Add highlights\n\t\toverlay.appendChild(createOverlayFragment(knownMines, knownSafe));\n\n\t\t// Insert overlay into board container\n\t\tboard.appendChild(overlay);\n\t}\n\n\tconst createGrid = () => {\n\t\tconst grid: Cell[][] = [];\n\t\tconst cells = document.querySelectorAll(\"#AreaBlock .cell\");\n\t\tfor (const cell of cells) {\n\t\t\tconst cellData = processChange(cell);\n\t\t\tif (cellData) {\n\t\t\t\tif (!grid[cellData.y]) {\n\t\t\t\t\tgrid[cellData.y] = [];\n\t\t\t\t}\n\t\t\t\tgrid[cellData.y][cellData.x] = cellData.value;\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t};\n\n\tconst scheduleDetection = () => {\n\t\tif (detectionTimeout !== undefined) {\n\t\t\tclearTimeout(detectionTimeout);\n\t\t}\n\t\tdetectionTimeout = window.setTimeout(() => {\n\t\t\tconst grid = createGrid();\n\t\t\tconst solver = new MinesweeperSolver(grid);\n\t\t\tconst result = solver.solve();\n\t\t\tconst knownMines = result.newBombs;\n\t\t\tconst knownSafe = result.newClears;\n\t\t\tupdateOverlay(knownMines, knownSafe);\n\t\t\tdetectionTimeout = undefined;\n\t\t}, DEBOUNCE_MS);\n\t};\n\n\tconst gameObserver = new MutationObserver((records) => {\n\t\tfor (const record of records) {\n\t\t\tif (record.attributeName) {\n\t\t\t\t// target is the element so type it\n\t\t\t\tconst element = record.target as Element;\n\t\t\t\tif (element.classList.contains(\"cell\")) {\n\t\t\t\t\tscheduleDetection();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\texport const main = () => {\n\t\tgameObserver.observe(document, {\n\t\t\tsubtree: true,\n\t\t\tchildList: true,\n\t\t\tattributeFilter: [\"class\"],\n\t\t});\n\t};\n}\nMinesweeperOnline.main();\n"],
  "mappings": "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",
  "names": ["MinesweeperOnline"]
}
