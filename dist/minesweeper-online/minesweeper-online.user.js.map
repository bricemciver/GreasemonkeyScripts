{
  "version": 3,
  "sources": ["../../src/main/minesweeper-online/minesweeper-online.user.ts"],
  "sourcesContent": ["namespace MinesweeperOnline {\n\n  type Cell = -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n  type Grid = Cell[][];\n\n  interface Position {\n    x: number; // horizontal axis (column)\n    y: number; // vertical axis (row)\n  }\n\n  interface SolverResult {\n    grid: Grid;\n    newBombs: Position[];\n    newClears: Position[];\n    changed: boolean;\n  }\n\n  class MinesweeperSolver {\n    private readonly grid: Grid;\n    private readonly rows: number;\n    private readonly cols: number;\n\n    constructor(grid: Grid) {\n      this.grid = grid.map(row => [...row]); // Deep copy\n      this.rows = grid.length;\n      this.cols = grid[0].length;\n    }\n\n    /**\n     * Get all adjacent positions for a given cell\n     * @param y - vertical position (row)\n     * @param x - horizontal position (column)\n     */\n    private getAdjacentPositions(y: number, x: number): Position[] {\n      const adjacent: Position[] = [];\n\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          if (dy === 0 && dx === 0) continue;\n\n          const newY = y + dy;\n          const newX = x + dx;\n\n          if (newY >= 0 && newY < this.rows &&\n            newX >= 0 && newX < this.cols) {\n            adjacent.push({ x: newX, y: newY });\n          }\n        }\n      }\n\n      return adjacent;\n    }\n\n    /**\n     * Count bombs and unknowns in adjacent cells\n     * @param y - vertical position (row)\n     * @param x - horizontal position (column)\n     */\n    private analyzeAdjacent(y: number, x: number): {\n      bombs: number;\n      unknowns: Position[];\n      clears: number;\n    } {\n      const adjacent = this.getAdjacentPositions(y, x);\n      let bombs = 0;\n      let clears = 0;\n      const unknowns: Position[] = [];\n\n      for (const pos of adjacent) {\n        const cell = this.grid[pos.y][pos.x];\n        if (cell === 9) {\n          bombs++;\n        } else if (cell === -1) {\n          unknowns.push(pos);\n        } else if (cell >= 0 && cell <= 8) {\n          clears++;\n        }\n      }\n\n      return { bombs, unknowns, clears };\n    }\n\n    /**\n     * Apply basic minesweeper logic rules\n     */\n    private applyBasicRules(): { newBombs: Position[]; newClears: Position[]; changed: boolean } {\n      const newBombs: Position[] = [];\n      const newClears: Position[] = [];\n      let changed = false;\n\n      // Check each numbered cell - iterate through rows (y) and columns (x)\n      for (let y = 0; y < this.rows; y++) {\n        for (let x = 0; x < this.cols; x++) {\n          const cell = this.grid[y][x];\n\n          // Only process numbered cells (1-8)\n          if (cell >= 1 && cell <= 8) {\n            const { bombs, unknowns } = this.analyzeAdjacent(y, x);\n\n            // Rule 1: If we've found all bombs, remaining unknowns are clear\n            if (bombs === cell && unknowns.length > 0) {\n              for (const pos of unknowns) {\n                this.grid[pos.y][pos.x] = 0;\n                newClears.push(pos);\n                changed = true;\n              }\n            }\n\n            // Rule 2: If remaining unknowns equal remaining bombs needed, they're all bombs\n            else if (bombs + unknowns.length === cell && unknowns.length > 0) {\n              for (const pos of unknowns) {\n                this.grid[pos.y][pos.x] = 9;\n                newBombs.push(pos);\n                changed = true;\n              }\n            }\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed };\n    }\n\n    /**\n     * Apply advanced constraint satisfaction techniques\n     */\n    private applyAdvancedRules(): { newBombs: Position[]; newClears: Position[]; changed: boolean } {\n      const newBombs: Position[] = [];\n      const newClears: Position[] = [];\n      let changed = false;\n\n      // Find all numbered cells with unknowns\n      const constraintCells: Array<{\n        pos: Position;\n        value: number;\n        unknowns: Position[];\n        remainingBombs: number;\n      }> = [];\n\n      for (let y = 0; y < this.rows; y++) {\n        for (let x = 0; x < this.cols; x++) {\n          const cell = this.grid[y][x];\n          if (cell >= 1 && cell <= 8) {\n            const { bombs, unknowns } = this.analyzeAdjacent(y, x);\n            const remainingBombs = cell - bombs;\n\n            if (unknowns.length > 0 && remainingBombs > 0) {\n              constraintCells.push({\n                pos: { x, y },\n                value: cell,\n                unknowns,\n                remainingBombs\n              });\n            }\n          }\n        }\n      }\n\n      // Look for subset relationships between constraint cells\n      for (let i = 0; i < constraintCells.length; i++) {\n        for (let j = i + 1; j < constraintCells.length; j++) {\n          const cell1 = constraintCells[i];\n          const cell2 = constraintCells[j];\n\n          // Check if one set of unknowns is a subset of another\n          const unknowns1Set = new Set(cell1.unknowns.map(p => `${p.x},${p.y}`));\n          const unknowns2Set = new Set(cell2.unknowns.map(p => `${p.x},${p.y}`));\n\n          // If cell1's unknowns are a subset of cell2's unknowns\n          if (cell1.unknowns.every(p => unknowns2Set.has(`${p.x},${p.y}`))) {\n            const difference = cell2.unknowns.filter(p => !unknowns1Set.has(`${p.x},${p.y}`));\n            const bombDifference = cell2.remainingBombs - cell1.remainingBombs;\n\n            if (bombDifference === 0 && difference.length > 0) {\n              // All difference cells are clear\n              for (const pos of difference) {\n                if (this.grid[pos.y][pos.x] === -1) {\n                  this.grid[pos.y][pos.x] = 0;\n                  newClears.push(pos);\n                  changed = true;\n                }\n              }\n            } else if (bombDifference === difference.length && difference.length > 0) {\n              // All difference cells are bombs\n              for (const pos of difference) {\n                if (this.grid[pos.y][pos.x] === -1) {\n                  this.grid[pos.y][pos.x] = 9;\n                  newBombs.push(pos);\n                  changed = true;\n                }\n              }\n            }\n          }\n          // If cell2's unknowns are a subset of cell1's unknowns\n          else if (cell2.unknowns.every(p => unknowns1Set.has(`${p.x},${p.y}`))) {\n            const difference = cell1.unknowns.filter(p => !unknowns2Set.has(`${p.x},${p.y}`));\n            const bombDifference = cell1.remainingBombs - cell2.remainingBombs;\n\n            if (bombDifference === 0 && difference.length > 0) {\n              // All difference cells are clear\n              for (const pos of difference) {\n                if (this.grid[pos.y][pos.x] === -1) {\n                  this.grid[pos.y][pos.x] = 0;\n                  newClears.push(pos);\n                  changed = true;\n                }\n              }\n            } else if (bombDifference === difference.length && difference.length > 0) {\n              // All difference cells are bombs\n              for (const pos of difference) {\n                if (this.grid[pos.y][pos.x] === -1) {\n                  this.grid[pos.y][pos.x] = 9;\n                  newBombs.push(pos);\n                  changed = true;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return { newBombs, newClears, changed };\n    }\n\n    /**\n     * Solve the minesweeper grid using logical deduction\n     */\n    solve(): SolverResult {\n      const allNewBombs: Position[] = [];\n      const allNewClears: Position[] = [];\n      let totalChanged = false;\n\n      // Keep applying rules until no more changes occur\n      let iterations = 0;\n      const maxIterations = 100; // Prevent infinite loops\n\n      while (iterations < maxIterations) {\n        iterations++;\n\n        // Apply basic rules\n        const basicResult = this.applyBasicRules();\n        allNewBombs.push(...basicResult.newBombs);\n        allNewClears.push(...basicResult.newClears);\n\n        // Apply advanced rules\n        const advancedResult = this.applyAdvancedRules();\n        allNewBombs.push(...advancedResult.newBombs);\n        allNewClears.push(...advancedResult.newClears);\n\n        const changed = basicResult.changed || advancedResult.changed;\n        totalChanged = totalChanged || changed;\n\n        if (!changed) {\n          break; // No more deductions possible\n        }\n      }\n\n      return {\n        grid: this.grid,\n        newBombs: allNewBombs,\n        newClears: allNewClears,\n        changed: totalChanged\n      };\n    }\n  }\n\n  const classToValue: Record<string, Cell> = {\n    \"hdd_flag\": 9,\n    \"hdd_type0\": 0,\n    \"hdd_type1\": 1,\n    \"hdd_type2\": 2,\n    \"hdd_type3\": 3,\n    \"hdd_type4\": 4,\n    \"hdd_type5\": 5,\n    \"hdd_type6\": 6,\n    \"hdd_type7\": 7,\n    \"hdd_type8\": 8,\n  };\n\n  const processChange = (element: Element) => {\n    // example data\n    const xString = element.getAttribute(\"data-x\");\n    const yString = element.getAttribute(\"data-y\");\n    let value: Cell = -1;\n    for (const [cls, val] of Object.entries(classToValue)) {\n      if (element.classList.contains(cls)) {\n        value = val;\n        break;\n      }\n    }\n    if (xString && yString) {\n      const x = parseInt(xString, 10);\n      const y = parseInt(yString, 10);\n      return { x, y, value };\n    }\n    return null;\n  }\n\n  let detectionTimeout: number | undefined;\n  const DEBOUNCE_MS = 500;\n\n  const OVERLAY_ID = \"minesweeper-solver-overlay\";\n\n  function createOverlayFragment(knownMines: Position[], knownSafe: Position[]) {\n    const fragment = document.createDocumentFragment();\n\n    // Helper to create a highlight div for a cell\n    function createHighlightDiv(pos: Position, color: string) {\n      const cell = document.getElementById(`cell_${pos.x}_${pos.y}`);\n      if (!cell) return null;\n\n      // Make sure it hasn't be revealed already\n      if (!cell.classList.contains(\"hdd_closed\")) {\n        return null;\n      }\n\n      // Position relative to the board container\n      const highlight = document.createElement(\"div\");\n      highlight.style.position = \"absolute\";\n      highlight.style.left = `${cell.offsetLeft}px`;\n      highlight.style.top = `${cell.offsetTop}px`;\n      highlight.style.width = `${cell.offsetWidth}px`;\n      highlight.style.height = `${cell.offsetHeight}px`;\n      highlight.style.pointerEvents = \"none\";\n      highlight.style.boxSizing = \"border-box\";\n      highlight.style.border = `2px solid ${color}`;\n      highlight.style.borderRadius = \"3px\";\n      highlight.style.zIndex = \"1\";\n      return highlight;\n    }\n\n    for (const mine of knownMines) {\n      const div = createHighlightDiv(mine, \"red\");\n      if (div) fragment.appendChild(div);\n    }\n    for (const safe of knownSafe) {\n      const div = createHighlightDiv(safe, \"green\");\n      if (div) fragment.appendChild(div);\n    }\n    return fragment;\n  }\n\n  function updateOverlay(knownMines: Position[], knownSafe: Position[]) {\n    // Remove old overlay if present\n    const old = document.getElementById(OVERLAY_ID);\n    if (old?.parentElement) old.parentElement.removeChild(old);\n\n    // Find the board container (adjust selector as needed)\n    const board = document.getElementById(\"game\")\n    if (!board) return;\n    const gameBoard = board as HTMLDivElement\n\n    // Create overlay container\n    const overlay = document.createElement(\"div\");\n    overlay.id = OVERLAY_ID;\n    overlay.style.position = \"absolute\";\n    overlay.style.left = \"0\";\n    overlay.style.top = \"0\";\n    overlay.style.width = \"100%\";\n    overlay.style.height = \"100%\";\n    overlay.style.pointerEvents = \"none\";\n    overlay.style.zIndex = \"9999\";\n\n    // Position overlay absolutely over the board\n    overlay.style.left = `${gameBoard.offsetLeft}px`;\n    overlay.style.top = `${gameBoard.offsetTop}px`;\n    overlay.style.width = `${gameBoard.offsetWidth}px`;\n    overlay.style.height = `${gameBoard.offsetHeight}px`;\n\n    // Add highlights\n    overlay.appendChild(createOverlayFragment(knownMines, knownSafe));\n\n    // Insert overlay into board container\n    board.appendChild(overlay);\n  }\n\n  const createGrid = () => {\n    const grid: Cell[][] = [];\n    const cells = document.querySelectorAll(\"#AreaBlock .cell\");\n    for (const cell of cells) {\n      const cellData = processChange(cell);\n      if (cellData) {\n        if (!grid[cellData.y]) {\n          grid[cellData.y] = [];\n        }\n        grid[cellData.y][cellData.x] = cellData.value;\n      }\n    }\n    return grid;\n  }\n\n  const scheduleDetection = () => {\n    if (detectionTimeout !== undefined) {\n      clearTimeout(detectionTimeout);\n    }\n    detectionTimeout = window.setTimeout(() => {\n      const grid = createGrid();\n      const solver = new MinesweeperSolver(grid);\n      const result = solver.solve();\n      const knownMines = result.newBombs;\n      const knownSafe = result.newClears;\n      updateOverlay(knownMines, knownSafe);\n      detectionTimeout = undefined;\n    }, DEBOUNCE_MS);\n  };\n\n  const gameObserver = new MutationObserver((records) => {\n    for (const record of records) {\n      if (record.attributeName) {\n        // target is the element so type it\n        const element = record.target as Element;\n        if (element.classList.contains(\"cell\")) {\n          scheduleDetection();\n        }\n      }\n    }\n  })\n\n  export const main = () => {\n    gameObserver.observe(document, { subtree: true, childList: true, attributeFilter: [\"class\"] });\n  }\n}\nMinesweeperOnline.main();\n"],
  "mappings": "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",
  "names": ["MinesweeperOnline"]
}
