{
  "version": 3,
  "sources": ["../../node_modules/@badrap/result/src/index.ts", "../../node_modules/chessops/src/squareSet.ts", "../../node_modules/chessops/src/types.ts", "../../node_modules/chessops/src/util.ts", "../../node_modules/chessops/src/attacks.ts", "../../node_modules/chessops/src/board.ts", "../../node_modules/chessops/src/chess.ts", "../../node_modules/chessops/src/setup.ts", "../../node_modules/chessops/src/fen.ts", "../../node_modules/chessops/src/variant.ts", "../../node_modules/chessops/src/pgn.ts", "../../node_modules/chessops/src/san.ts", "../../src/main/lichess-opening-explorer/lichess-opening-explorer.user.ts"],
  "sourcesContent": ["abstract class _Result<T, E extends Error> {\n  protected abstract _chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>,\n  ): Result<X, U>;\n\n  unwrap(): T;\n  unwrap<U>(ok: (value: T) => U): U;\n  unwrap<U, V>(ok: (value: T) => U, err: (error: E) => V): U | V;\n  unwrap<U>(ok: (value: T) => U, err: (error: E) => U): U;\n  unwrap(ok?: (value: T) => unknown, err?: (error: E) => unknown): unknown {\n    const r = this._chain(\n      (value) => Result.ok(ok ? ok(value) : value),\n      (error) => (err ? Result.ok(err(error)) : Result.err(error)),\n    );\n    if (r.isErr) {\n      throw r.error;\n    }\n    return r.value;\n  }\n\n  map<U>(ok: (value: T) => U): Result<U, E>;\n  map<U, F extends Error>(\n    ok: (value: T) => U,\n    err: (error: E) => F,\n  ): Result<U, F>;\n  map(ok: (value: T) => unknown, err?: (error: E) => Error): Result<unknown> {\n    return this._chain(\n      (value) => Result.ok(ok(value)),\n      (error) => Result.err(err ? err(error) : error),\n    );\n  }\n\n  chain<X>(ok: (value: T) => Result<X, E>): Result<X, E>;\n  chain<X>(\n    ok: (value: T) => Result<X, E>,\n    err: (error: E) => Result<X, E>,\n  ): Result<X, E>;\n  chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>,\n  ): Result<X, U>;\n  chain(\n    ok: (value: T) => Result<unknown>,\n    err?: (error: E) => Result<unknown>,\n  ): Result<unknown> {\n    return this._chain(ok, err ?? ((error) => Result.err(error)));\n  }\n}\n\nclass _Ok<T, E extends Error> extends _Result<T, E> {\n  readonly isOk = true;\n  readonly isErr = false;\n  constructor(readonly value: T) {\n    super();\n  }\n\n  protected _chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    _err: (error: E) => Result<X, U>,\n  ): Result<X, U> {\n    return ok(this.value);\n  }\n}\n\nclass _Err<T, E extends Error> extends _Result<T, E> {\n  readonly isOk = false;\n  readonly isErr = true;\n  constructor(readonly error: E) {\n    super();\n  }\n\n  protected _chain<X, U extends Error>(\n    _ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>,\n  ): Result<X, U> {\n    return err(this.error);\n  }\n}\n\nexport namespace Result {\n  export interface Ok<T, E extends Error> extends _Ok<T, E> {}\n  export interface Err<T, E extends Error> extends _Err<T, E> {}\n\n  export function ok<T, E extends Error>(value: T): Result<T, E> {\n    return new _Ok(value);\n  }\n  export function err<E extends Error, T = never>(error?: E): Result<T, E>;\n  export function err<E extends Error, T = never>(error: E): Result<T, E> {\n    return new _Err(error || new Error());\n  }\n\n  type U = Result<unknown>;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n    R14 extends U,\n    R15 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n      OkType<R14>,\n      OkType<R15>,\n    ],\n    ErrType<\n      | R0\n      | R1\n      | R2\n      | R3\n      | R4\n      | R5\n      | R6\n      | R7\n      | R8\n      | R9\n      | R10\n      | R11\n      | R12\n      | R13\n      | R14\n      | R15\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n    R14 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n      OkType<R14>,\n    ],\n    ErrType<\n      | R0\n      | R1\n      | R2\n      | R3\n      | R4\n      | R5\n      | R6\n      | R7\n      | R8\n      | R9\n      | R10\n      | R11\n      | R12\n      | R13\n      | R14\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n    ],\n    ErrType<\n      R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11 | R12 | R13\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6],\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4, R5],\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>, OkType<R4>, OkType<R5>],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n  >(\n    obj: [R0, R1, R2, R3, R4],\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>, OkType<R4>],\n    ErrType<R0 | R1 | R2 | R3 | R4>\n  >;\n  export function all<R0 extends U, R1 extends U, R2 extends U, R3 extends U>(\n    obj: [R0, R1, R2, R3],\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>],\n    ErrType<R0 | R1 | R2 | R3>\n  >;\n  export function all<R0 extends U, R1 extends U, R2 extends U>(\n    obj: [R0, R1, R2],\n  ): Result<[OkType<R0>, OkType<R1>, OkType<R2>], ErrType<R0 | R1 | R2>>;\n  export function all<R0 extends U, R1 extends U>(\n    obj: [R0, R1],\n  ): Result<[OkType<R0>, OkType<R1>], ErrType<R0 | R1>>;\n  export function all<R0 extends U>(\n    obj: [R0],\n  ): Result<[OkType<R0>], ErrType<R0>>;\n  export function all(obj: []): Result<[]>;\n  export function all<T extends U[] | Record<string, U>>(\n    obj: T,\n  ): Result<\n    { [K in keyof T]: T[K] extends Result<infer I> ? I : never },\n    {\n      [K in keyof T]: T[K] extends Result<unknown, infer E> ? E : never;\n    }[keyof T]\n  >;\n  export function all(obj: U[] | Record<string, U>): unknown {\n    if (Array.isArray(obj)) {\n      const res = [];\n      for (let i = 0; i < obj.length; i++) {\n        const item = obj[i];\n        if (item.isErr) {\n          return item;\n        }\n        res.push(item.value);\n      }\n      return Result.ok(res);\n    }\n\n    const res: Record<string, unknown> = {};\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n      const item = obj[keys[i]];\n      if (item.isErr) {\n        return item;\n      }\n      res[keys[i]] = item.value;\n    }\n    return Result.ok(res);\n  }\n}\n\nexport type Result<T, E extends Error = Error> =\n  | Result.Ok<T, E>\n  | Result.Err<T, E>;\n\ntype OkType<R extends Result<unknown>> = R extends Result<infer O> ? O : never;\ntype ErrType<R extends Result<unknown>> =\n  R extends Result<unknown, infer E> ? E : never;\n", "import { Color, Square } from './types.js';\n\nconst popcnt32 = (n: number): number => {\n  n = n - ((n >>> 1) & 0x5555_5555);\n  n = (n & 0x3333_3333) + ((n >>> 2) & 0x3333_3333);\n  return Math.imul((n + (n >>> 4)) & 0x0f0f_0f0f, 0x0101_0101) >> 24;\n};\n\nconst bswap32 = (n: number): number => {\n  n = ((n >>> 8) & 0x00ff_00ff) | ((n & 0x00ff_00ff) << 8);\n  return ((n >>> 16) & 0xffff) | ((n & 0xffff) << 16);\n};\n\nconst rbit32 = (n: number): number => {\n  n = ((n >>> 1) & 0x5555_5555) | ((n & 0x5555_5555) << 1);\n  n = ((n >>> 2) & 0x3333_3333) | ((n & 0x3333_3333) << 2);\n  n = ((n >>> 4) & 0x0f0f_0f0f) | ((n & 0x0f0f_0f0f) << 4);\n  return bswap32(n);\n};\n\n/**\n * An immutable set of squares, implemented as a bitboard.\n */\nexport class SquareSet implements Iterable<Square> {\n  readonly lo: number;\n  readonly hi: number;\n\n  constructor(lo: number, hi: number) {\n    this.lo = lo | 0;\n    this.hi = hi | 0;\n  }\n\n  static fromSquare(square: Square): SquareSet {\n    return square >= 32 ? new SquareSet(0, 1 << (square - 32)) : new SquareSet(1 << square, 0);\n  }\n\n  static fromRank(rank: number): SquareSet {\n    return new SquareSet(0xff, 0).shl64(8 * rank);\n  }\n\n  static fromFile(file: number): SquareSet {\n    return new SquareSet(0x0101_0101 << file, 0x0101_0101 << file);\n  }\n\n  static empty(): SquareSet {\n    return new SquareSet(0, 0);\n  }\n\n  static full(): SquareSet {\n    return new SquareSet(0xffff_ffff, 0xffff_ffff);\n  }\n\n  static corners(): SquareSet {\n    return new SquareSet(0x81, 0x8100_0000);\n  }\n\n  static center(): SquareSet {\n    return new SquareSet(0x1800_0000, 0x18);\n  }\n\n  static backranks(): SquareSet {\n    return new SquareSet(0xff, 0xff00_0000);\n  }\n\n  static backrank(color: Color): SquareSet {\n    return color === 'white' ? new SquareSet(0xff, 0) : new SquareSet(0, 0xff00_0000);\n  }\n\n  static lightSquares(): SquareSet {\n    return new SquareSet(0x55aa_55aa, 0x55aa_55aa);\n  }\n\n  static darkSquares(): SquareSet {\n    return new SquareSet(0xaa55_aa55, 0xaa55_aa55);\n  }\n\n  complement(): SquareSet {\n    return new SquareSet(~this.lo, ~this.hi);\n  }\n\n  xor(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo ^ other.lo, this.hi ^ other.hi);\n  }\n\n  union(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo | other.lo, this.hi | other.hi);\n  }\n\n  intersect(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo & other.lo, this.hi & other.hi);\n  }\n\n  diff(other: SquareSet): SquareSet {\n    return new SquareSet(this.lo & ~other.lo, this.hi & ~other.hi);\n  }\n\n  intersects(other: SquareSet): boolean {\n    return this.intersect(other).nonEmpty();\n  }\n\n  isDisjoint(other: SquareSet): boolean {\n    return this.intersect(other).isEmpty();\n  }\n\n  supersetOf(other: SquareSet): boolean {\n    return other.diff(this).isEmpty();\n  }\n\n  subsetOf(other: SquareSet): boolean {\n    return this.diff(other).isEmpty();\n  }\n\n  shr64(shift: number): SquareSet {\n    if (shift >= 64) return SquareSet.empty();\n    if (shift >= 32) return new SquareSet(this.hi >>> (shift - 32), 0);\n    if (shift > 0) return new SquareSet((this.lo >>> shift) ^ (this.hi << (32 - shift)), this.hi >>> shift);\n    return this;\n  }\n\n  shl64(shift: number): SquareSet {\n    if (shift >= 64) return SquareSet.empty();\n    if (shift >= 32) return new SquareSet(0, this.lo << (shift - 32));\n    if (shift > 0) return new SquareSet(this.lo << shift, (this.hi << shift) ^ (this.lo >>> (32 - shift)));\n    return this;\n  }\n\n  bswap64(): SquareSet {\n    return new SquareSet(bswap32(this.hi), bswap32(this.lo));\n  }\n\n  rbit64(): SquareSet {\n    return new SquareSet(rbit32(this.hi), rbit32(this.lo));\n  }\n\n  minus64(other: SquareSet): SquareSet {\n    const lo = this.lo - other.lo;\n    const c = ((lo & other.lo & 1) + (other.lo >>> 1) + (lo >>> 1)) >>> 31;\n    return new SquareSet(lo, this.hi - (other.hi + c));\n  }\n\n  equals(other: SquareSet): boolean {\n    return this.lo === other.lo && this.hi === other.hi;\n  }\n\n  size(): number {\n    return popcnt32(this.lo) + popcnt32(this.hi);\n  }\n\n  isEmpty(): boolean {\n    return this.lo === 0 && this.hi === 0;\n  }\n\n  nonEmpty(): boolean {\n    return this.lo !== 0 || this.hi !== 0;\n  }\n\n  has(square: Square): boolean {\n    return (square >= 32 ? this.hi & (1 << (square - 32)) : this.lo & (1 << square)) !== 0;\n  }\n\n  set(square: Square, on: boolean): SquareSet {\n    return on ? this.with(square) : this.without(square);\n  }\n\n  with(square: Square): SquareSet {\n    return square >= 32\n      ? new SquareSet(this.lo, this.hi | (1 << (square - 32)))\n      : new SquareSet(this.lo | (1 << square), this.hi);\n  }\n\n  without(square: Square): SquareSet {\n    return square >= 32\n      ? new SquareSet(this.lo, this.hi & ~(1 << (square - 32)))\n      : new SquareSet(this.lo & ~(1 << square), this.hi);\n  }\n\n  toggle(square: Square): SquareSet {\n    return square >= 32\n      ? new SquareSet(this.lo, this.hi ^ (1 << (square - 32)))\n      : new SquareSet(this.lo ^ (1 << square), this.hi);\n  }\n\n  last(): Square | undefined {\n    if (this.hi !== 0) return 63 - Math.clz32(this.hi);\n    if (this.lo !== 0) return 31 - Math.clz32(this.lo);\n    return;\n  }\n\n  first(): Square | undefined {\n    if (this.lo !== 0) return 31 - Math.clz32(this.lo & -this.lo);\n    if (this.hi !== 0) return 63 - Math.clz32(this.hi & -this.hi);\n    return;\n  }\n\n  withoutFirst(): SquareSet {\n    if (this.lo !== 0) return new SquareSet(this.lo & (this.lo - 1), this.hi);\n    return new SquareSet(0, this.hi & (this.hi - 1));\n  }\n\n  moreThanOne(): boolean {\n    return (this.hi !== 0 && this.lo !== 0) || (this.lo & (this.lo - 1)) !== 0 || (this.hi & (this.hi - 1)) !== 0;\n  }\n\n  singleSquare(): Square | undefined {\n    return this.moreThanOne() ? undefined : this.last();\n  }\n\n  *[Symbol.iterator](): Iterator<Square> {\n    let lo = this.lo;\n    let hi = this.hi;\n    while (lo !== 0) {\n      const idx = 31 - Math.clz32(lo & -lo);\n      lo ^= 1 << idx;\n      yield idx;\n    }\n    while (hi !== 0) {\n      const idx = 31 - Math.clz32(hi & -hi);\n      hi ^= 1 << idx;\n      yield 32 + idx;\n    }\n  }\n\n  *reversed(): Iterable<Square> {\n    let lo = this.lo;\n    let hi = this.hi;\n    while (hi !== 0) {\n      const idx = 31 - Math.clz32(hi);\n      hi ^= 1 << idx;\n      yield 32 + idx;\n    }\n    while (lo !== 0) {\n      const idx = 31 - Math.clz32(lo);\n      lo ^= 1 << idx;\n      yield idx;\n    }\n  }\n}\n", "export const FILE_NAMES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] as const;\n\nexport type FileName = (typeof FILE_NAMES)[number];\n\nexport const RANK_NAMES = ['1', '2', '3', '4', '5', '6', '7', '8'] as const;\n\nexport type RankName = (typeof RANK_NAMES)[number];\n\nexport type Square = number;\n\nexport type SquareName = `${FileName}${RankName}`;\n\nexport const ROLE_CHARS = ['q', 'n', 'r', 'b', 'p', 'k'] as const;\n\nexport type RoleChar = (typeof ROLE_CHARS)[number];\n\n/**\n * Indexable by square indices.\n */\nexport type BySquare<T> = T[];\n\nexport const COLORS = ['white', 'black'] as const;\n\nexport type Color = (typeof COLORS)[number];\n\n/**\n * Indexable by `white` and `black`.\n */\nexport type ByColor<T> = {\n  [color in Color]: T;\n};\n\nexport const ROLES = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'] as const;\n\nexport type Role = (typeof ROLES)[number];\n\n/**\n * Indexable by `pawn`, `knight`, `bishop`, `rook`, `queen`, and `king`.\n */\nexport type ByRole<T> = {\n  [role in Role]: T;\n};\n\nexport const CASTLING_SIDES = ['a', 'h'] as const;\n\nexport type CastlingSide = (typeof CASTLING_SIDES)[number];\n\n/**\n * Indexable by `a` and `h`.\n */\nexport type ByCastlingSide<T> = {\n  [side in CastlingSide]: T;\n};\n\nexport interface Piece {\n  role: Role;\n  color: Color;\n  promoted?: boolean;\n}\n\nexport interface NormalMove {\n  from: Square;\n  to: Square;\n  promotion?: Role;\n}\n\nexport interface DropMove {\n  role: Role;\n  to: Square;\n}\n\nexport type Move = NormalMove | DropMove;\n\nexport const isDrop = (v: Move): v is DropMove => 'role' in v;\n\nexport const isNormal = (v: Move): v is NormalMove => 'from' in v;\n\nexport const RULES = [\n  'chess',\n  'antichess',\n  'kingofthehill',\n  '3check',\n  'atomic',\n  'horde',\n  'racingkings',\n  'crazyhouse',\n] as const;\n\nexport type Rules = (typeof RULES)[number];\n\nexport interface Outcome {\n  winner: Color | undefined;\n}\n", "import {\n  CastlingSide,\n  Color,\n  FILE_NAMES,\n  isDrop,\n  isNormal,\n  Move,\n  RANK_NAMES,\n  Role,\n  type RoleChar,\n  Square,\n  SquareName,\n} from './types.js';\n\nexport const defined = <A>(v: A | undefined): v is A => v !== undefined;\n\nexport const opposite = (color: Color): Color => (color === 'white' ? 'black' : 'white');\n\nexport const squareRank = (square: Square): number => square >> 3;\n\nexport const squareFile = (square: Square): number => square & 0x7;\n\nexport const squareFromCoords = (file: number, rank: number): Square | undefined =>\n  0 <= file && file < 8 && 0 <= rank && rank < 8 ? file + 8 * rank : undefined;\n\nexport const roleToChar = (role: Role): RoleChar => {\n  switch (role) {\n    case 'pawn':\n      return 'p';\n    case 'knight':\n      return 'n';\n    case 'bishop':\n      return 'b';\n    case 'rook':\n      return 'r';\n    case 'queen':\n      return 'q';\n    case 'king':\n      return 'k';\n  }\n};\n\nexport function charToRole(ch: RoleChar | Uppercase<RoleChar>): Role;\nexport function charToRole(ch: string): Role | undefined;\nexport function charToRole(ch: string): Role | undefined {\n  switch (ch.toLowerCase()) {\n    case 'p':\n      return 'pawn';\n    case 'n':\n      return 'knight';\n    case 'b':\n      return 'bishop';\n    case 'r':\n      return 'rook';\n    case 'q':\n      return 'queen';\n    case 'k':\n      return 'king';\n    default:\n      return;\n  }\n}\n\nexport function parseSquare(str: SquareName): Square;\nexport function parseSquare(str: string): Square | undefined;\nexport function parseSquare(str: string): Square | undefined {\n  if (str.length !== 2) return;\n  return squareFromCoords(str.charCodeAt(0) - 'a'.charCodeAt(0), str.charCodeAt(1) - '1'.charCodeAt(0));\n}\n\nexport const makeSquare = (square: Square): SquareName =>\n  (FILE_NAMES[squareFile(square)] + RANK_NAMES[squareRank(square)]) as SquareName;\n\nexport const parseUci = (str: string): Move | undefined => {\n  if (str[1] === '@' && str.length === 4) {\n    const role = charToRole(str[0]);\n    const to = parseSquare(str.slice(2));\n    if (role && defined(to)) return { role, to };\n  } else if (str.length === 4 || str.length === 5) {\n    const from = parseSquare(str.slice(0, 2));\n    const to = parseSquare(str.slice(2, 4));\n    let promotion: Role | undefined;\n    if (str.length === 5) {\n      promotion = charToRole(str[4]);\n      if (!promotion) return;\n    }\n    if (defined(from) && defined(to)) return { from, to, promotion };\n  }\n  return;\n};\n\nexport const moveEquals = (left: Move, right: Move): boolean => {\n  if (left.to !== right.to) return false;\n  if (isDrop(left)) return isDrop(right) && left.role === right.role;\n  else return isNormal(right) && left.from === right.from && left.promotion === right.promotion;\n};\n\n/**\n * Converts a move to UCI notation, like `g1f3` for a normal move,\n * `a7a8q` for promotion to a queen, and `Q@f7` for a Crazyhouse drop.\n */\nexport const makeUci = (move: Move): string =>\n  isDrop(move)\n    ? `${roleToChar(move.role).toUpperCase()}@${makeSquare(move.to)}`\n    : makeSquare(move.from) + makeSquare(move.to) + (move.promotion ? roleToChar(move.promotion) : '');\n\nexport const kingCastlesTo = (color: Color, side: CastlingSide): Square =>\n  color === 'white' ? (side === 'a' ? 2 : 6) : side === 'a' ? 58 : 62;\n\nexport const rookCastlesTo = (color: Color, side: CastlingSide): Square =>\n  color === 'white' ? (side === 'a' ? 3 : 5) : side === 'a' ? 59 : 61;\n", "/**\n * Compute attacks and rays.\n *\n * These are low-level functions that can be used to implement chess rules.\n *\n * Implementation notes: Sliding attacks are computed using\n * [Hyperbola Quintessence](https://www.chessprogramming.org/Hyperbola_Quintessence).\n * Magic Bitboards would deliver slightly faster lookups, but also require\n * initializing considerably larger attack tables. On the web, initialization\n * time is important, so the chosen method may strike a better balance.\n *\n * @packageDocumentation\n */\n\nimport { SquareSet } from './squareSet.js';\nimport { BySquare, Color, Piece, Square } from './types.js';\nimport { squareFile, squareRank } from './util.js';\n\nconst computeRange = (square: Square, deltas: number[]): SquareSet => {\n  let range = SquareSet.empty();\n  for (const delta of deltas) {\n    const sq = square + delta;\n    if (0 <= sq && sq < 64 && Math.abs(squareFile(square) - squareFile(sq)) <= 2) {\n      range = range.with(sq);\n    }\n  }\n  return range;\n};\n\nconst tabulate = <T>(f: (square: Square) => T): BySquare<T> => {\n  const table = [];\n  for (let square = 0; square < 64; square++) table[square] = f(square);\n  return table;\n};\n\nconst KING_ATTACKS = tabulate(sq => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));\nconst KNIGHT_ATTACKS = tabulate(sq => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));\nconst PAWN_ATTACKS = {\n  white: tabulate(sq => computeRange(sq, [7, 9])),\n  black: tabulate(sq => computeRange(sq, [-7, -9])),\n};\n\n/**\n * Gets squares attacked or defended by a king on `square`.\n */\nexport const kingAttacks = (square: Square): SquareSet => KING_ATTACKS[square];\n\n/**\n * Gets squares attacked or defended by a knight on `square`.\n */\nexport const knightAttacks = (square: Square): SquareSet => KNIGHT_ATTACKS[square];\n\n/**\n * Gets squares attacked or defended by a pawn of the given `color`\n * on `square`.\n */\nexport const pawnAttacks = (color: Color, square: Square): SquareSet => PAWN_ATTACKS[color][square];\n\nconst FILE_RANGE = tabulate(sq => SquareSet.fromFile(squareFile(sq)).without(sq));\nconst RANK_RANGE = tabulate(sq => SquareSet.fromRank(squareRank(sq)).without(sq));\n\nconst DIAG_RANGE = tabulate(sq => {\n  const diag = new SquareSet(0x0804_0201, 0x8040_2010);\n  const shift = 8 * (squareRank(sq) - squareFile(sq));\n  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\n\nconst ANTI_DIAG_RANGE = tabulate(sq => {\n  const diag = new SquareSet(0x1020_4080, 0x0102_0408);\n  const shift = 8 * (squareRank(sq) + squareFile(sq) - 7);\n  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\n\nconst hyperbola = (bit: SquareSet, range: SquareSet, occupied: SquareSet): SquareSet => {\n  let forward = occupied.intersect(range);\n  let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank\n  forward = forward.minus64(bit);\n  reverse = reverse.minus64(bit.bswap64());\n  return forward.xor(reverse.bswap64()).intersect(range);\n};\n\nconst fileAttacks = (square: Square, occupied: SquareSet): SquareSet =>\n  hyperbola(SquareSet.fromSquare(square), FILE_RANGE[square], occupied);\n\nconst rankAttacks = (square: Square, occupied: SquareSet): SquareSet => {\n  const range = RANK_RANGE[square];\n  let forward = occupied.intersect(range);\n  let reverse = forward.rbit64();\n  forward = forward.minus64(SquareSet.fromSquare(square));\n  reverse = reverse.minus64(SquareSet.fromSquare(63 - square));\n  return forward.xor(reverse.rbit64()).intersect(range);\n};\n\n/**\n * Gets squares attacked or defended by a bishop on `square`, given `occupied`\n * squares.\n */\nexport const bishopAttacks = (square: Square, occupied: SquareSet): SquareSet => {\n  const bit = SquareSet.fromSquare(square);\n  return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));\n};\n\n/**\n * Gets squares attacked or defended by a rook on `square`, given `occupied`\n * squares.\n */\nexport const rookAttacks = (square: Square, occupied: SquareSet): SquareSet =>\n  fileAttacks(square, occupied).xor(rankAttacks(square, occupied));\n\n/**\n * Gets squares attacked or defended by a queen on `square`, given `occupied`\n * squares.\n */\nexport const queenAttacks = (square: Square, occupied: SquareSet): SquareSet =>\n  bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));\n\n/**\n * Gets squares attacked or defended by a `piece` on `square`, given\n * `occupied` squares.\n */\nexport const attacks = (piece: Piece, square: Square, occupied: SquareSet): SquareSet => {\n  switch (piece.role) {\n    case 'pawn':\n      return pawnAttacks(piece.color, square);\n    case 'knight':\n      return knightAttacks(square);\n    case 'bishop':\n      return bishopAttacks(square, occupied);\n    case 'rook':\n      return rookAttacks(square, occupied);\n    case 'queen':\n      return queenAttacks(square, occupied);\n    case 'king':\n      return kingAttacks(square);\n  }\n};\n\n/**\n * Gets all squares of the rank, file or diagonal with the two squares\n * `a` and `b`, or an empty set if they are not aligned.\n */\nexport const ray = (a: Square, b: Square): SquareSet => {\n  const other = SquareSet.fromSquare(b);\n  if (RANK_RANGE[a].intersects(other)) return RANK_RANGE[a].with(a);\n  if (ANTI_DIAG_RANGE[a].intersects(other)) return ANTI_DIAG_RANGE[a].with(a);\n  if (DIAG_RANGE[a].intersects(other)) return DIAG_RANGE[a].with(a);\n  if (FILE_RANGE[a].intersects(other)) return FILE_RANGE[a].with(a);\n  return SquareSet.empty();\n};\n\n/**\n * Gets all squares between `a` and `b` (bounds not included), or an empty set\n * if they are not on the same rank, file or diagonal.\n */\nexport const between = (a: Square, b: Square): SquareSet =>\n  ray(a, b)\n    .intersect(SquareSet.full().shl64(a).xor(SquareSet.full().shl64(b)))\n    .withoutFirst();\n", "import { SquareSet } from './squareSet.js';\nimport { ByColor, ByRole, Color, COLORS, Piece, Role, ROLES, Square } from './types.js';\n\n/**\n * Piece positions on a board.\n *\n * Properties are sets of squares, like `board.occupied` for all occupied\n * squares, `board[color]` for all pieces of that color, and `board[role]`\n * for all pieces of that role. When modifying the properties directly, take\n * care to keep them consistent.\n */\nexport class Board implements Iterable<[Square, Piece]>, ByRole<SquareSet>, ByColor<SquareSet> {\n  /**\n   * All occupied squares.\n   */\n  occupied: SquareSet;\n  /**\n   * All squares occupied by pieces known to be promoted. This information is\n   * relevant in chess variants like Crazyhouse.\n   */\n  promoted: SquareSet;\n\n  white: SquareSet;\n  black: SquareSet;\n\n  pawn: SquareSet;\n  knight: SquareSet;\n  bishop: SquareSet;\n  rook: SquareSet;\n  queen: SquareSet;\n  king: SquareSet;\n\n  private constructor() {}\n\n  static default(): Board {\n    const board = new Board();\n    board.reset();\n    return board;\n  }\n\n  /**\n   * Resets all pieces to the default starting position for standard chess.\n   */\n  reset(): void {\n    this.occupied = new SquareSet(0xffff, 0xffff_0000);\n    this.promoted = SquareSet.empty();\n    this.white = new SquareSet(0xffff, 0);\n    this.black = new SquareSet(0, 0xffff_0000);\n    this.pawn = new SquareSet(0xff00, 0x00ff_0000);\n    this.knight = new SquareSet(0x42, 0x4200_0000);\n    this.bishop = new SquareSet(0x24, 0x2400_0000);\n    this.rook = new SquareSet(0x81, 0x8100_0000);\n    this.queen = new SquareSet(0x8, 0x0800_0000);\n    this.king = new SquareSet(0x10, 0x1000_0000);\n  }\n\n  static empty(): Board {\n    const board = new Board();\n    board.clear();\n    return board;\n  }\n\n  clear(): void {\n    this.occupied = SquareSet.empty();\n    this.promoted = SquareSet.empty();\n    for (const color of COLORS) this[color] = SquareSet.empty();\n    for (const role of ROLES) this[role] = SquareSet.empty();\n  }\n\n  clone(): Board {\n    const board = new Board();\n    board.occupied = this.occupied;\n    board.promoted = this.promoted;\n    for (const color of COLORS) board[color] = this[color];\n    for (const role of ROLES) board[role] = this[role];\n    return board;\n  }\n\n  getColor(square: Square): Color | undefined {\n    if (this.white.has(square)) return 'white';\n    if (this.black.has(square)) return 'black';\n    return;\n  }\n\n  getRole(square: Square): Role | undefined {\n    for (const role of ROLES) {\n      if (this[role].has(square)) return role;\n    }\n    return;\n  }\n\n  get(square: Square): Piece | undefined {\n    const color = this.getColor(square);\n    if (!color) return;\n    const role = this.getRole(square)!;\n    const promoted = this.promoted.has(square);\n    return { color, role, promoted };\n  }\n\n  /**\n   * Removes and returns the piece from the given `square`, if any.\n   */\n  take(square: Square): Piece | undefined {\n    const piece = this.get(square);\n    if (piece) {\n      this.occupied = this.occupied.without(square);\n      this[piece.color] = this[piece.color].without(square);\n      this[piece.role] = this[piece.role].without(square);\n      if (piece.promoted) this.promoted = this.promoted.without(square);\n    }\n    return piece;\n  }\n\n  /**\n   * Put `piece` onto `square`, potentially replacing an existing piece.\n   * Returns the existing piece, if any.\n   */\n  set(square: Square, piece: Piece): Piece | undefined {\n    const old = this.take(square);\n    this.occupied = this.occupied.with(square);\n    this[piece.color] = this[piece.color].with(square);\n    this[piece.role] = this[piece.role].with(square);\n    if (piece.promoted) this.promoted = this.promoted.with(square);\n    return old;\n  }\n\n  has(square: Square): boolean {\n    return this.occupied.has(square);\n  }\n\n  *[Symbol.iterator](): Iterator<[Square, Piece]> {\n    for (const square of this.occupied) {\n      yield [square, this.get(square)!];\n    }\n  }\n\n  pieces(color: Color, role: Role): SquareSet {\n    return this[color].intersect(this[role]);\n  }\n\n  rooksAndQueens(): SquareSet {\n    return this.rook.union(this.queen);\n  }\n\n  bishopsAndQueens(): SquareSet {\n    return this.bishop.union(this.queen);\n  }\n\n  steppers(): SquareSet {\n    return this.knight.union(this.pawn).union(this.king);\n  }\n\n  sliders(): SquareSet {\n    return this.bishop.union(this.rook).union(this.queen);\n  }\n\n  /**\n   * Finds the unique king of the given `color`, if any.\n   */\n  kingOf(color: Color): Square | undefined {\n    return this.pieces(color, 'king').singleSquare();\n  }\n}\n\nexport const boardEquals = (left: Board, right: Board): boolean =>\n  left.white.equals(right.white)\n  && left.promoted.equals(right.promoted)\n  && ROLES.every(role => left[role].equals(right[role]));\n", "import { Result } from '@badrap/result';\nimport {\n  attacks,\n  between,\n  bishopAttacks,\n  kingAttacks,\n  knightAttacks,\n  pawnAttacks,\n  queenAttacks,\n  ray,\n  rookAttacks,\n} from './attacks.js';\nimport { Board, boardEquals } from './board.js';\nimport { Material, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport {\n  ByCastlingSide,\n  ByColor,\n  CASTLING_SIDES,\n  CastlingSide,\n  Color,\n  COLORS,\n  isDrop,\n  Move,\n  NormalMove,\n  Outcome,\n  Piece,\n  Rules,\n  Square,\n} from './types.js';\nimport { defined, kingCastlesTo, opposite, rookCastlesTo, squareRank } from './util.js';\n\nexport enum IllegalSetup {\n  Empty = 'ERR_EMPTY',\n  OppositeCheck = 'ERR_OPPOSITE_CHECK',\n  PawnsOnBackrank = 'ERR_PAWNS_ON_BACKRANK',\n  Kings = 'ERR_KINGS',\n  Variant = 'ERR_VARIANT',\n}\n\nexport class PositionError extends Error {}\n\nconst attacksTo = (square: Square, attacker: Color, board: Board, occupied: SquareSet): SquareSet =>\n  board[attacker].intersect(\n    rookAttacks(square, occupied)\n      .intersect(board.rooksAndQueens())\n      .union(bishopAttacks(square, occupied).intersect(board.bishopsAndQueens()))\n      .union(knightAttacks(square).intersect(board.knight))\n      .union(kingAttacks(square).intersect(board.king))\n      .union(pawnAttacks(opposite(attacker), square).intersect(board.pawn)),\n  );\n\nexport class Castles {\n  castlingRights: SquareSet;\n  rook: ByColor<ByCastlingSide<Square | undefined>>;\n  path: ByColor<ByCastlingSide<SquareSet>>;\n\n  private constructor() {}\n\n  static default(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = SquareSet.corners();\n    castles.rook = {\n      white: { a: 0, h: 7 },\n      black: { a: 56, h: 63 },\n    };\n    castles.path = {\n      white: { a: new SquareSet(0xe, 0), h: new SquareSet(0x60, 0) },\n      black: { a: new SquareSet(0, 0x0e000000), h: new SquareSet(0, 0x60000000) },\n    };\n    return castles;\n  }\n\n  static empty(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = SquareSet.empty();\n    castles.rook = {\n      white: { a: undefined, h: undefined },\n      black: { a: undefined, h: undefined },\n    };\n    castles.path = {\n      white: { a: SquareSet.empty(), h: SquareSet.empty() },\n      black: { a: SquareSet.empty(), h: SquareSet.empty() },\n    };\n    return castles;\n  }\n\n  clone(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = this.castlingRights;\n    castles.rook = {\n      white: { a: this.rook.white.a, h: this.rook.white.h },\n      black: { a: this.rook.black.a, h: this.rook.black.h },\n    };\n    castles.path = {\n      white: { a: this.path.white.a, h: this.path.white.h },\n      black: { a: this.path.black.a, h: this.path.black.h },\n    };\n    return castles;\n  }\n\n  private add(color: Color, side: CastlingSide, king: Square, rook: Square): void {\n    const kingTo = kingCastlesTo(color, side);\n    const rookTo = rookCastlesTo(color, side);\n    this.castlingRights = this.castlingRights.with(rook);\n    this.rook[color][side] = rook;\n    this.path[color][side] = between(rook, rookTo)\n      .with(rookTo)\n      .union(between(king, kingTo).with(kingTo))\n      .without(king)\n      .without(rook);\n  }\n\n  static fromSetup(setup: Setup): Castles {\n    const castles = Castles.empty();\n    const rooks = setup.castlingRights.intersect(setup.board.rook);\n    for (const color of COLORS) {\n      const backrank = SquareSet.backrank(color);\n      const king = setup.board.kingOf(color);\n      if (!defined(king) || !backrank.has(king)) continue;\n      const side = rooks.intersect(setup.board[color]).intersect(backrank);\n      const aSide = side.first();\n      if (defined(aSide) && aSide < king) castles.add(color, 'a', king, aSide);\n      const hSide = side.last();\n      if (defined(hSide) && king < hSide) castles.add(color, 'h', king, hSide);\n    }\n    return castles;\n  }\n\n  discardRook(square: Square): void {\n    if (this.castlingRights.has(square)) {\n      this.castlingRights = this.castlingRights.without(square);\n      for (const color of COLORS) {\n        for (const side of CASTLING_SIDES) {\n          if (this.rook[color][side] === square) this.rook[color][side] = undefined;\n        }\n      }\n    }\n  }\n\n  discardColor(color: Color): void {\n    this.castlingRights = this.castlingRights.diff(SquareSet.backrank(color));\n    this.rook[color].a = undefined;\n    this.rook[color].h = undefined;\n  }\n}\n\nexport interface Context {\n  king: Square | undefined;\n  blockers: SquareSet;\n  checkers: SquareSet;\n  variantEnd: boolean;\n  mustCapture: boolean;\n}\n\nexport abstract class Position {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castles: Castles;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n\n  protected constructor(readonly rules: Rules) {}\n\n  reset() {\n    this.board = Board.default();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.default();\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    this.board = setup.board.clone();\n    this.board.promoted = SquareSet.empty();\n    this.pockets = undefined;\n    this.turn = setup.turn;\n    this.castles = Castles.fromSetup(setup);\n    this.epSquare = validEpSquare(this, setup.epSquare);\n    this.remainingChecks = undefined;\n    this.halfmoves = setup.halfmoves;\n    this.fullmoves = setup.fullmoves;\n  }\n\n  // When subclassing overwrite at least:\n  //\n  // - static default()\n  // - static fromSetup()\n  // - static clone()\n  //\n  // - dests()\n  // - isVariantEnd()\n  // - variantOutcome()\n  // - hasInsufficientMaterial()\n  // - isStandardMaterial()\n\n  kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    return attacksTo(square, attacker, this.board, occupied);\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    this.halfmoves = 0;\n    if (captured.role === 'rook') this.castles.discardRook(square);\n    if (this.pockets) this.pockets[opposite(captured.color)][captured.promoted ? 'pawn' : captured.role]++;\n  }\n\n  ctx(): Context {\n    const variantEnd = this.isVariantEnd();\n    const king = this.board.kingOf(this.turn);\n    if (!defined(king)) {\n      return { king, blockers: SquareSet.empty(), checkers: SquareSet.empty(), variantEnd, mustCapture: false };\n    }\n    const snipers = rookAttacks(king, SquareSet.empty())\n      .intersect(this.board.rooksAndQueens())\n      .union(bishopAttacks(king, SquareSet.empty()).intersect(this.board.bishopsAndQueens()))\n      .intersect(this.board[opposite(this.turn)]);\n    let blockers = SquareSet.empty();\n    for (const sniper of snipers) {\n      const b = between(king, sniper).intersect(this.board.occupied);\n      if (!b.moreThanOne()) blockers = blockers.union(b);\n    }\n    const checkers = this.kingAttackers(king, opposite(this.turn), this.board.occupied);\n    return {\n      king,\n      blockers,\n      checkers,\n      variantEnd,\n      mustCapture: false,\n    };\n  }\n\n  clone(): Position {\n    const pos = new (this as any).constructor();\n    pos.board = this.board.clone();\n    pos.pockets = this.pockets?.clone();\n    pos.turn = this.turn;\n    pos.castles = this.castles.clone();\n    pos.epSquare = this.epSquare;\n    pos.remainingChecks = this.remainingChecks?.clone();\n    pos.halfmoves = this.halfmoves;\n    pos.fullmoves = this.fullmoves;\n    return pos;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() !== 2) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    if (!defined(this.board.kingOf(this.turn))) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n\n    return Result.ok(undefined);\n  }\n\n  dropDests(_ctx?: Context): SquareSet {\n    return SquareSet.empty();\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd) return SquareSet.empty();\n    const piece = this.board.get(square);\n    if (!piece || piece.color !== this.turn) return SquareSet.empty();\n\n    let pseudo, legal;\n    if (piece.role === 'pawn') {\n      pseudo = pawnAttacks(this.turn, square).intersect(this.board[opposite(this.turn)]);\n      const delta = this.turn === 'white' ? 8 : -8;\n      const step = square + delta;\n      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n        pseudo = pseudo.with(step);\n        const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n        const doubleStep = step + delta;\n        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n          pseudo = pseudo.with(doubleStep);\n        }\n      }\n      if (defined(this.epSquare) && canCaptureEp(this, square, ctx)) {\n        legal = SquareSet.fromSquare(this.epSquare);\n      }\n    } else if (piece.role === 'bishop') pseudo = bishopAttacks(square, this.board.occupied);\n    else if (piece.role === 'knight') pseudo = knightAttacks(square);\n    else if (piece.role === 'rook') pseudo = rookAttacks(square, this.board.occupied);\n    else if (piece.role === 'queen') pseudo = queenAttacks(square, this.board.occupied);\n    else pseudo = kingAttacks(square);\n\n    pseudo = pseudo.diff(this.board[this.turn]);\n\n    if (defined(ctx.king)) {\n      if (piece.role === 'king') {\n        const occ = this.board.occupied.without(square);\n        for (const to of pseudo) {\n          if (this.kingAttackers(to, opposite(this.turn), occ).nonEmpty()) pseudo = pseudo.without(to);\n        }\n        return pseudo.union(castlingDest(this, 'a', ctx)).union(castlingDest(this, 'h', ctx));\n      }\n\n      if (ctx.checkers.nonEmpty()) {\n        const checker = ctx.checkers.singleSquare();\n        if (!defined(checker)) return SquareSet.empty();\n        pseudo = pseudo.intersect(between(checker, ctx.king).with(checker));\n      }\n\n      if (ctx.blockers.has(square)) pseudo = pseudo.intersect(ray(square, ctx.king));\n    }\n\n    if (legal) pseudo = pseudo.union(legal);\n    return pseudo;\n  }\n\n  isVariantEnd(): boolean {\n    return false;\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    return;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return false;\n    if (this.board[color].intersects(this.board.knight)) {\n      return (\n        this.board[color].size() <= 2\n        && this.board[opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty()\n      );\n    }\n    if (this.board[color].intersects(this.board.bishop)) {\n      const sameColor = !this.board.bishop.intersects(SquareSet.darkSquares())\n        || !this.board.bishop.intersects(SquareSet.lightSquares());\n      return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n    }\n    return true;\n  }\n\n  // The following should be identical in all subclasses\n\n  toSetup(): Setup {\n    return {\n      board: this.board.clone(),\n      pockets: this.pockets?.clone(),\n      turn: this.turn,\n      castlingRights: this.castles.castlingRights,\n      epSquare: legalEpSquare(this),\n      remainingChecks: this.remainingChecks?.clone(),\n      halfmoves: Math.min(this.halfmoves, 150),\n      fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),\n    };\n  }\n\n  isInsufficientMaterial(): boolean {\n    return COLORS.every(color => this.hasInsufficientMaterial(color));\n  }\n\n  hasDests(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    for (const square of this.board[this.turn]) {\n      if (this.dests(square, ctx).nonEmpty()) return true;\n    }\n    return this.dropDests(ctx).nonEmpty();\n  }\n\n  isLegal(move: Move, ctx?: Context): boolean {\n    if (isDrop(move)) {\n      if (!this.pockets || this.pockets[this.turn][move.role] <= 0) return false;\n      if (move.role === 'pawn' && SquareSet.backranks().has(move.to)) return false;\n      return this.dropDests(ctx).has(move.to);\n    } else {\n      if (move.promotion === 'pawn') return false;\n      if (move.promotion === 'king' && this.rules !== 'antichess') return false;\n      if (!!move.promotion !== (this.board.pawn.has(move.from) && SquareSet.backranks().has(move.to))) return false;\n      const dests = this.dests(move.from, ctx);\n      return dests.has(move.to) || dests.has(normalizeMove(this, move).to);\n    }\n  }\n\n  isCheck(): boolean {\n    const king = this.board.kingOf(this.turn);\n    return defined(king) && this.kingAttackers(king, opposite(this.turn), this.board.occupied).nonEmpty();\n  }\n\n  isEnd(ctx?: Context): boolean {\n    if (ctx ? ctx.variantEnd : this.isVariantEnd()) return true;\n    return this.isInsufficientMaterial() || !this.hasDests(ctx);\n  }\n\n  isCheckmate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n  }\n\n  isStalemate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n  }\n\n  outcome(ctx?: Context): Outcome | undefined {\n    const variantOutcome = this.variantOutcome(ctx);\n    if (variantOutcome) return variantOutcome;\n    ctx = ctx || this.ctx();\n    if (this.isCheckmate(ctx)) return { winner: opposite(this.turn) };\n    else if (this.isInsufficientMaterial() || this.isStalemate(ctx)) return { winner: undefined };\n    else return;\n  }\n\n  allDests(ctx?: Context): Map<Square, SquareSet> {\n    ctx = ctx || this.ctx();\n    const d = new Map();\n    if (ctx.variantEnd) return d;\n    for (const square of this.board[this.turn]) {\n      d.set(square, this.dests(square, ctx));\n    }\n    return d;\n  }\n\n  play(move: Move): void {\n    const turn = this.turn;\n    const epSquare = this.epSquare;\n    const castling = castlingSide(this, move);\n\n    this.epSquare = undefined;\n    this.halfmoves += 1;\n    if (turn === 'black') this.fullmoves += 1;\n    this.turn = opposite(turn);\n\n    if (isDrop(move)) {\n      this.board.set(move.to, { role: move.role, color: turn });\n      if (this.pockets) this.pockets[turn][move.role]--;\n      if (move.role === 'pawn') this.halfmoves = 0;\n    } else {\n      const piece = this.board.take(move.from);\n      if (!piece) return;\n\n      let epCapture: Piece | undefined;\n      if (piece.role === 'pawn') {\n        this.halfmoves = 0;\n        if (move.to === epSquare) {\n          epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n        }\n        const delta = move.from - move.to;\n        if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {\n          this.epSquare = (move.from + move.to) >> 1;\n        }\n        if (move.promotion) {\n          piece.role = move.promotion;\n          piece.promoted = !!this.pockets;\n        }\n      } else if (piece.role === 'rook') {\n        this.castles.discardRook(move.from);\n      } else if (piece.role === 'king') {\n        if (castling) {\n          const rookFrom = this.castles.rook[turn][castling];\n          if (defined(rookFrom)) {\n            const rook = this.board.take(rookFrom);\n            this.board.set(kingCastlesTo(turn, castling), piece);\n            if (rook) this.board.set(rookCastlesTo(turn, castling), rook);\n          }\n        }\n        this.castles.discardColor(turn);\n      }\n\n      if (!castling) {\n        const capture = this.board.set(move.to, piece) || epCapture;\n        if (capture) this.playCaptureAt(move.to, capture);\n      }\n    }\n\n    if (this.remainingChecks) {\n      if (this.isCheck()) this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n    }\n  }\n}\n\nexport class Chess extends Position {\n  private constructor() {\n    super('chess');\n  }\n\n  static default(): Chess {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Chess, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Chess {\n    return super.clone() as Chess;\n  }\n}\n\nconst validEpSquare = (pos: Position, square: Square | undefined): Square | undefined => {\n  if (!defined(square)) return;\n  const epRank = pos.turn === 'white' ? 5 : 2;\n  const forward = pos.turn === 'white' ? 8 : -8;\n  if (squareRank(square) !== epRank) return;\n  if (pos.board.occupied.has(square + forward)) return;\n  const pawn = square - forward;\n  if (!pos.board.pawn.has(pawn) || !pos.board[opposite(pos.turn)].has(pawn)) return;\n  return square;\n};\n\nconst legalEpSquare = (pos: Position): Square | undefined => {\n  if (!defined(pos.epSquare)) return;\n  const ctx = pos.ctx();\n  const ourPawns = pos.board.pieces(pos.turn, 'pawn');\n  const candidates = ourPawns.intersect(pawnAttacks(opposite(pos.turn), pos.epSquare));\n  for (const candidate of candidates) {\n    if (pos.dests(candidate, ctx).has(pos.epSquare)) return pos.epSquare;\n  }\n  return;\n};\n\nconst canCaptureEp = (pos: Position, pawnFrom: Square, ctx: Context): boolean => {\n  if (!defined(pos.epSquare)) return false;\n  if (!pawnAttacks(pos.turn, pawnFrom).has(pos.epSquare)) return false;\n  if (!defined(ctx.king)) return true;\n  const delta = pos.turn === 'white' ? 8 : -8;\n  const captured = pos.epSquare - delta;\n  return pos\n    .kingAttackers(\n      ctx.king,\n      opposite(pos.turn),\n      pos.board.occupied.toggle(pawnFrom).toggle(captured).with(pos.epSquare),\n    )\n    .without(captured)\n    .isEmpty();\n};\n\nconst castlingDest = (pos: Position, side: CastlingSide, ctx: Context): SquareSet => {\n  if (!defined(ctx.king) || ctx.checkers.nonEmpty()) return SquareSet.empty();\n  const rook = pos.castles.rook[pos.turn][side];\n  if (!defined(rook)) return SquareSet.empty();\n  if (pos.castles.path[pos.turn][side].intersects(pos.board.occupied)) return SquareSet.empty();\n\n  const kingTo = kingCastlesTo(pos.turn, side);\n  const kingPath = between(ctx.king, kingTo);\n  const occ = pos.board.occupied.without(ctx.king);\n  for (const sq of kingPath) {\n    if (pos.kingAttackers(sq, opposite(pos.turn), occ).nonEmpty()) return SquareSet.empty();\n  }\n\n  const rookTo = rookCastlesTo(pos.turn, side);\n  const after = pos.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n  if (pos.kingAttackers(kingTo, opposite(pos.turn), after).nonEmpty()) return SquareSet.empty();\n\n  return SquareSet.fromSquare(rook);\n};\n\nexport const pseudoDests = (pos: Position, square: Square, ctx: Context): SquareSet => {\n  if (ctx.variantEnd) return SquareSet.empty();\n  const piece = pos.board.get(square);\n  if (!piece || piece.color !== pos.turn) return SquareSet.empty();\n\n  let pseudo = attacks(piece, square, pos.board.occupied);\n  if (piece.role === 'pawn') {\n    let captureTargets = pos.board[opposite(pos.turn)];\n    if (defined(pos.epSquare)) captureTargets = captureTargets.with(pos.epSquare);\n    pseudo = pseudo.intersect(captureTargets);\n    const delta = pos.turn === 'white' ? 8 : -8;\n    const step = square + delta;\n    if (0 <= step && step < 64 && !pos.board.occupied.has(step)) {\n      pseudo = pseudo.with(step);\n      const canDoubleStep = pos.turn === 'white' ? square < 16 : square >= 64 - 16;\n      const doubleStep = step + delta;\n      if (canDoubleStep && !pos.board.occupied.has(doubleStep)) {\n        pseudo = pseudo.with(doubleStep);\n      }\n    }\n    return pseudo;\n  } else {\n    pseudo = pseudo.diff(pos.board[pos.turn]);\n  }\n  if (square === ctx.king) return pseudo.union(castlingDest(pos, 'a', ctx)).union(castlingDest(pos, 'h', ctx));\n  else return pseudo;\n};\n\nexport const equalsIgnoreMoves = (left: Position, right: Position): boolean =>\n  left.rules === right.rules\n  && boardEquals(left.board, right.board)\n  && ((right.pockets && left.pockets?.equals(right.pockets)) || (!left.pockets && !right.pockets))\n  && left.turn === right.turn\n  && left.castles.castlingRights.equals(right.castles.castlingRights)\n  && legalEpSquare(left) === legalEpSquare(right)\n  && ((right.remainingChecks && left.remainingChecks?.equals(right.remainingChecks))\n    || (!left.remainingChecks && !right.remainingChecks));\n\nexport const castlingSide = (pos: Position, move: Move): CastlingSide | undefined => {\n  if (isDrop(move)) return;\n  const delta = move.to - move.from;\n  if (Math.abs(delta) !== 2 && !pos.board[pos.turn].has(move.to)) return;\n  if (!pos.board.king.has(move.from)) return;\n  return delta > 0 ? 'h' : 'a';\n};\n\nexport const normalizeMove = (pos: Position, move: Move): Move => {\n  const side = castlingSide(pos, move);\n  if (!side) return move;\n  const rookFrom = pos.castles.rook[pos.turn][side];\n  return {\n    from: (move as NormalMove).from,\n    to: defined(rookFrom) ? rookFrom : move.to,\n  };\n};\n\nexport const isStandardMaterialSide = (board: Board, color: Color): boolean => {\n  const promoted = Math.max(board.pieces(color, 'queen').size() - 1, 0)\n    + Math.max(board.pieces(color, 'rook').size() - 2, 0)\n    + Math.max(board.pieces(color, 'knight').size() - 2, 0)\n    + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.lightSquares()).size() - 1, 0)\n    + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.darkSquares()).size() - 1, 0);\n  return board.pieces(color, 'pawn').size() + promoted <= 8;\n};\n\nexport const isStandardMaterial = (pos: Chess): boolean =>\n  COLORS.every(color => isStandardMaterialSide(pos.board, color));\n\nexport const isImpossibleCheck = (pos: Position): boolean => {\n  const ourKing = pos.board.kingOf(pos.turn);\n  if (!defined(ourKing)) return false;\n  const checkers = pos.kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied);\n  if (checkers.isEmpty()) return false;\n  if (defined(pos.epSquare)) {\n    // The pushed pawn must be the only checker, or it has uncovered\n    // check by a single sliding piece.\n    const pushedTo = pos.epSquare ^ 8;\n    const pushedFrom = pos.epSquare ^ 24;\n    return (\n      checkers.moreThanOne()\n      || (checkers.first()! !== pushedTo\n        && pos\n          .kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied.without(pushedTo).with(pushedFrom))\n          .nonEmpty())\n    );\n  } else if (pos.rules === 'atomic') {\n    // Other king moving away can cause many checks to be given at the same\n    // time. Not checking details, or even that the king is close enough.\n    return false;\n  } else {\n    // Sliding checkers aligned with king.\n    return checkers.size() > 2\n      || (checkers.size() === 2 && ray(checkers.first()!, checkers.last()!).has(ourKing)) // Sliding checkers aligned with king\n      || checkers.intersect(pos.board.steppers()).moreThanOne();\n  }\n};\n", "import { Board, boardEquals } from './board.js';\nimport { SquareSet } from './squareSet.js';\nimport { ByColor, ByRole, Color, Role, ROLES, Square } from './types.js';\n\nexport class MaterialSide implements ByRole<number> {\n  pawn: number;\n  knight: number;\n  bishop: number;\n  rook: number;\n  queen: number;\n  king: number;\n\n  private constructor() {}\n\n  static empty(): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = 0;\n    return m;\n  }\n\n  static fromBoard(board: Board, color: Color): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = board.pieces(color, role).size();\n    return m;\n  }\n\n  clone(): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role];\n    return m;\n  }\n\n  equals(other: MaterialSide): boolean {\n    return ROLES.every(role => this[role] === other[role]);\n  }\n\n  add(other: MaterialSide): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role] + other[role];\n    return m;\n  }\n\n  subtract(other: MaterialSide): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role] - other[role];\n    return m;\n  }\n\n  nonEmpty(): boolean {\n    return ROLES.some(role => this[role] > 0);\n  }\n\n  isEmpty(): boolean {\n    return !this.nonEmpty();\n  }\n\n  hasPawns(): boolean {\n    return this.pawn > 0;\n  }\n\n  hasNonPawns(): boolean {\n    return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;\n  }\n\n  size(): number {\n    return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;\n  }\n}\n\nexport class Material implements ByColor<MaterialSide> {\n  constructor(\n    public white: MaterialSide,\n    public black: MaterialSide,\n  ) {}\n\n  static empty(): Material {\n    return new Material(MaterialSide.empty(), MaterialSide.empty());\n  }\n\n  static fromBoard(board: Board): Material {\n    return new Material(MaterialSide.fromBoard(board, 'white'), MaterialSide.fromBoard(board, 'black'));\n  }\n\n  clone(): Material {\n    return new Material(this.white.clone(), this.black.clone());\n  }\n\n  equals(other: Material): boolean {\n    return this.white.equals(other.white) && this.black.equals(other.black);\n  }\n\n  add(other: Material): Material {\n    return new Material(this.white.add(other.white), this.black.add(other.black));\n  }\n\n  subtract(other: Material): Material {\n    return new Material(this.white.subtract(other.white), this.black.subtract(other.black));\n  }\n\n  count(role: Role): number {\n    return this.white[role] + this.black[role];\n  }\n\n  size(): number {\n    return this.white.size() + this.black.size();\n  }\n\n  isEmpty(): boolean {\n    return this.white.isEmpty() && this.black.isEmpty();\n  }\n\n  nonEmpty(): boolean {\n    return !this.isEmpty();\n  }\n\n  hasPawns(): boolean {\n    return this.white.hasPawns() || this.black.hasPawns();\n  }\n\n  hasNonPawns(): boolean {\n    return this.white.hasNonPawns() || this.black.hasNonPawns();\n  }\n}\n\nexport class RemainingChecks implements ByColor<number> {\n  constructor(\n    public white: number,\n    public black: number,\n  ) {}\n\n  static default(): RemainingChecks {\n    return new RemainingChecks(3, 3);\n  }\n\n  clone(): RemainingChecks {\n    return new RemainingChecks(this.white, this.black);\n  }\n\n  equals(other: RemainingChecks): boolean {\n    return this.white === other.white && this.black === other.black;\n  }\n}\n\n/**\n * A not necessarily legal chess or chess variant position.\n */\nexport interface Setup {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castlingRights: SquareSet;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n}\n\nexport const defaultSetup = (): Setup => ({\n  board: Board.default(),\n  pockets: undefined,\n  turn: 'white',\n  castlingRights: SquareSet.corners(),\n  epSquare: undefined,\n  remainingChecks: undefined,\n  halfmoves: 0,\n  fullmoves: 1,\n});\n\nexport const setupClone = (setup: Setup): Setup => ({\n  board: setup.board.clone(),\n  pockets: setup.pockets?.clone(),\n  turn: setup.turn,\n  castlingRights: setup.castlingRights,\n  epSquare: setup.epSquare,\n  remainingChecks: setup.remainingChecks?.clone(),\n  halfmoves: setup.halfmoves,\n  fullmoves: setup.fullmoves,\n});\n\nexport const setupEquals = (left: Setup, right: Setup): boolean =>\n  boardEquals(left.board, right.board)\n  && ((right.pockets && left.pockets?.equals(right.pockets)) || (!left.pockets && !right.pockets))\n  && left.turn === right.turn\n  && left.castlingRights.equals(right.castlingRights)\n  && left.epSquare === right.epSquare\n  && ((right.remainingChecks && left.remainingChecks?.equals(right.remainingChecks))\n    || (!left.remainingChecks && !right.remainingChecks))\n  && left.halfmoves === right.halfmoves\n  && left.fullmoves === right.fullmoves;\n", "import { Result } from '@badrap/result';\nimport { Board } from './board.js';\nimport { Material, MaterialSide, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport { Color, COLORS, FILE_NAMES, Piece, ROLES, Square } from './types.js';\nimport { charToRole, defined, makeSquare, parseSquare, roleToChar, squareFile, squareFromCoords } from './util.js';\n\nexport const INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nexport const INITIAL_EPD = INITIAL_BOARD_FEN + ' w KQkq -';\nexport const INITIAL_FEN = INITIAL_EPD + ' 0 1';\nexport const EMPTY_BOARD_FEN = '8/8/8/8/8/8/8/8';\nexport const EMPTY_EPD = EMPTY_BOARD_FEN + ' w - -';\nexport const EMPTY_FEN = EMPTY_EPD + ' 0 1';\n\nexport enum InvalidFen {\n  Fen = 'ERR_FEN',\n  Board = 'ERR_BOARD',\n  Pockets = 'ERR_POCKETS',\n  Turn = 'ERR_TURN',\n  Castling = 'ERR_CASTLING',\n  EpSquare = 'ERR_EP_SQUARE',\n  RemainingChecks = 'ERR_REMAINING_CHECKS',\n  Halfmoves = 'ERR_HALFMOVES',\n  Fullmoves = 'ERR_FULLMOVES',\n}\n\nexport class FenError extends Error {}\n\nconst nthIndexOf = (haystack: string, needle: string, n: number): number => {\n  let index = haystack.indexOf(needle);\n  while (n-- > 0) {\n    if (index === -1) break;\n    index = haystack.indexOf(needle, index + needle.length);\n  }\n  return index;\n};\n\nconst parseSmallUint = (str: string): number | undefined => (/^\\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined);\n\nconst charToPiece = (ch: string): Piece | undefined => {\n  const role = charToRole(ch);\n  return role && { role, color: ch.toLowerCase() === ch ? 'black' : 'white' };\n};\n\nexport const parseBoardFen = (boardPart: string): Result<Board, FenError> => {\n  const board = Board.empty();\n  let rank = 7;\n  let file = 0;\n  for (let i = 0; i < boardPart.length; i++) {\n    const c = boardPart[i];\n    if (c === '/' && file === 8) {\n      file = 0;\n      rank--;\n    } else {\n      const step = parseInt(c, 10);\n      if (step > 0) file += step;\n      else {\n        if (file >= 8 || rank < 0) return Result.err(new FenError(InvalidFen.Board));\n        const square = file + rank * 8;\n        const piece = charToPiece(c);\n        if (!piece) return Result.err(new FenError(InvalidFen.Board));\n        if (boardPart[i + 1] === '~') {\n          piece.promoted = true;\n          i++;\n        }\n        board.set(square, piece);\n        file++;\n      }\n    }\n  }\n  if (rank !== 0 || file !== 8) return Result.err(new FenError(InvalidFen.Board));\n  return Result.ok(board);\n};\n\nexport const parsePockets = (pocketPart: string): Result<Material, FenError> => {\n  if (pocketPart.length > 64) return Result.err(new FenError(InvalidFen.Pockets));\n  const pockets = Material.empty();\n  for (const c of pocketPart) {\n    const piece = charToPiece(c);\n    if (!piece) return Result.err(new FenError(InvalidFen.Pockets));\n    pockets[piece.color][piece.role]++;\n  }\n  return Result.ok(pockets);\n};\n\nexport const parseCastlingFen = (board: Board, castlingPart: string): Result<SquareSet, FenError> => {\n  let castlingRights = SquareSet.empty();\n  if (castlingPart === '-') return Result.ok(castlingRights);\n\n  for (const c of castlingPart) {\n    const lower = c.toLowerCase();\n    const color = c === lower ? 'black' : 'white';\n    const rank = color === 'white' ? 0 : 7;\n    if ('a' <= lower && lower <= 'h') {\n      castlingRights = castlingRights.with(squareFromCoords(lower.charCodeAt(0) - 'a'.charCodeAt(0), rank)!);\n    } else if (lower === 'k' || lower === 'q') {\n      const rooksAndKings = board[color].intersect(SquareSet.backrank(color)).intersect(board.rook.union(board.king));\n      const candidate = lower === 'k' ? rooksAndKings.last() : rooksAndKings.first();\n      castlingRights = castlingRights.with(\n        defined(candidate) && board.rook.has(candidate) ? candidate : squareFromCoords(lower === 'k' ? 7 : 0, rank)!,\n      );\n    } else return Result.err(new FenError(InvalidFen.Castling));\n  }\n\n  if (COLORS.some(color => SquareSet.backrank(color).intersect(castlingRights).size() > 2)) {\n    return Result.err(new FenError(InvalidFen.Castling));\n  }\n\n  return Result.ok(castlingRights);\n};\n\nexport const parseRemainingChecks = (part: string): Result<RemainingChecks, FenError> => {\n  const parts = part.split('+');\n  if (parts.length === 3 && parts[0] === '') {\n    const white = parseSmallUint(parts[1]);\n    const black = parseSmallUint(parts[2]);\n    if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n      return Result.err(new FenError(InvalidFen.RemainingChecks));\n    }\n    return Result.ok(new RemainingChecks(3 - white, 3 - black));\n  } else if (parts.length === 2) {\n    const white = parseSmallUint(parts[0]);\n    const black = parseSmallUint(parts[1]);\n    if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n      return Result.err(new FenError(InvalidFen.RemainingChecks));\n    }\n    return Result.ok(new RemainingChecks(white, black));\n  } else return Result.err(new FenError(InvalidFen.RemainingChecks));\n};\n\nexport const parseFen = (fen: string): Result<Setup, FenError> => {\n  const parts = fen.split(/[\\s_]+/);\n  const boardPart = parts.shift()!;\n\n  // Board and pockets\n  let board: Result<Board, FenError>;\n  let pockets = Result.ok<Material | undefined, FenError>(undefined);\n  if (boardPart.endsWith(']')) {\n    const pocketStart = boardPart.indexOf('[');\n    if (pocketStart === -1) return Result.err(new FenError(InvalidFen.Fen));\n    board = parseBoardFen(boardPart.slice(0, pocketStart));\n    pockets = parsePockets(boardPart.slice(pocketStart + 1, -1));\n  } else {\n    const pocketStart = nthIndexOf(boardPart, '/', 7);\n    if (pocketStart === -1) board = parseBoardFen(boardPart);\n    else {\n      board = parseBoardFen(boardPart.slice(0, pocketStart));\n      pockets = parsePockets(boardPart.slice(pocketStart + 1));\n    }\n  }\n\n  // Turn\n  let turn: Color;\n  const turnPart = parts.shift();\n  if (!defined(turnPart) || turnPart === 'w') turn = 'white';\n  else if (turnPart === 'b') turn = 'black';\n  else return Result.err(new FenError(InvalidFen.Turn));\n\n  return board.chain(board => {\n    // Castling\n    const castlingPart = parts.shift();\n    const castlingRights = defined(castlingPart) ? parseCastlingFen(board, castlingPart) : Result.ok(SquareSet.empty());\n\n    // En passant square\n    const epPart = parts.shift();\n    let epSquare: Square | undefined;\n    if (defined(epPart) && epPart !== '-') {\n      epSquare = parseSquare(epPart);\n      if (!defined(epSquare)) return Result.err(new FenError(InvalidFen.EpSquare));\n    }\n\n    // Halfmoves or remaining checks\n    let halfmovePart = parts.shift();\n    let earlyRemainingChecks: Result<RemainingChecks, FenError> | undefined;\n    if (defined(halfmovePart) && halfmovePart.includes('+')) {\n      earlyRemainingChecks = parseRemainingChecks(halfmovePart);\n      halfmovePart = parts.shift();\n    }\n    const halfmoves = defined(halfmovePart) ? parseSmallUint(halfmovePart) : 0;\n    if (!defined(halfmoves)) return Result.err(new FenError(InvalidFen.Halfmoves));\n\n    const fullmovesPart = parts.shift();\n    const fullmoves = defined(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;\n    if (!defined(fullmoves)) return Result.err(new FenError(InvalidFen.Fullmoves));\n\n    const remainingChecksPart = parts.shift();\n    let remainingChecks: Result<RemainingChecks | undefined, FenError> = Result.ok(undefined);\n    if (defined(remainingChecksPart)) {\n      if (defined(earlyRemainingChecks)) return Result.err(new FenError(InvalidFen.RemainingChecks));\n      remainingChecks = parseRemainingChecks(remainingChecksPart);\n    } else if (defined(earlyRemainingChecks)) {\n      remainingChecks = earlyRemainingChecks;\n    }\n\n    if (parts.length > 0) return Result.err(new FenError(InvalidFen.Fen));\n\n    return pockets.chain(pockets =>\n      castlingRights.chain(castlingRights =>\n        remainingChecks.map(remainingChecks => {\n          return {\n            board,\n            pockets,\n            turn,\n            castlingRights,\n            remainingChecks,\n            epSquare,\n            halfmoves,\n            fullmoves: Math.max(1, fullmoves),\n          };\n        })\n      )\n    );\n  });\n};\n\nexport interface FenOpts {\n  epd?: boolean;\n}\n\nexport const parsePiece = (str: string): Piece | undefined => {\n  if (!str) return;\n  const piece = charToPiece(str[0]);\n  if (!piece) return;\n  if (str.length === 2 && str[1] === '~') piece.promoted = true;\n  else if (str.length > 1) return;\n  return piece;\n};\n\nexport const makePiece = (piece: Piece): string => {\n  let r: string = roleToChar(piece.role);\n  if (piece.color === 'white') r = r.toUpperCase();\n  if (piece.promoted) r += '~';\n  return r;\n};\n\nexport const makeBoardFen = (board: Board): string => {\n  let fen = '';\n  let empty = 0;\n  for (let rank = 7; rank >= 0; rank--) {\n    for (let file = 0; file < 8; file++) {\n      const square = file + rank * 8;\n      const piece = board.get(square);\n      if (!piece) empty++;\n      else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        fen += makePiece(piece);\n      }\n\n      if (file === 7) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        if (rank !== 0) fen += '/';\n      }\n    }\n  }\n  return fen;\n};\n\nexport const makePocket = (material: MaterialSide): string =>\n  ROLES.map(role => roleToChar(role).repeat(material[role])).join('');\n\nexport const makePockets = (pocket: Material): string =>\n  makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);\n\nexport const makeCastlingFen = (board: Board, castlingRights: SquareSet): string => {\n  let fen = '';\n  for (const color of COLORS) {\n    const backrank = SquareSet.backrank(color);\n    let king = board.kingOf(color);\n    if (defined(king) && !backrank.has(king)) king = undefined;\n    const candidates = board.pieces(color, 'rook').intersect(backrank);\n    for (const rook of castlingRights.intersect(backrank).reversed()) {\n      if (rook === candidates.first() && defined(king) && rook < king) {\n        fen += color === 'white' ? 'Q' : 'q';\n      } else if (rook === candidates.last() && defined(king) && king < rook) {\n        fen += color === 'white' ? 'K' : 'k';\n      } else {\n        const file = FILE_NAMES[squareFile(rook)];\n        fen += color === 'white' ? file.toUpperCase() : file;\n      }\n    }\n  }\n  return fen || '-';\n};\n\nexport const makeRemainingChecks = (checks: RemainingChecks): string => `${checks.white}+${checks.black}`;\n\nexport const makeFen = (setup: Setup, opts?: FenOpts): string =>\n  [\n    makeBoardFen(setup.board) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ''),\n    setup.turn[0],\n    makeCastlingFen(setup.board, setup.castlingRights),\n    defined(setup.epSquare) ? makeSquare(setup.epSquare) : '-',\n    ...(setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : []),\n    ...(opts?.epd ? [] : [Math.max(0, Math.min(setup.halfmoves, 9999)), Math.max(1, Math.min(setup.fullmoves, 9999))]),\n  ].join(' ');\n", "import { Result } from '@badrap/result';\nimport { between, kingAttacks, pawnAttacks } from './attacks.js';\nimport { Board } from './board.js';\nimport {\n  Castles,\n  castlingSide,\n  Chess,\n  Context,\n  equalsIgnoreMoves,\n  IllegalSetup,\n  isImpossibleCheck,\n  isStandardMaterialSide,\n  normalizeMove,\n  Position,\n  PositionError,\n  pseudoDests,\n} from './chess.js';\nimport { Material, MaterialSide, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport { Color, COLORS, Outcome, Piece, Rules, Square } from './types.js';\nimport { defined, opposite } from './util.js';\n\nexport {\n  Castles,\n  castlingSide,\n  Chess,\n  Context,\n  equalsIgnoreMoves,\n  IllegalSetup,\n  isImpossibleCheck,\n  normalizeMove,\n  Position,\n  PositionError,\n};\n\nexport class Crazyhouse extends Position {\n  private constructor() {\n    super('crazyhouse');\n  }\n\n  reset() {\n    super.reset();\n    this.pockets = Material.empty();\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.board.promoted = setup.board.promoted\n      .intersect(setup.board.occupied)\n      .diff(setup.board.king)\n      .diff(setup.board.pawn);\n    this.pockets = setup.pockets ? setup.pockets.clone() : Material.empty();\n  }\n\n  static default(): Crazyhouse {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Crazyhouse, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Crazyhouse {\n    return super.clone() as Crazyhouse;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    return super.validate().chain(_ => {\n      if (this.pockets?.count('king')) {\n        return Result.err(new PositionError(IllegalSetup.Kings));\n      }\n      if ((this.pockets?.size() || 0) + this.board.occupied.size() > 64) {\n        return Result.err(new PositionError(IllegalSetup.Variant));\n      }\n      return Result.ok(undefined);\n    });\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // No material can leave the game, but we can easily check this for\n    // custom positions.\n    if (!this.pockets) return super.hasInsufficientMaterial(color);\n    return (\n      this.board.occupied.size() + this.pockets.size() <= 3\n      && this.board.pawn.isEmpty()\n      && this.board.promoted.isEmpty()\n      && this.board.rooksAndQueens().isEmpty()\n      && this.pockets.count('pawn') <= 0\n      && this.pockets.count('rook') <= 0\n      && this.pockets.count('queen') <= 0\n    );\n  }\n\n  dropDests(ctx?: Context): SquareSet {\n    const mask = this.board.occupied\n      .complement()\n      .intersect(\n        this.pockets?.[this.turn].hasNonPawns()\n          ? SquareSet.full()\n          : this.pockets?.[this.turn].hasPawns()\n          ? SquareSet.backranks().complement()\n          : SquareSet.empty(),\n      );\n\n    ctx = ctx || this.ctx();\n    if (defined(ctx.king) && ctx.checkers.nonEmpty()) {\n      const checker = ctx.checkers.singleSquare();\n      if (!defined(checker)) return SquareSet.empty();\n      return mask.intersect(between(checker, ctx.king));\n    } else return mask;\n  }\n}\n\nexport class Atomic extends Position {\n  private constructor() {\n    super('atomic');\n  }\n\n  static default(): Atomic {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Atomic, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Atomic {\n    return super.clone() as Atomic;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    // Like chess, but allow our king to be missing.\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() > 2) return Result.err(new PositionError(IllegalSetup.Kings));\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n    return Result.ok(undefined);\n  }\n\n  kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    const attackerKings = this.board.pieces(attacker, 'king');\n    if (attackerKings.isEmpty() || kingAttacks(square).intersects(attackerKings)) {\n      return SquareSet.empty();\n    }\n    return super.kingAttackers(square, attacker, occupied);\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    super.playCaptureAt(square, captured);\n    this.board.take(square);\n    for (const explode of kingAttacks(square).intersect(this.board.occupied).diff(this.board.pawn)) {\n      const piece = this.board.take(explode);\n      if (piece?.role === 'rook') this.castles.discardRook(explode);\n      if (piece?.role === 'king') this.castles.discardColor(piece.color);\n    }\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // Remaining material does not matter if the enemy king is already\n    // exploded.\n    if (this.board.pieces(opposite(color), 'king').isEmpty()) return false;\n\n    // Bare king cannot mate.\n    if (this.board[color].diff(this.board.king).isEmpty()) return true;\n\n    // As long as the enemy king is not alone, there is always a chance their\n    // own pieces explode next to it.\n    if (this.board[opposite(color)].diff(this.board.king).nonEmpty()) {\n      // Unless there are only bishops that cannot explode each other.\n      if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) {\n        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.darkSquares())) {\n          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.lightSquares());\n        }\n        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.lightSquares())) {\n          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.darkSquares());\n        }\n      }\n      return false;\n    }\n\n    // Queen or pawn (future queen) can give mate against bare king.\n    if (this.board.queen.nonEmpty() || this.board.pawn.nonEmpty()) return false;\n\n    // Single knight, bishop or rook cannot mate against bare king.\n    if (this.board.knight.union(this.board.bishop).union(this.board.rook).size() === 1) return true;\n\n    // If only knights, more than two are required to mate bare king.\n    if (this.board.occupied.equals(this.board.knight.union(this.board.king))) {\n      return this.board.knight.size() <= 2;\n    }\n\n    return false;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    let dests = SquareSet.empty();\n    for (const to of pseudoDests(this, square, ctx)) {\n      const after = this.clone();\n      after.play({ from: square, to });\n      const ourKing = after.board.kingOf(this.turn);\n      if (\n        defined(ourKing)\n        && (!defined(after.board.kingOf(after.turn))\n          || after.kingAttackers(ourKing, after.turn, after.board.occupied).isEmpty())\n      ) {\n        dests = dests.with(to);\n      }\n    }\n    return dests;\n  }\n\n  isVariantEnd(): boolean {\n    return !!this.variantOutcome();\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'king').isEmpty()) return { winner: opposite(color) };\n    }\n    return;\n  }\n}\n\nexport class Antichess extends Position {\n  private constructor() {\n    super('antichess');\n  }\n\n  reset() {\n    super.reset();\n    this.castles = Castles.empty();\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.castles = Castles.empty();\n  }\n\n  static default(): Antichess {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Antichess, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Antichess {\n    return super.clone() as Antichess;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n    return Result.ok(undefined);\n  }\n\n  kingAttackers(_square: Square, _attacker: Color, _occupied: SquareSet): SquareSet {\n    return SquareSet.empty();\n  }\n\n  ctx(): Context {\n    const ctx = super.ctx();\n    if (\n      defined(this.epSquare)\n      && pawnAttacks(opposite(this.turn), this.epSquare).intersects(this.board.pieces(this.turn, 'pawn'))\n    ) {\n      ctx.mustCapture = true;\n      return ctx;\n    }\n    const enemy = this.board[opposite(this.turn)];\n    for (const from of this.board[this.turn]) {\n      if (pseudoDests(this, from, ctx).intersects(enemy)) {\n        ctx.mustCapture = true;\n        return ctx;\n      }\n    }\n    return ctx;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    const dests = pseudoDests(this, square, ctx);\n    const enemy = this.board[opposite(this.turn)];\n    return dests.intersect(\n      ctx.mustCapture\n        ? defined(this.epSquare) && this.board.getRole(square) === 'pawn'\n          ? enemy.with(this.epSquare)\n          : enemy\n        : SquareSet.full(),\n    );\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board[color].isEmpty()) return false;\n    if (this.board[opposite(color)].isEmpty()) return true;\n    if (this.board.occupied.equals(this.board.bishop)) {\n      const weSomeOnLight = this.board[color].intersects(SquareSet.lightSquares());\n      const weSomeOnDark = this.board[color].intersects(SquareSet.darkSquares());\n      const theyAllOnDark = this.board[opposite(color)].isDisjoint(SquareSet.lightSquares());\n      const theyAllOnLight = this.board[opposite(color)].isDisjoint(SquareSet.darkSquares());\n      return (weSomeOnLight && theyAllOnDark) || (weSomeOnDark && theyAllOnLight);\n    }\n    if (this.board.occupied.equals(this.board.knight) && this.board.occupied.size() === 2) {\n      return (\n        (this.board.white.intersects(SquareSet.lightSquares())\n          !== this.board.black.intersects(SquareSet.darkSquares()))\n          !== (this.turn === color)\n      );\n    }\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board[this.turn].isEmpty();\n  }\n\n  variantOutcome(ctx?: Context): Outcome | undefined {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd || this.isStalemate(ctx)) {\n      return { winner: this.turn };\n    }\n    return;\n  }\n}\n\nexport class KingOfTheHill extends Position {\n  private constructor() {\n    super('kingofthehill');\n  }\n\n  static default(): KingOfTheHill {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<KingOfTheHill, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): KingOfTheHill {\n    return super.clone() as KingOfTheHill;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board.king.intersects(SquareSet.center());\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'king').intersects(SquareSet.center())) return { winner: color };\n    }\n    return;\n  }\n}\n\nexport class ThreeCheck extends Position {\n  private constructor() {\n    super('3check');\n  }\n\n  reset() {\n    super.reset();\n    this.remainingChecks = RemainingChecks.default();\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.remainingChecks = setup.remainingChecks?.clone() || RemainingChecks.default();\n  }\n\n  static default(): ThreeCheck {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<ThreeCheck, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): ThreeCheck {\n    return super.clone() as ThreeCheck;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    return this.board.pieces(color, 'king').equals(this.board[color]);\n  }\n\n  isVariantEnd(): boolean {\n    return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0);\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    if (this.remainingChecks) {\n      for (const color of COLORS) {\n        if (this.remainingChecks[color] <= 0) return { winner: color };\n      }\n    }\n    return;\n  }\n}\n\nconst racingKingsBoard = (): Board => {\n  const board = Board.empty();\n  board.occupied = new SquareSet(0xffff, 0);\n  board.promoted = SquareSet.empty();\n  board.white = new SquareSet(0xf0f0, 0);\n  board.black = new SquareSet(0x0f0f, 0);\n  board.pawn = SquareSet.empty();\n  board.knight = new SquareSet(0x1818, 0);\n  board.bishop = new SquareSet(0x2424, 0);\n  board.rook = new SquareSet(0x4242, 0);\n  board.queen = new SquareSet(0x0081, 0);\n  board.king = new SquareSet(0x8100, 0);\n  return board;\n};\n\nexport class RacingKings extends Position {\n  private constructor() {\n    super('racingkings');\n  }\n\n  reset() {\n    this.board = racingKingsBoard();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.empty();\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.castles = Castles.empty();\n  }\n\n  static default(): RacingKings {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<RacingKings, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): RacingKings {\n    return super.clone() as RacingKings;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.isCheck() || this.board.pawn.nonEmpty()) return Result.err(new PositionError(IllegalSetup.Variant));\n    return super.validate();\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n\n    // Kings cannot give check.\n    if (square === ctx.king) return super.dests(square, ctx);\n\n    // Do not allow giving check.\n    let dests = SquareSet.empty();\n    for (const to of super.dests(square, ctx)) {\n      // Valid, because there are no promotions (or even pawns).\n      const move = { from: square, to };\n      const after = this.clone();\n      after.play(move);\n      if (!after.isCheck()) dests = dests.with(to);\n    }\n    return dests;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    const goal = SquareSet.fromRank(7);\n    const inGoal = this.board.king.intersect(goal);\n    if (inGoal.isEmpty()) return false;\n    if (this.turn === 'white' || inGoal.intersects(this.board.black)) return true;\n\n    // White has reached the backrank. Check if black can catch up.\n    const blackKing = this.board.kingOf('black');\n    if (defined(blackKing)) {\n      const occ = this.board.occupied.without(blackKing);\n      for (const target of kingAttacks(blackKing).intersect(goal).diff(this.board.black)) {\n        if (this.kingAttackers(target, 'white', occ).isEmpty()) return false;\n      }\n    }\n    return true;\n  }\n\n  variantOutcome(ctx?: Context): Outcome | undefined {\n    if (ctx ? !ctx.variantEnd : !this.isVariantEnd()) return;\n    const goal = SquareSet.fromRank(7);\n    const blackInGoal = this.board.pieces('black', 'king').intersects(goal);\n    const whiteInGoal = this.board.pieces('white', 'king').intersects(goal);\n    if (blackInGoal && !whiteInGoal) return { winner: 'black' };\n    if (whiteInGoal && !blackInGoal) return { winner: 'white' };\n    return { winner: undefined };\n  }\n}\n\nconst hordeBoard = (): Board => {\n  const board = Board.empty();\n  board.occupied = new SquareSet(0xffff_ffff, 0xffff_0066);\n  board.promoted = SquareSet.empty();\n  board.white = new SquareSet(0xffff_ffff, 0x0000_0066);\n  board.black = new SquareSet(0, 0xffff_0000);\n  board.pawn = new SquareSet(0xffff_ffff, 0x00ff_0066);\n  board.knight = new SquareSet(0, 0x4200_0000);\n  board.bishop = new SquareSet(0, 0x2400_0000);\n  board.rook = new SquareSet(0, 0x8100_0000);\n  board.queen = new SquareSet(0, 0x0800_0000);\n  board.king = new SquareSet(0, 0x1000_0000);\n  return board;\n};\n\nexport class Horde extends Position {\n  private constructor() {\n    super('horde');\n  }\n\n  reset() {\n    this.board = hordeBoard();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.default();\n    this.castles.discardColor('white');\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  static default(): Horde {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Horde, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Horde {\n    return super.clone() as Horde;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() !== 1) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (defined(otherKing) && this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n    for (const color of COLORS) {\n      const backranks = this.board.pieces(color, 'king').isEmpty()\n        ? SquareSet.backrank(opposite(color))\n        : SquareSet.backranks();\n      if (this.board.pieces(color, 'pawn').intersects(backranks)) {\n        return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n      }\n    }\n    return Result.ok(undefined);\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // The side with the king can always win by capturing the horde.\n    if (this.board.pieces(color, 'king').nonEmpty()) return false;\n\n    type SquareColor = 'light' | 'dark';\n    const oppositeSquareColor = (squareColor: SquareColor): SquareColor => (squareColor === 'light' ? 'dark' : 'light');\n    const coloredSquares = (squareColor: SquareColor): SquareSet =>\n      squareColor === 'light' ? SquareSet.lightSquares() : SquareSet.darkSquares();\n\n    const hasBishopPair = (side: Color) => {\n      const bishops = this.board.pieces(side, 'bishop');\n      return bishops.intersects(SquareSet.darkSquares()) && bishops.intersects(SquareSet.lightSquares());\n    };\n\n    // By this point: color is the horde.\n    // Based on\n    // https://github.com/stevepapazis/horde-insufficient-material-tests.\n    const horde = MaterialSide.fromBoard(this.board, color);\n    const hordeBishops = (squareColor: SquareColor) =>\n      coloredSquares(squareColor).intersect(this.board.pieces(color, 'bishop')).size();\n    const hordeBishopColor: SquareColor = hordeBishops('light') >= 1 ? 'light' : 'dark';\n    const hordeNum = horde.pawn\n      + horde.knight\n      + horde.rook\n      + horde.queen\n      + Math.min(hordeBishops('dark'), 2)\n      + Math.min(hordeBishops('light'), 2);\n\n    const pieces = MaterialSide.fromBoard(this.board, opposite(color));\n    const piecesBishops = (squareColor: SquareColor) =>\n      coloredSquares(squareColor)\n        .intersect(this.board.pieces(opposite(color), 'bishop'))\n        .size();\n    const piecesNum = pieces.size();\n    const piecesOfRoleNot = (piece: number) => piecesNum - piece;\n\n    if (hordeNum === 0) return true;\n    if (hordeNum >= 4) {\n      // Four or more pieces can always deliver mate.\n      return false;\n    }\n    if ((horde.pawn >= 1 || horde.queen >= 1) && hordeNum >= 2) {\n      // Pawns/queens are never insufficient material when paired with any other\n      // piece (a pawn promotes to a queen and delivers mate).\n      return false;\n    }\n    if (horde.rook >= 1 && hordeNum >= 2) {\n      // A rook is insufficient material only when it is paired with a bishop\n      // against a lone king. The horde can mate in any other case.\n      // A rook on A1 and a bishop on C3 mate a king on B1 when there is a\n      // friendly pawn/opposite-color-bishop/rook/queen on C2.\n      // A rook on B8 and a bishop C3 mate a king on A1 when there is a friendly\n      // knight on A2.\n      if (\n        !(\n          hordeNum === 2\n          && horde.rook === 1\n          && horde.bishop === 1\n          && piecesOfRoleNot(piecesBishops(hordeBishopColor)) === 1\n        )\n      ) {\n        return false;\n      }\n    }\n\n    if (hordeNum === 1) {\n      if (piecesNum === 1) {\n        // A lone piece cannot mate a lone king.\n        return true;\n      } else if (horde.queen === 1) {\n        // The horde has a lone queen.\n        // A lone queen mates a king on A1 bounded by:\n        //  -- a pawn/rook on A2\n        //  -- two same color bishops on A2, B1\n        // We ignore every other mating case, since it can be reduced to\n        // the two previous cases (e.g. a black pawn on A2 and a black\n        // bishop on B1).\n        return !(pieces.pawn >= 1 || pieces.rook >= 1 || piecesBishops('light') >= 2 || piecesBishops('dark') >= 2);\n      } else if (horde.pawn === 1) {\n        // Promote the pawn to a queen or a knight and check whether white\n        // can mate.\n        const pawnSquare = this.board.pieces(color, 'pawn').last()!;\n        const promoteToQueen = this.clone();\n        promoteToQueen.board.set(pawnSquare, { color, role: 'queen' });\n        const promoteToKnight = this.clone();\n        promoteToKnight.board.set(pawnSquare, { color, role: 'knight' });\n        return promoteToQueen.hasInsufficientMaterial(color) && promoteToKnight.hasInsufficientMaterial(color);\n      } else if (horde.rook === 1) {\n        // A lone rook mates a king on A8 bounded by a pawn/rook on A7 and a\n        // pawn/knight on B7. We ignore every other case, since it can be\n        // reduced to the two previous cases.\n        // (e.g. three pawns on A7, B7, C7)\n        return !(\n          pieces.pawn >= 2\n          || (pieces.rook >= 1 && pieces.pawn >= 1)\n          || (pieces.rook >= 1 && pieces.knight >= 1)\n          || (pieces.pawn >= 1 && pieces.knight >= 1)\n        );\n      } else if (horde.bishop === 1) {\n        // The horde has a lone bishop.\n        return !(\n          // The king can be mated on A1 if there is a pawn/opposite-color-bishop\n          // on A2 and an opposite-color-bishop on B1.\n          // If black has two or more pawns, white gets the benefit of the doubt;\n          // there is an outside chance that white promotes its pawns to\n          // opposite-color-bishops and selfmates theirself.\n          // Every other case that the king is mated by the bishop requires that\n          // black has two pawns or two opposite-color-bishop or a pawn and an\n          // opposite-color-bishop.\n          // For example a king on A3 can be mated if there is\n          // a pawn/opposite-color-bishop on A4, a pawn/opposite-color-bishop on\n          // B3, a pawn/bishop/rook/queen on A2 and any other piece on B2.\n          piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 2\n          || (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 && pieces.pawn >= 1)\n          || pieces.pawn >= 2\n        );\n      } else if (horde.knight === 1) {\n        // The horde has a lone knight.\n        return !(\n          // The king on A1 can be smother mated by a knight on C2 if there is\n          // a pawn/knight/bishop on B2, a knight/rook on B1 and any other piece\n          // on A2.\n          // Moreover, when black has four or more pieces and two of them are\n          // pawns, black can promote their pawns and selfmate theirself.\n          piecesNum >= 4\n          && (pieces.knight >= 2\n            || pieces.pawn >= 2\n            || (pieces.rook >= 1 && pieces.knight >= 1)\n            || (pieces.rook >= 1 && pieces.bishop >= 1)\n            || (pieces.knight >= 1 && pieces.bishop >= 1)\n            || (pieces.rook >= 1 && pieces.pawn >= 1)\n            || (pieces.knight >= 1 && pieces.pawn >= 1)\n            || (pieces.bishop >= 1 && pieces.pawn >= 1)\n            || (hasBishopPair(opposite(color)) && pieces.pawn >= 1))\n          && (piecesBishops('dark') < 2 || piecesOfRoleNot(piecesBishops('dark')) >= 3)\n          && (piecesBishops('light') < 2 || piecesOfRoleNot(piecesBishops('light')) >= 3)\n        );\n      }\n\n      // By this point, we only need to deal with white's minor pieces.\n    } else if (hordeNum === 2) {\n      if (piecesNum === 1) {\n        // Two minor pieces cannot mate a lone king.\n        return true;\n      } else if (horde.knight === 2) {\n        // A king on A1 is mated by two knights, if it is obstructed by a\n        // pawn/bishop/knight on B2. On the other hand, if black only has\n        // major pieces it is a draw.\n        return pieces.pawn + pieces.bishop + pieces.knight < 1;\n      } else if (hasBishopPair(color)) {\n        return !(\n          // A king on A1 obstructed by a pawn/bishop on A2 is mated\n          // by the bishop pair.\n          pieces.pawn >= 1\n          || pieces.bishop >= 1\n          // A pawn/bishop/knight on B4, a pawn/bishop/rook/queen on\n          // A4 and the king on A3 enable Boden's mate by the bishop\n          // pair. In every other case white cannot win.\n          || (pieces.knight >= 1 && pieces.rook + pieces.queen >= 1)\n        );\n      } else if (horde.bishop >= 1 && horde.knight >= 1) {\n        // The horde has a bishop and a knight.\n        return !(\n          // A king on A1 obstructed by a pawn/opposite-color-bishop on\n          // A2 is mated by a knight on D2 and a bishop on C3.\n          pieces.pawn >= 1\n          || piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1\n          // A king on A1 bounded by two friendly pieces on A2 and B1 is\n          // mated when the knight moves from D4 to C2 so that both the\n          // knight and the bishop deliver check.\n          || piecesOfRoleNot(piecesBishops(hordeBishopColor)) >= 3\n        );\n      } else {\n        // The horde has two or more bishops on the same color.\n        // White can only win if black has enough material to obstruct\n        // the squares of the opposite color around the king.\n        return !(\n          // A king on A1 obstructed by a pawn/opposite-bishop/knight\n          // on A2 and a opposite-bishop/knight on B1 is mated by two\n          // bishops on B2 and C3. This position is theoretically\n          // achievable even when black has two pawns or when they\n          // have a pawn and an opposite color bishop.\n          (pieces.pawn >= 1 && piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1)\n          || (pieces.pawn >= 1 && pieces.knight >= 1)\n          || (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 && pieces.knight >= 1)\n          || piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 2\n          || pieces.knight >= 2\n          || pieces.pawn >= 2\n          // In every other case, white can only draw.\n        );\n      }\n    } else if (hordeNum === 3) {\n      // A king in the corner is mated by two knights and a bishop or three\n      // knights or the bishop pair and a knight/bishop.\n      if ((horde.knight === 2 && horde.bishop === 1) || horde.knight === 3 || hasBishopPair(color)) {\n        return false;\n      } else {\n        // White has two same color bishops and a knight.\n        // A king on A1 is mated by a bishop on B2, a bishop on C1 and a\n        // knight on C3, as long as there is another black piece to waste\n        // a tempo.\n        return piecesNum === 1;\n      }\n    }\n\n    return true;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board.white.isEmpty() || this.board.black.isEmpty();\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    if (this.board.white.isEmpty()) return { winner: 'black' };\n    if (this.board.black.isEmpty()) return { winner: 'white' };\n    return;\n  }\n}\n\nexport const defaultPosition = (rules: Rules): Position => {\n  switch (rules) {\n    case 'chess':\n      return Chess.default();\n    case 'antichess':\n      return Antichess.default();\n    case 'atomic':\n      return Atomic.default();\n    case 'horde':\n      return Horde.default();\n    case 'racingkings':\n      return RacingKings.default();\n    case 'kingofthehill':\n      return KingOfTheHill.default();\n    case '3check':\n      return ThreeCheck.default();\n    case 'crazyhouse':\n      return Crazyhouse.default();\n  }\n};\n\nexport const setupPosition = (rules: Rules, setup: Setup): Result<Position, PositionError> => {\n  switch (rules) {\n    case 'chess':\n      return Chess.fromSetup(setup);\n    case 'antichess':\n      return Antichess.fromSetup(setup);\n    case 'atomic':\n      return Atomic.fromSetup(setup);\n    case 'horde':\n      return Horde.fromSetup(setup);\n    case 'racingkings':\n      return RacingKings.fromSetup(setup);\n    case 'kingofthehill':\n      return KingOfTheHill.fromSetup(setup);\n    case '3check':\n      return ThreeCheck.fromSetup(setup);\n    case 'crazyhouse':\n      return Crazyhouse.fromSetup(setup);\n  }\n};\n\nexport const isStandardMaterial = (pos: Position): boolean => {\n  switch (pos.rules) {\n    case 'chess':\n    case 'antichess':\n    case 'atomic':\n    case 'kingofthehill':\n    case '3check':\n      return COLORS.every(color => isStandardMaterialSide(pos.board, color));\n    case 'crazyhouse': {\n      const promoted = pos.board.promoted;\n      return (\n        promoted.size() + pos.board.pawn.size() + (pos.pockets?.count('pawn') || 0) <= 16\n        && pos.board.knight.diff(promoted).size() + (pos.pockets?.count('knight') || 0) <= 4\n        && pos.board.bishop.diff(promoted).size() + (pos.pockets?.count('bishop') || 0) <= 4\n        && pos.board.rook.diff(promoted).size() + (pos.pockets?.count('rook') || 0) <= 4\n        && pos.board.queen.diff(promoted).size() + (pos.pockets?.count('queen') || 0) <= 2\n      );\n    }\n    case 'horde':\n      return COLORS.every(color =>\n        pos.board.pieces(color, 'king').nonEmpty()\n          ? isStandardMaterialSide(pos.board, color)\n          : pos.board[color].size() <= 36\n      );\n    case 'racingkings':\n      return COLORS.every(\n        color =>\n          pos.board.pieces(color, 'knight').size() <= 2\n          && pos.board.pieces(color, 'bishop').size() <= 2\n          && pos.board.pieces(color, 'rook').size() <= 2\n          && pos.board.pieces(color, 'queen').size() <= 1,\n      );\n  }\n};\n", "/**\n * Parse, transform and write PGN.\n *\n * ## Parser\n *\n * The parser will interpret any input as a PGN, creating a tree of\n * syntactically valid (but not necessarily legal) moves, skipping any invalid\n * tokens.\n *\n * ```ts\n * import { parsePgn, startingPosition } from 'chessops/pgn';\n * import { parseSan } from 'chessops/san';\n *\n * const pgn = '1. d4 d5 *';\n * const games = parsePgn(pgn);\n * for (const game of games) {\n *   const pos = startingPosition(game.headers).unwrap();\n *   for (const node of game.moves.mainline()) {\n *     const move = parseSan(pos, node.san);\n *     if (!move) break; // Illegal move\n *     pos.play(move);\n *   }\n * }\n * ```\n *\n * ## Streaming parser\n *\n * The module also provides a denial-of-service resistant streaming parser.\n * It can be configured with a budget for reasonable complexity of a single\n * game, fed with chunks of text, and will yield parsed games as they are\n * completed.\n *\n * ```ts\n *\n * import { createReadStream } from 'fs';\n * import { PgnParser } from 'chessops/pgn';\n *\n * const stream = createReadStream('games.pgn', { encoding: 'utf-8' });\n *\n * const parser = new PgnParser((game, err) => {\n *   if (err) {\n *     // Budget exceeded.\n *     stream.destroy(err);\n *   }\n *\n *   // Use game ...\n * });\n *\n * await new Promise<void>(resolve =>\n *   stream\n *     .on('data', (chunk: string) => parser.parse(chunk, { stream: true }))\n *     .on('close', () => {\n *       parser.parse('');\n *       resolve();\n *     })\n * );\n * ```\n *\n * ## Augmenting the game tree\n *\n * You can use `walk` to visit all nodes in the game tree, or `transform`\n * to augment it with user data.\n *\n * Both allow you to provide context. You update the context inside the\n * callback, and it is automatically `clone()`-ed at each fork.\n * In the example below, the current position `pos` is provided as context.\n *\n * ```ts\n * import { transform } from 'chessops/pgn';\n * import { makeFen } from 'chessops/fen';\n * import { parseSan, makeSanAndPlay } from 'chessops/san';\n *\n * const pos = startingPosition(game.headers).unwrap();\n * game.moves = transform(game.moves, pos, (pos, node) => {\n *   const move = parseSan(pos, node.san);\n *   if (!move) {\n *     // Illegal move. Returning undefined cuts off the tree here.\n *     return;\n *   }\n *\n *   const san = makeSanAndPlay(pos, move); // Mutating pos!\n *\n *   return {\n *     ...node, // Keep comments and annotation glyphs\n *     san, // Normalized SAN\n *     fen: makeFen(pos.toSetup()), // Add arbitrary user data to node\n *   };\n * });\n * ```\n *\n * ## Writing\n *\n * Requires each node to at least have a `san` property.\n *\n * ```\n * import { makePgn } from 'chessops/pgn';\n *\n * const rewrittenPgn = makePgn(game);\n * ```\n *\n * @packageDocumentation\n */\nimport { Result } from '@badrap/result';\nimport { IllegalSetup, Position, PositionError } from './chess.js';\nimport { FenError, makeFen, parseFen } from './fen.js';\nimport { Outcome, Rules, Square } from './types.js';\nimport { defined, makeSquare, parseSquare } from './util.js';\nimport { defaultPosition, setupPosition } from './variant.js';\n\nexport interface Game<T> {\n  headers: Map<string, string>;\n  comments?: string[];\n  moves: Node<T>;\n}\n\nexport const defaultGame = <T>(initHeaders: () => Map<string, string> = defaultHeaders): Game<T> => ({\n  headers: initHeaders(),\n  moves: new Node(),\n});\n\nexport class Node<T> {\n  children: ChildNode<T>[] = [];\n\n  *mainlineNodes(): Iterable<ChildNode<T>> {\n    let node: Node<T> = this;\n    while (node.children.length) {\n      const child = node.children[0];\n      yield child;\n      node = child;\n    }\n  }\n\n  *mainline(): Iterable<T> {\n    for (const child of this.mainlineNodes()) yield child.data;\n  }\n\n  end(): Node<T> {\n    let node: Node<T> = this;\n    while (node.children.length) node = node.children[0];\n    return node;\n  }\n}\n\nexport class ChildNode<T> extends Node<T> {\n  constructor(public data: T) {\n    super();\n  }\n}\n\nexport const isChildNode = <T>(node: Node<T>): node is ChildNode<T> => node instanceof ChildNode;\n\nexport const extend = <T>(node: Node<T>, data: T[]): Node<T> => {\n  for (const d of data) {\n    const child = new ChildNode(d);\n    node.children.push(child);\n    node = child;\n  }\n  return node;\n};\n\nexport class Box<T> {\n  constructor(public value: T) {}\n\n  clone(): Box<T> {\n    return new Box(this.value);\n  }\n}\n\nexport const transform = <T, U, C extends { clone(): C }>(\n  node: Node<T>,\n  ctx: C,\n  f: (ctx: C, data: T, childIndex: number) => U | undefined,\n): Node<U> => {\n  const root = new Node<U>();\n  const stack = [\n    {\n      before: node,\n      after: root,\n      ctx,\n    },\n  ];\n  let frame;\n  while ((frame = stack.pop())) {\n    for (let childIndex = 0; childIndex < frame.before.children.length; childIndex++) {\n      const ctx = childIndex < frame.before.children.length - 1 ? frame.ctx.clone() : frame.ctx;\n      const childBefore = frame.before.children[childIndex];\n      const data = f(ctx, childBefore.data, childIndex);\n      if (defined(data)) {\n        const childAfter = new ChildNode(data);\n        frame.after.children.push(childAfter);\n        stack.push({\n          before: childBefore,\n          after: childAfter,\n          ctx,\n        });\n      }\n    }\n  }\n  return root;\n};\n\nexport const walk = <T, C extends { clone(): C }>(\n  node: Node<T>,\n  ctx: C,\n  f: (ctx: C, data: T, childIndex: number) => boolean | void,\n) => {\n  const stack = [{ node, ctx }];\n  let frame;\n  while ((frame = stack.pop())) {\n    for (let childIndex = 0; childIndex < frame.node.children.length; childIndex++) {\n      const ctx = childIndex < frame.node.children.length - 1 ? frame.ctx.clone() : frame.ctx;\n      const child = frame.node.children[childIndex];\n      if (f(ctx, child.data, childIndex) !== false) stack.push({ node: child, ctx });\n    }\n  }\n};\n\nexport interface PgnNodeData {\n  san: string;\n  startingComments?: string[];\n  comments?: string[];\n  nags?: number[];\n}\n\nexport const makeOutcome = (outcome: Outcome | undefined): string => {\n  if (!outcome) return '*';\n  else if (outcome.winner === 'white') return '1-0';\n  else if (outcome.winner === 'black') return '0-1';\n  else return '1/2-1/2';\n};\n\nexport const parseOutcome = (s: string | undefined): Outcome | undefined => {\n  if (s === '1-0' || s === '10' || s === '10') return { winner: 'white' };\n  else if (s === '0-1' || s === '01' || s === '01') return { winner: 'black' };\n  else if (s === '1/2-1/2' || s === '1/21/2' || s === '1/21/2') return { winner: undefined };\n  else return;\n};\n\nconst escapeHeader = (value: string): string => value.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n\nconst safeComment = (comment: string): string => comment.replace(/\\}/g, '');\n\nconst enum MakePgnState {\n  Pre = 0,\n  Sidelines = 1,\n  End = 2,\n}\n\ninterface MakePgnFrame {\n  state: MakePgnState;\n  ply: number;\n  node: ChildNode<PgnNodeData>;\n  sidelines: Iterator<ChildNode<PgnNodeData>>;\n  startsVariation: boolean;\n  inVariation: boolean;\n}\n\nexport const makePgn = (game: Game<PgnNodeData>): string => {\n  const builder = [],\n    tokens = [];\n\n  if (game.headers.size) {\n    for (const [key, value] of game.headers.entries()) {\n      builder.push('[', key, ' \"', escapeHeader(value), '\"]\\n');\n    }\n    builder.push('\\n');\n  }\n\n  for (const comment of game.comments || []) tokens.push('{', safeComment(comment), '}');\n\n  const fen = game.headers.get('FEN');\n  const initialPly = fen\n    ? parseFen(fen).unwrap(\n      setup => (setup.fullmoves - 1) * 2 + (setup.turn === 'white' ? 0 : 1),\n      _ => 0,\n    )\n    : 0;\n\n  const stack: MakePgnFrame[] = [];\n\n  const variations = game.moves.children[Symbol.iterator]();\n  const firstVariation = variations.next();\n  if (!firstVariation.done) {\n    stack.push({\n      state: MakePgnState.Pre,\n      ply: initialPly,\n      node: firstVariation.value,\n      sidelines: variations,\n      startsVariation: false,\n      inVariation: false,\n    });\n  }\n\n  let forceMoveNumber = true;\n  while (stack.length) {\n    const frame = stack[stack.length - 1];\n\n    if (frame.inVariation) {\n      tokens.push(')');\n      frame.inVariation = false;\n      forceMoveNumber = true;\n    }\n\n    switch (frame.state) {\n      case MakePgnState.Pre:\n        for (const comment of frame.node.data.startingComments || []) {\n          tokens.push('{', safeComment(comment), '}');\n          forceMoveNumber = true;\n        }\n        if (forceMoveNumber || frame.ply % 2 === 0) {\n          tokens.push(Math.floor(frame.ply / 2) + 1 + (frame.ply % 2 ? '...' : '.'));\n          forceMoveNumber = false;\n        }\n        tokens.push(frame.node.data.san);\n        for (const nag of frame.node.data.nags || []) {\n          tokens.push('$' + nag);\n          forceMoveNumber = true;\n        }\n        for (const comment of frame.node.data.comments || []) {\n          tokens.push('{', safeComment(comment), '}');\n        }\n        frame.state = MakePgnState.Sidelines; // fall through\n      case MakePgnState.Sidelines: {\n        const child = frame.sidelines.next();\n        if (child.done) {\n          const variations = frame.node.children[Symbol.iterator]();\n          const firstVariation = variations.next();\n          if (!firstVariation.done) {\n            stack.push({\n              state: MakePgnState.Pre,\n              ply: frame.ply + 1,\n              node: firstVariation.value,\n              sidelines: variations,\n              startsVariation: false,\n              inVariation: false,\n            });\n          }\n          frame.state = MakePgnState.End;\n        } else {\n          tokens.push('(');\n          forceMoveNumber = true;\n          stack.push({\n            state: MakePgnState.Pre,\n            ply: frame.ply,\n            node: child.value,\n            sidelines: [][Symbol.iterator](),\n            startsVariation: true,\n            inVariation: false,\n          });\n          frame.inVariation = true;\n        }\n        break;\n      }\n      case MakePgnState.End:\n        stack.pop();\n    }\n  }\n\n  tokens.push(makeOutcome(parseOutcome(game.headers.get('Result'))));\n\n  builder.push(tokens.join(' '), '\\n');\n  return builder.join('');\n};\n\nexport const defaultHeaders = (): Map<string, string> =>\n  new Map([\n    ['Event', '?'],\n    ['Site', '?'],\n    ['Date', '????.??.??'],\n    ['Round', '?'],\n    ['White', '?'],\n    ['Black', '?'],\n    ['Result', '*'],\n  ]);\n\nexport const emptyHeaders = (): Map<string, string> => new Map();\n\nconst BOM = '\\ufeff';\n\nconst isWhitespace = (line: string): boolean => /^\\s*$/.test(line);\n\nconst isCommentLine = (line: string): boolean => line.startsWith('%');\n\nexport interface ParseOptions {\n  stream: boolean;\n}\n\ninterface ParserFrame {\n  parent: Node<PgnNodeData>;\n  root: boolean;\n  node?: ChildNode<PgnNodeData>;\n  startingComments?: string[];\n}\n\nconst enum ParserState {\n  Bom = 0,\n  Pre = 1,\n  Headers = 2,\n  Moves = 3,\n  Comment = 4,\n}\n\nexport class PgnError extends Error {}\n\nexport class PgnParser {\n  private lineBuf: string[] = [];\n\n  private budget: number;\n  private found: boolean;\n  private state: ParserState;\n  private game: Game<PgnNodeData>;\n  private stack: ParserFrame[];\n  private commentBuf: string[];\n\n  constructor(\n    private emitGame: (game: Game<PgnNodeData>, err: PgnError | undefined) => void,\n    private initHeaders: () => Map<string, string> = defaultHeaders,\n    private maxBudget = 1_000_000,\n  ) {\n    this.resetGame();\n    this.state = ParserState.Bom;\n  }\n\n  private resetGame() {\n    this.budget = this.maxBudget;\n    this.found = false;\n    this.state = ParserState.Pre;\n    this.game = defaultGame(this.initHeaders);\n    this.stack = [{ parent: this.game.moves, root: true }];\n    this.commentBuf = [];\n  }\n\n  private consumeBudget(cost: number) {\n    this.budget -= cost;\n    if (this.budget < 0) throw new PgnError('ERR_PGN_BUDGET');\n  }\n\n  parse(data: string, options?: ParseOptions): void {\n    if (this.budget < 0) return;\n    try {\n      let idx = 0;\n      for (;;) {\n        const nlIdx = data.indexOf('\\n', idx);\n        if (nlIdx === -1) {\n          break;\n        }\n        const crIdx = nlIdx > idx && data[nlIdx - 1] === '\\r' ? nlIdx - 1 : nlIdx;\n        this.consumeBudget(nlIdx - idx);\n        this.lineBuf.push(data.slice(idx, crIdx));\n        idx = nlIdx + 1;\n        this.handleLine();\n      }\n      this.consumeBudget(data.length - idx);\n      this.lineBuf.push(data.slice(idx));\n\n      if (!options?.stream) {\n        this.handleLine();\n        this.emit(undefined);\n      }\n    } catch (err: unknown) {\n      this.emit(err as PgnError);\n    }\n  }\n\n  private handleLine() {\n    let freshLine = true;\n    let line = this.lineBuf.join('');\n    this.lineBuf = [];\n\n    continuedLine: for (;;) {\n      switch (this.state) {\n        case ParserState.Bom:\n          if (line.startsWith(BOM)) line = line.slice(BOM.length);\n          this.state = ParserState.Pre; // fall through\n        case ParserState.Pre:\n          if (isWhitespace(line) || isCommentLine(line)) return;\n          this.found = true;\n          this.state = ParserState.Headers; // fall through\n        case ParserState.Headers: {\n          if (isCommentLine(line)) return;\n          let moreHeaders = true;\n          while (moreHeaders) {\n            moreHeaders = false;\n            line = line.replace(\n              /^\\s*\\[([A-Za-z0-9][A-Za-z0-9_+#=:-]*)\\s+\"((?:[^\"\\\\]|\\\\\"|\\\\\\\\)*)\"\\]/,\n              (_match, headerName, headerValue) => {\n                this.consumeBudget(200);\n                this.handleHeader(headerName, headerValue.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\'));\n                moreHeaders = true;\n                freshLine = false;\n                return '';\n              },\n            );\n          }\n          if (isWhitespace(line)) return;\n          this.state = ParserState.Moves; // fall through\n        }\n        case ParserState.Moves: {\n          if (freshLine) {\n            if (isCommentLine(line)) return;\n            if (isWhitespace(line)) return this.emit(undefined);\n          }\n          const tokenRegex =\n            /(?:[NBKRQ]?[a-h]?[1-8]?[-x]?[a-h][1-8](?:=?[nbrqkNBRQK])?|[pnbrqkPNBRQK]?@[a-h][1-8]|[O0o][-][O0o](?:[-][O0o])?)[+#]?|--|Z0|0000|@@@@|{|;|\\$\\d{1,4}|[?!]{1,2}|\\(|\\)|\\*|1[-]0|0[-]1|1\\/2[-]1\\/2/g;\n          let match;\n          while ((match = tokenRegex.exec(line))) {\n            const frame = this.stack[this.stack.length - 1];\n            let token = match[0];\n            if (token === ';') return;\n            else if (token.startsWith('$')) this.handleNag(parseInt(token.slice(1), 10));\n            else if (token === '!') this.handleNag(1);\n            else if (token === '?') this.handleNag(2);\n            else if (token === '!!') this.handleNag(3);\n            else if (token === '??') this.handleNag(4);\n            else if (token === '!?') this.handleNag(5);\n            else if (token === '?!') this.handleNag(6);\n            else if (\n              token === '1-0' || token === '10' || token === '10'\n              || token === '0-1' || token === '01' || token === '01'\n              || token === '1/2-1/2' || token === '1/21/2' || token === '1/21/2'\n              || token === '*'\n            ) {\n              if (this.stack.length === 1 && token !== '*') this.handleHeader('Result', token);\n            } else if (token === '(') {\n              this.consumeBudget(100);\n              this.stack.push({ parent: frame.parent, root: false });\n            } else if (token === ')') {\n              if (this.stack.length > 1) this.stack.pop();\n            } else if (token === '{') {\n              const openIndex = tokenRegex.lastIndex;\n              const beginIndex = line[openIndex] === ' ' ? openIndex + 1 : openIndex;\n              line = line.slice(beginIndex);\n              this.state = ParserState.Comment;\n              continue continuedLine;\n            } else {\n              this.consumeBudget(100);\n              if (token.startsWith('O') || token.startsWith('0') || token.startsWith('o')) {\n                token = token.replace(/[0o]/g, 'O').replace(/[]/g, '-');\n              } else if (token === 'Z0' || token === '0000' || token === '@@@@') token = '--';\n\n              if (frame.node) frame.parent = frame.node;\n              frame.node = new ChildNode({\n                san: token,\n                startingComments: frame.startingComments,\n              });\n              frame.startingComments = undefined;\n              frame.root = false;\n              frame.parent.children.push(frame.node);\n            }\n          }\n          return;\n        }\n        case ParserState.Comment: {\n          const closeIndex = line.indexOf('}');\n          if (closeIndex === -1) {\n            this.commentBuf.push(line);\n            return;\n          } else {\n            const endIndex = closeIndex > 0 && line[closeIndex - 1] === ' ' ? closeIndex - 1 : closeIndex;\n            this.commentBuf.push(line.slice(0, endIndex));\n            this.handleComment();\n            line = line.slice(closeIndex);\n            this.state = ParserState.Moves;\n            freshLine = false;\n          }\n        }\n      }\n    }\n  }\n\n  private handleHeader(name: string, value: string) {\n    this.game.headers.set(name, name === 'Result' ? makeOutcome(parseOutcome(value)) : value);\n  }\n\n  private handleNag(nag: number) {\n    this.consumeBudget(50);\n    const frame = this.stack[this.stack.length - 1];\n    if (frame.node) {\n      frame.node.data.nags ||= [];\n      frame.node.data.nags.push(nag);\n    }\n  }\n\n  private handleComment() {\n    this.consumeBudget(100);\n    const frame = this.stack[this.stack.length - 1];\n    const comment = this.commentBuf.join('\\n');\n    this.commentBuf = [];\n    if (frame.node) {\n      frame.node.data.comments ||= [];\n      frame.node.data.comments.push(comment);\n    } else if (frame.root) {\n      this.game.comments ||= [];\n      this.game.comments.push(comment);\n    } else {\n      frame.startingComments ||= [];\n      frame.startingComments.push(comment);\n    }\n  }\n\n  private emit(err: PgnError | undefined) {\n    if (this.state === ParserState.Comment) this.handleComment();\n    if (err) return this.emitGame(this.game, err);\n    if (this.found) this.emitGame(this.game, undefined);\n    this.resetGame();\n  }\n}\n\nexport const parsePgn = (pgn: string, initHeaders: () => Map<string, string> = defaultHeaders): Game<PgnNodeData>[] => {\n  const games: Game<PgnNodeData>[] = [];\n  new PgnParser(game => games.push(game), initHeaders, NaN).parse(pgn);\n  return games;\n};\n\nexport const parseVariant = (variant: string | undefined): Rules | undefined => {\n  switch ((variant || 'chess').toLowerCase()) {\n    case 'chess':\n    case 'chess960':\n    case 'chess 960':\n    case 'standard':\n    case 'from position':\n    case 'classical':\n    case 'normal':\n    case 'fischerandom': // Cute Chess\n    case 'fischerrandom':\n    case 'fischer random':\n    case 'wild/0':\n    case 'wild/1':\n    case 'wild/2':\n    case 'wild/3':\n    case 'wild/4':\n    case 'wild/5':\n    case 'wild/6':\n    case 'wild/7':\n    case 'wild/8':\n    case 'wild/8a':\n      return 'chess';\n    case 'crazyhouse':\n    case 'crazy house':\n    case 'house':\n    case 'zh':\n      return 'crazyhouse';\n    case 'king of the hill':\n    case 'koth':\n    case 'kingofthehill':\n      return 'kingofthehill';\n    case 'three-check':\n    case 'three check':\n    case 'threecheck':\n    case 'three check chess':\n    case '3-check':\n    case '3 check':\n    case '3check':\n      return '3check';\n    case 'antichess':\n    case 'anti chess':\n    case 'anti':\n      return 'antichess';\n    case 'atomic':\n    case 'atom':\n    case 'atomic chess':\n      return 'atomic';\n    case 'horde':\n    case 'horde chess':\n      return 'horde';\n    case 'racing kings':\n    case 'racingkings':\n    case 'racing':\n    case 'race':\n      return 'racingkings';\n    default:\n      return;\n  }\n};\n\nexport const makeVariant = (rules: Rules): string | undefined => {\n  switch (rules) {\n    case 'chess':\n      return;\n    case 'crazyhouse':\n      return 'Crazyhouse';\n    case 'racingkings':\n      return 'Racing Kings';\n    case 'horde':\n      return 'Horde';\n    case 'atomic':\n      return 'Atomic';\n    case 'antichess':\n      return 'Antichess';\n    case '3check':\n      return 'Three-check';\n    case 'kingofthehill':\n      return 'King of the Hill';\n  }\n};\n\nexport const startingPosition = (headers: Map<string, string>): Result<Position, FenError | PositionError> => {\n  const rules = parseVariant(headers.get('Variant'));\n  if (!rules) return Result.err(new PositionError(IllegalSetup.Variant));\n  const fen = headers.get('FEN');\n  if (fen) return parseFen(fen).chain(setup => setupPosition(rules, setup));\n  else return Result.ok(defaultPosition(rules));\n};\n\nexport const setStartingPosition = (headers: Map<string, string>, pos: Position) => {\n  const variant = makeVariant(pos.rules);\n  if (variant) headers.set('Variant', variant);\n  else headers.delete('Variant');\n\n  const fen = makeFen(pos.toSetup());\n  const defaultFen = makeFen(defaultPosition(pos.rules).toSetup());\n  if (fen !== defaultFen) headers.set('FEN', fen);\n  else headers.delete('FEN');\n};\n\nexport type CommentShapeColor = 'green' | 'red' | 'yellow' | 'blue';\n\nexport interface CommentShape {\n  color: CommentShapeColor;\n  from: Square;\n  to: Square;\n}\n\nexport type EvaluationPawns = { pawns: number; depth?: number };\nexport type EvaluationMate = { mate: number; depth?: number };\nexport type Evaluation = EvaluationPawns | EvaluationMate;\n\nexport const isPawns = (ev: Evaluation): ev is EvaluationPawns => 'pawns' in ev;\nexport const isMate = (ev: Evaluation): ev is EvaluationMate => 'mate' in ev;\n\nexport interface Comment {\n  text: string;\n  shapes: CommentShape[];\n  clock?: number;\n  emt?: number;\n  evaluation?: Evaluation;\n}\n\nconst makeClk = (seconds: number): string => {\n  seconds = Math.max(0, seconds);\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  seconds = (seconds % 3600) % 60;\n  return `${hours}:${minutes.toString().padStart(2, '0')}:${\n    seconds.toLocaleString('en', {\n      minimumIntegerDigits: 2,\n      maximumFractionDigits: 3,\n    })\n  }`;\n};\n\nconst makeCommentShapeColor = (color: CommentShapeColor): 'G' | 'R' | 'Y' | 'B' => {\n  switch (color) {\n    case 'green':\n      return 'G';\n    case 'red':\n      return 'R';\n    case 'yellow':\n      return 'Y';\n    case 'blue':\n      return 'B';\n  }\n};\n\nfunction parseCommentShapeColor(str: 'G' | 'R' | 'Y' | 'B'): CommentShapeColor;\nfunction parseCommentShapeColor(str: string): CommentShapeColor | undefined;\nfunction parseCommentShapeColor(str: string): CommentShapeColor | undefined {\n  switch (str) {\n    case 'G':\n      return 'green';\n    case 'R':\n      return 'red';\n    case 'Y':\n      return 'yellow';\n    case 'B':\n      return 'blue';\n    default:\n      return;\n  }\n}\n\nconst makeCommentShape = (shape: CommentShape): string =>\n  shape.to === shape.from\n    ? `${makeCommentShapeColor(shape.color)}${makeSquare(shape.to)}`\n    : `${makeCommentShapeColor(shape.color)}${makeSquare(shape.from)}${makeSquare(shape.to)}`;\n\nconst parseCommentShape = (str: string): CommentShape | undefined => {\n  const color = parseCommentShapeColor(str.slice(0, 1));\n  const from = parseSquare(str.slice(1, 3));\n  const to = parseSquare(str.slice(3, 5));\n  if (!color || !defined(from)) return;\n  if (str.length === 3) return { color, from, to: from };\n  if (str.length === 5 && defined(to)) return { color, from, to };\n  return;\n};\n\nconst makeEval = (ev: Evaluation): string => {\n  const str = isMate(ev) ? '#' + ev.mate : ev.pawns.toFixed(2);\n  return defined(ev.depth) ? str + ',' + ev.depth : str;\n};\n\nexport const makeComment = (comment: Partial<Comment>): string => {\n  const builder = [];\n  if (defined(comment.text)) builder.push(comment.text);\n  const circles = (comment.shapes || []).filter(shape => shape.to === shape.from).map(makeCommentShape);\n  if (circles.length) builder.push(`[%csl ${circles.join(',')}]`);\n  const arrows = (comment.shapes || []).filter(shape => shape.to !== shape.from).map(makeCommentShape);\n  if (arrows.length) builder.push(`[%cal ${arrows.join(',')}]`);\n  if (comment.evaluation) builder.push(`[%eval ${makeEval(comment.evaluation)}]`);\n  if (defined(comment.emt)) builder.push(`[%emt ${makeClk(comment.emt)}]`);\n  if (defined(comment.clock)) builder.push(`[%clk ${makeClk(comment.clock)}]`);\n  return builder.join(' ');\n};\n\nexport const parseComment = (comment: string): Comment => {\n  let emt, clock, evaluation;\n  const shapes: CommentShape[] = [];\n  const text = comment\n    .replace(\n      /\\s?\\[%(emt|clk)\\s(\\d{1,5}):(\\d{1,2}):(\\d{1,2}(?:\\.\\d{0,3})?)\\]\\s?/g,\n      (_, annotation, hours, minutes, seconds) => {\n        const value = parseInt(hours, 10) * 3600 + parseInt(minutes, 10) * 60 + parseFloat(seconds);\n        if (annotation === 'emt') emt = value;\n        else if (annotation === 'clk') clock = value;\n        return '  ';\n      },\n    )\n    .replace(\n      /\\s?\\[%(?:csl|cal)\\s([RGYB][a-h][1-8](?:[a-h][1-8])?(?:,[RGYB][a-h][1-8](?:[a-h][1-8])?)*)\\]\\s?/g,\n      (_, arrows) => {\n        for (const arrow of arrows.split(',')) {\n          shapes.push(parseCommentShape(arrow)!);\n        }\n        return '  ';\n      },\n    )\n    .replace(\n      /\\s?\\[%eval\\s(?:#([+-]?\\d{1,5})|([+-]?(?:\\d{1,5}|\\d{0,5}\\.\\d{1,2})))(?:,(\\d{1,5}))?\\]\\s?/g,\n      (_, mate, pawns, d) => {\n        const depth = d && parseInt(d, 10);\n        evaluation = mate ? { mate: parseInt(mate, 10), depth } : { pawns: parseFloat(pawns), depth };\n        return '  ';\n      },\n    )\n    .trim();\n  return {\n    text,\n    shapes,\n    emt,\n    clock,\n    evaluation,\n  };\n};\n", "import { attacks, bishopAttacks, kingAttacks, knightAttacks, queenAttacks, rookAttacks } from './attacks.js';\nimport { Position } from './chess.js';\nimport { SquareSet } from './squareSet.js';\nimport { CastlingSide, FILE_NAMES, isDrop, Move, RANK_NAMES, SquareName } from './types.js';\nimport { charToRole, defined, makeSquare, opposite, parseSquare, roleToChar, squareFile, squareRank } from './util.js';\n\nconst makeSanWithoutSuffix = (pos: Position, move: Move): string => {\n  let san = '';\n  if (isDrop(move)) {\n    if (move.role !== 'pawn') san = roleToChar(move.role).toUpperCase();\n    san += '@' + makeSquare(move.to);\n  } else {\n    const role = pos.board.getRole(move.from);\n    if (!role) return '--';\n    if (role === 'king' && (pos.board[pos.turn].has(move.to) || Math.abs(move.to - move.from) === 2)) {\n      san = move.to > move.from ? 'O-O' : 'O-O-O';\n    } else {\n      const capture = pos.board.occupied.has(move.to)\n        || (role === 'pawn' && squareFile(move.from) !== squareFile(move.to));\n      if (role !== 'pawn') {\n        san = roleToChar(role).toUpperCase();\n\n        // Disambiguation\n        let others;\n        if (role === 'king') others = kingAttacks(move.to).intersect(pos.board.king);\n        else if (role === 'queen') others = queenAttacks(move.to, pos.board.occupied).intersect(pos.board.queen);\n        else if (role === 'rook') others = rookAttacks(move.to, pos.board.occupied).intersect(pos.board.rook);\n        else if (role === 'bishop') others = bishopAttacks(move.to, pos.board.occupied).intersect(pos.board.bishop);\n        else others = knightAttacks(move.to).intersect(pos.board.knight);\n        others = others.intersect(pos.board[pos.turn]).without(move.from);\n        if (others.nonEmpty()) {\n          const ctx = pos.ctx();\n          for (const from of others) {\n            if (!pos.dests(from, ctx).has(move.to)) others = others.without(from);\n          }\n          if (others.nonEmpty()) {\n            let row = false;\n            let column = others.intersects(SquareSet.fromRank(squareRank(move.from)));\n            if (others.intersects(SquareSet.fromFile(squareFile(move.from)))) row = true;\n            else column = true;\n            if (column) san += FILE_NAMES[squareFile(move.from)];\n            if (row) san += RANK_NAMES[squareRank(move.from)];\n          }\n        }\n      } else if (capture) san = FILE_NAMES[squareFile(move.from)];\n\n      if (capture) san += 'x';\n      san += makeSquare(move.to);\n      if (move.promotion) san += '=' + roleToChar(move.promotion).toUpperCase();\n    }\n  }\n  return san;\n};\n\nexport const makeSanAndPlay = (pos: Position, move: Move): string => {\n  const san = makeSanWithoutSuffix(pos, move);\n  pos.play(move);\n  if (pos.outcome()?.winner) return san + '#';\n  if (pos.isCheck()) return san + '+';\n  return san;\n};\n\nexport const makeSanVariation = (pos: Position, variation: Move[]): string => {\n  pos = pos.clone();\n  const line = [];\n  for (let i = 0; i < variation.length; i++) {\n    if (i !== 0) line.push(' ');\n    if (pos.turn === 'white') line.push(pos.fullmoves, '. ');\n    else if (i === 0) line.push(pos.fullmoves, '... ');\n    const san = makeSanWithoutSuffix(pos, variation[i]);\n    pos.play(variation[i]);\n    line.push(san);\n    if (san === '--') return line.join('');\n    if (i === variation.length - 1 && pos.outcome()?.winner) line.push('#');\n    else if (pos.isCheck()) line.push('+');\n  }\n  return line.join('');\n};\n\nexport const makeSan = (pos: Position, move: Move): string => makeSanAndPlay(pos.clone(), move);\n\nexport const parseSan = (pos: Position, san: string): Move | undefined => {\n  const ctx = pos.ctx();\n\n  // Normal move\n  const match = san.match(/^([NBRQK])?([a-h])?([1-8])?[-x]?([a-h][1-8])(?:=?([nbrqkNBRQK]))?[+#]?$/) as\n    | [\n      string,\n      'N' | 'B' | 'R' | 'Q' | 'K' | undefined,\n      string | undefined,\n      string | undefined,\n      SquareName,\n      'n' | 'b' | 'r' | 'q' | 'k' | 'N' | 'B' | 'R' | 'Q' | 'K' | undefined,\n    ]\n    | null;\n  if (!match) {\n    // Castling\n    let castlingSide: CastlingSide | undefined;\n    if (san === 'O-O' || san === 'O-O+' || san === 'O-O#') castlingSide = 'h';\n    else if (san === 'O-O-O' || san === 'O-O-O+' || san === 'O-O-O#') castlingSide = 'a';\n    if (castlingSide) {\n      const rook = pos.castles.rook[pos.turn][castlingSide];\n      if (!defined(ctx.king) || !defined(rook) || !pos.dests(ctx.king, ctx).has(rook)) return;\n      return {\n        from: ctx.king,\n        to: rook,\n      };\n    }\n\n    // Drop\n    const match = san.match(/^([pnbrqkPNBRQK])?@([a-h][1-8])[+#]?$/) as\n      | [string, 'p' | 'n' | 'b' | 'r' | 'q' | 'k' | 'P' | 'N' | 'B' | 'R' | 'Q' | 'K' | undefined, SquareName]\n      | null;\n    if (!match) return;\n    const move = {\n      role: match[1] ? charToRole(match[1]) : 'pawn',\n      to: parseSquare(match[2]),\n    };\n    return pos.isLegal(move, ctx) ? move : undefined;\n  }\n  const role = match[1] ? charToRole(match[1]) : 'pawn';\n  const to = parseSquare(match[4]);\n\n  const promotion = match[5] ? charToRole(match[5]) : undefined;\n  if (!!promotion !== (role === 'pawn' && SquareSet.backranks().has(to))) return;\n  if (promotion === 'king' && pos.rules !== 'antichess') return;\n\n  let candidates = pos.board.pieces(pos.turn, role);\n  if (role === 'pawn' && !match[2]) candidates = candidates.intersect(SquareSet.fromFile(squareFile(to)));\n  else if (match[2]) candidates = candidates.intersect(SquareSet.fromFile(match[2].charCodeAt(0) - 'a'.charCodeAt(0)));\n  if (match[3]) candidates = candidates.intersect(SquareSet.fromRank(match[3].charCodeAt(0) - '1'.charCodeAt(0)));\n\n  // Optimization: Reduce set of candidates\n  const pawnAdvance = role === 'pawn' ? SquareSet.fromFile(squareFile(to)) : SquareSet.empty();\n  candidates = candidates.intersect(\n    pawnAdvance.union(attacks({ color: opposite(pos.turn), role }, to, pos.board.occupied)),\n  );\n\n  // Check uniqueness and legality\n  let from;\n  for (const candidate of candidates) {\n    if (pos.dests(candidate, ctx).has(to)) {\n      if (defined(from)) return; // Ambiguous\n      from = candidate;\n    }\n  }\n  if (!defined(from)) return; // Illegal\n\n  return {\n    from,\n    to,\n    promotion,\n  };\n};\n", "import { defaultGame, startingPosition } from \"chessops/pgn\";\nimport { parseSan } from \"chessops/san\";\nimport { makeUci } from \"chessops/util\";\n\nnamespace LichessOpeningExplorer {\n  const CACHE_NAME = \"lichess-cache\";\n\n  interface Moves {\n    uci: string;\n    san: string;\n    averageRating: number;\n    white: number;\n    draws: number;\n    black: number;\n    game: string | null;\n    opening: {\n      eco: string;\n      name: string;\n    } | null;\n  }\n\n  interface Games {\n    uci: string;\n    id: string;\n    winner: string | null;\n    black: {\n      name: string;\n      rating: number;\n    };\n    white: {\n      name: string;\n      rating: number;\n    };\n    year: number;\n    month: string;\n  }\n\n  interface ChessDBResult {\n    white: number;\n    draws: number;\n    black: number;\n    moves: Array<Moves>;\n    topGames: Array<Games>;\n    opening: {\n      eco: string;\n      name: string | null;\n    };\n  }\n\n  const getLichessGame = (): string[] => {\n    console.info(\"=== LICHESS GAME EXTRACTOR ===\\n\");\n\n    // Find the move list container\n    const moveContainer = document.querySelector(\"rm6, l4x\");\n    if (!moveContainer) {\n      return [];\n    }\n\n    // Extract all moves in Standard Algebraic Notation (SAN)\n    const moveElements = moveContainer.querySelectorAll(\"kwdb\");\n    // Use chessops library to parse moves\n    const game = defaultGame();\n    const pos = startingPosition(game.headers).unwrap();\n    const uciMoves: string[] = [];\n\n    for (const moveEl of moveElements) {\n      const move = moveEl.textContent?.trim();\n      if (move) {\n        const chessMove = parseSan(pos, move);\n        if (!chessMove) {\n          console.warn(`Illegal move detected: \"${move}\"`);\n          break;\n        }\n        uciMoves.push(makeUci(chessMove));\n        pos.play(chessMove);\n      }\n    }\n\n    console.info(\"Moves found:\", pos.fullmoves);\n    return uciMoves;\n  };\n\n  const fetchWithCache = async (url: string) => {\n    try {\n      const cache = await caches.open(CACHE_NAME);\n      const cachedResponse = await cache.match(url);\n\n      // Return cached response if it exists (no expiration check)\n      if (cachedResponse) {\n        console.log(\"Cache hit:\", url);\n        return cachedResponse;\n      }\n\n      // Cache miss - fetch fresh data using GM.xmlHttpRequest\n      console.log(\"Cache miss, fetching:\", url);\n      const response = await GM.xmlHttpRequest({\n        method: \"GET\",\n        url: url,\n        responseType: \"json\",\n      });\n\n      // Store as JSON string in cache\n      const status = response.responseText === \"bad request: illegal uci\" ? 400 : 200;\n      const statusText = status === 200 ? \"OK\" : \"Bad Request\";\n      const cacheableResponse = new Response(response.responseText, {\n        status,\n        statusText,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n\n      await cache.put(url, cacheableResponse);\n\n      // Return the cached response\n      return await cache.match(url);\n    } catch (error) {\n      console.error(\"Fetch error:\", error);\n      throw error;\n    }\n  };\n\n  const updateMoveDisplay = (move: string | null) => {\n    // Create a new container and place it into the grid\n    let container = document.getElementById(\"lichess-top-move\");\n    if (!container) {\n      container = document.createElement(\"div\");\n      container.id = \"lichess-top-move\";\n      container.style.marginTop = \"8px\";\n      container.style.display = \"flex\";\n      container.style.justifyContent = \"center\";\n      container.style.fontSize = \"14px\";\n      container.style.fontWeight = \"bold\";\n      container.style.flexFlow = \"row nowrap\";\n      container.style.alignItems = \"center\";\n      container.style.gridArea = \"voice\";\n      document.body.prepend(container);\n    }\n\n    container.textContent = move ? `Top Move: ${move}` : \"\";\n  };\n\n  export const main = async () => {\n    console.info(\"Lichess Opening Explorer script loaded.\");\n    // Watch for mutations to detect when a move has been made\n    const targetNode = document.body;\n    const config = { childList: true, subtree: true };\n\n    const callback: MutationCallback = async (\n      mutationsList,\n      internalObserver,\n    ) => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === \"childList\") {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement && node.matches(\"rm6, l4x, kwdb\")) {\n              console.info(\"Move list updated, extracting position...\");\n              const result = getLichessGame();\n              if (result.length > 0) {\n                const url = `https://explorer.lichess.ovh/masters?since=2008&play=${result.join(\",\")}`;\n                const data = await fetchWithCache(url);\n                if (data?.ok) {\n                  const chessDBResult = (await data.json()) as ChessDBResult;\n                  if (chessDBResult.moves.length === 0) {\n                    console.info(\n                      \"No moves found in database for this position.\",\n                    );\n                    updateMoveDisplay(null);\n                    internalObserver.disconnect();\n                    return;\n                  }\n                  updateMoveDisplay(chessDBResult.moves[0].uci);\n                  console.info(\"Top Move:\", chessDBResult.moves[0].uci);\n                } else {\n                  console.warn(\"Failed to fetch data from Lichess Opening Explorer.\");\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    const observer = new MutationObserver(callback);\n    observer.observe(targetNode, config);\n\n    // Initial extraction\n    const initialResult = getLichessGame();\n    if (initialResult.length > 0) {\n      const url = `https://explorer.lichess.ovh/masters?since=2008&play=${initialResult.join(\",\")}`;\n      const data = await fetchWithCache(url);\n      if (data) {\n        const chessDBResult = (await data.json()) as ChessDBResult;\n        if (chessDBResult.moves.length > 0) {\n          updateMoveDisplay(chessDBResult.moves[0].uci);\n          console.info(\"Top Move:\", chessDBResult.moves[0].uci);\n        }\n      }\n    }\n  };\n}\n\nLichessOpeningExplorer.main();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAe,UAAf,MAAsB;IAUpB,OAAO,IAA4B,KAA2B;AAC5D,YAAM,IAAI,KAAK,OACb,CAAC,UAAU,OAAO,GAAG,KAAK,GAAG,KAAK,IAAI,KAAK,GAC3C,CAAC,UAAW,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,IAAI,OAAO,IAAI,KAAK,CAAE;AAE9D,UAAI,EAAE,OAAO;AACX,cAAM,EAAE;MACV;AACA,aAAO,EAAE;IACX;IAOA,IAAI,IAA2B,KAAyB;AACtD,aAAO,KAAK,OACV,CAAC,UAAU,OAAO,GAAG,GAAG,KAAK,CAAC,GAC9B,CAAC,UAAU,OAAO,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC;IAEnD;IAWA,MACE,IACA,KAAmC;AAEnC,aAAO,KAAK,OAAO,IAAI,QAAG,QAAH,QAAG,SAAH,MAAQ,CAAC,UAAU,OAAO,IAAI,KAAK,CAAE;IAC9D;;AAGF,MAAM,MAAN,cAAsC,QAAa;IAGjD,YAAqB,OAAQ;AAC3B,YAAK;AADc,WAAA,QAAA;AAFZ,WAAA,OAAO;AACP,WAAA,QAAQ;IAGjB;IAEU,OACR,IACA,MAAgC;AAEhC,aAAO,GAAG,KAAK,KAAK;IACtB;;AAGF,MAAM,OAAN,cAAuC,QAAa;IAGlD,YAAqB,OAAQ;AAC3B,YAAK;AADc,WAAA,QAAA;AAFZ,WAAA,OAAO;AACP,WAAA,QAAQ;IAGjB;IAEU,OACR,KACA,KAA+B;AAE/B,aAAO,IAAI,KAAK,KAAK;IACvB;;AAGI,MAAW;AAAjB,GAAA,SAAiBA,SAAM;AAIrB,aAAgB,GAAuB,OAAQ;AAC7C,aAAO,IAAI,IAAI,KAAK;IACtB;AAFgB,IAAAA,QAAA,KAAE;AAIlB,aAAgB,IAAgC,OAAQ;AACtD,aAAO,IAAI,KAAK,SAAS,IAAI,MAAK,CAAE;IACtC;AAFgB,IAAAA,QAAA,MAAG;AA+YnB,aAAgB,IAAI,KAA4B;AAC9C,UAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,cAAMC,OAAM,CAAA;AACZ,iBAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,gBAAM,OAAO,IAAI,CAAC;AAClB,cAAI,KAAK,OAAO;AACd,mBAAO;UACT;AACA,UAAAA,KAAI,KAAK,KAAK,KAAK;QACrB;AACA,eAAOD,QAAO,GAAGC,IAAG;MACtB;AAEA,YAAM,MAA+B,CAAA;AACrC,YAAM,OAAO,OAAO,KAAK,GAAG;AAC5B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,cAAM,OAAO,IAAI,KAAK,CAAC,CAAC;AACxB,YAAI,KAAK,OAAO;AACd,iBAAO;QACT;AACA,YAAI,KAAK,CAAC,CAAC,IAAI,KAAK;MACtB;AACA,aAAOD,QAAO,GAAG,GAAG;IACtB;AAvBgB,IAAAA,QAAA,MAAG;EAwBrB,GA/aiB,WAAA,SAAM,CAAA,EAAA;;;AC9EvB,MAAM,WAAW,CAAC,MAAqB;AACrC,QAAI,KAAM,MAAM,IAAK;AACrB,SAAK,IAAI,cAAiB,MAAM,IAAK;AACrC,WAAO,KAAK,KAAM,KAAK,MAAM,KAAM,WAAa,QAAW,KAAK;EAClE;AAEA,MAAM,UAAU,CAAC,MAAqB;AACpC,QAAM,MAAM,IAAK,YAAiB,IAAI,aAAgB;AACtD,WAAS,MAAM,KAAM,SAAY,IAAI,UAAW;EAClD;AAEA,MAAM,SAAS,CAAC,MAAqB;AACnC,QAAM,MAAM,IAAK,cAAiB,IAAI,eAAgB;AACtD,QAAM,MAAM,IAAK,aAAiB,IAAI,cAAgB;AACtD,QAAM,MAAM,IAAK,aAAiB,IAAI,cAAgB;AACtD,WAAO,QAAQ,CAAC;EAClB;AAKM,MAAO,YAAP,MAAO,WAAS;IAIpB,YAAY,IAAY,IAAU;AAChC,WAAK,KAAK,KAAK;AACf,WAAK,KAAK,KAAK;IACjB;IAEA,OAAO,WAAW,QAAc;AAC9B,aAAO,UAAU,KAAK,IAAI,WAAU,GAAG,KAAM,SAAS,EAAG,IAAI,IAAI,WAAU,KAAK,QAAQ,CAAC;IAC3F;IAEA,OAAO,SAAS,MAAY;AAC1B,aAAO,IAAI,WAAU,KAAM,CAAC,EAAE,MAAM,IAAI,IAAI;IAC9C;IAEA,OAAO,SAAS,MAAY;AAC1B,aAAO,IAAI,WAAU,YAAe,MAAM,YAAe,IAAI;IAC/D;IAEA,OAAO,QAAK;AACV,aAAO,IAAI,WAAU,GAAG,CAAC;IAC3B;IAEA,OAAO,OAAI;AACT,aAAO,IAAI,WAAU,YAAa,UAAW;IAC/C;IAEA,OAAO,UAAO;AACZ,aAAO,IAAI,WAAU,KAAM,UAAW;IACxC;IAEA,OAAO,SAAM;AACX,aAAO,IAAI,WAAU,WAAa,EAAI;IACxC;IAEA,OAAO,YAAS;AACd,aAAO,IAAI,WAAU,KAAM,UAAW;IACxC;IAEA,OAAO,SAAS,OAAY;AAC1B,aAAO,UAAU,UAAU,IAAI,WAAU,KAAM,CAAC,IAAI,IAAI,WAAU,GAAG,UAAW;IAClF;IAEA,OAAO,eAAY;AACjB,aAAO,IAAI,WAAU,YAAa,UAAW;IAC/C;IAEA,OAAO,cAAW;AAChB,aAAO,IAAI,WAAU,YAAa,UAAW;IAC/C;IAEA,aAAU;AACR,aAAO,IAAI,WAAU,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;IACzC;IAEA,IAAI,OAAgB;AAClB,aAAO,IAAI,WAAU,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,EAAE;IAC7D;IAEA,MAAM,OAAgB;AACpB,aAAO,IAAI,WAAU,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,EAAE;IAC7D;IAEA,UAAU,OAAgB;AACxB,aAAO,IAAI,WAAU,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,EAAE;IAC7D;IAEA,KAAK,OAAgB;AACnB,aAAO,IAAI,WAAU,KAAK,KAAK,CAAC,MAAM,IAAI,KAAK,KAAK,CAAC,MAAM,EAAE;IAC/D;IAEA,WAAW,OAAgB;AACzB,aAAO,KAAK,UAAU,KAAK,EAAE,SAAQ;IACvC;IAEA,WAAW,OAAgB;AACzB,aAAO,KAAK,UAAU,KAAK,EAAE,QAAO;IACtC;IAEA,WAAW,OAAgB;AACzB,aAAO,MAAM,KAAK,IAAI,EAAE,QAAO;IACjC;IAEA,SAAS,OAAgB;AACvB,aAAO,KAAK,KAAK,KAAK,EAAE,QAAO;IACjC;IAEA,MAAM,OAAa;AACjB,UAAI,SAAS;AAAI,eAAO,WAAU,MAAK;AACvC,UAAI,SAAS;AAAI,eAAO,IAAI,WAAU,KAAK,OAAQ,QAAQ,IAAK,CAAC;AACjE,UAAI,QAAQ;AAAG,eAAO,IAAI,WAAW,KAAK,OAAO,QAAU,KAAK,MAAO,KAAK,OAAS,KAAK,OAAO,KAAK;AACtG,aAAO;IACT;IAEA,MAAM,OAAa;AACjB,UAAI,SAAS;AAAI,eAAO,WAAU,MAAK;AACvC,UAAI,SAAS;AAAI,eAAO,IAAI,WAAU,GAAG,KAAK,MAAO,QAAQ,EAAG;AAChE,UAAI,QAAQ;AAAG,eAAO,IAAI,WAAU,KAAK,MAAM,OAAQ,KAAK,MAAM,QAAU,KAAK,OAAQ,KAAK,KAAO;AACrG,aAAO;IACT;IAEA,UAAO;AACL,aAAO,IAAI,WAAU,QAAQ,KAAK,EAAE,GAAG,QAAQ,KAAK,EAAE,CAAC;IACzD;IAEA,SAAM;AACJ,aAAO,IAAI,WAAU,OAAO,KAAK,EAAE,GAAG,OAAO,KAAK,EAAE,CAAC;IACvD;IAEA,QAAQ,OAAgB;AACtB,YAAM,KAAK,KAAK,KAAK,MAAM;AAC3B,YAAM,KAAM,KAAK,MAAM,KAAK,MAAM,MAAM,OAAO,MAAM,OAAO,OAAQ;AACpE,aAAO,IAAI,WAAU,IAAI,KAAK,MAAM,MAAM,KAAK,EAAE;IACnD;IAEA,OAAO,OAAgB;AACrB,aAAO,KAAK,OAAO,MAAM,MAAM,KAAK,OAAO,MAAM;IACnD;IAEA,OAAI;AACF,aAAO,SAAS,KAAK,EAAE,IAAI,SAAS,KAAK,EAAE;IAC7C;IAEA,UAAO;AACL,aAAO,KAAK,OAAO,KAAK,KAAK,OAAO;IACtC;IAEA,WAAQ;AACN,aAAO,KAAK,OAAO,KAAK,KAAK,OAAO;IACtC;IAEA,IAAI,QAAc;AAChB,cAAQ,UAAU,KAAK,KAAK,KAAM,KAAM,SAAS,KAAO,KAAK,KAAM,KAAK,YAAa;IACvF;IAEA,IAAI,QAAgB,IAAW;AAC7B,aAAO,KAAK,KAAK,KAAK,MAAM,IAAI,KAAK,QAAQ,MAAM;IACrD;IAEA,KAAK,QAAc;AACjB,aAAO,UAAU,KACb,IAAI,WAAU,KAAK,IAAI,KAAK,KAAM,KAAM,SAAS,EAAI,IACrD,IAAI,WAAU,KAAK,KAAM,KAAK,QAAS,KAAK,EAAE;IACpD;IAEA,QAAQ,QAAc;AACpB,aAAO,UAAU,KACb,IAAI,WAAU,KAAK,IAAI,KAAK,KAAK,EAAE,KAAM,SAAS,GAAI,IACtD,IAAI,WAAU,KAAK,KAAK,EAAE,KAAK,SAAS,KAAK,EAAE;IACrD;IAEA,OAAO,QAAc;AACnB,aAAO,UAAU,KACb,IAAI,WAAU,KAAK,IAAI,KAAK,KAAM,KAAM,SAAS,EAAI,IACrD,IAAI,WAAU,KAAK,KAAM,KAAK,QAAS,KAAK,EAAE;IACpD;IAEA,OAAI;AACF,UAAI,KAAK,OAAO;AAAG,eAAO,KAAK,KAAK,MAAM,KAAK,EAAE;AACjD,UAAI,KAAK,OAAO;AAAG,eAAO,KAAK,KAAK,MAAM,KAAK,EAAE;AACjD;IACF;IAEA,QAAK;AACH,UAAI,KAAK,OAAO;AAAG,eAAO,KAAK,KAAK,MAAM,KAAK,KAAK,CAAC,KAAK,EAAE;AAC5D,UAAI,KAAK,OAAO;AAAG,eAAO,KAAK,KAAK,MAAM,KAAK,KAAK,CAAC,KAAK,EAAE;AAC5D;IACF;IAEA,eAAY;AACV,UAAI,KAAK,OAAO;AAAG,eAAO,IAAI,WAAU,KAAK,KAAM,KAAK,KAAK,GAAI,KAAK,EAAE;AACxE,aAAO,IAAI,WAAU,GAAG,KAAK,KAAM,KAAK,KAAK,CAAE;IACjD;IAEA,cAAW;AACT,aAAQ,KAAK,OAAO,KAAK,KAAK,OAAO,MAAO,KAAK,KAAM,KAAK,KAAK,OAAQ,MAAM,KAAK,KAAM,KAAK,KAAK,OAAQ;IAC9G;IAEA,eAAY;AACV,aAAO,KAAK,YAAW,IAAK,SAAY,KAAK,KAAI;IACnD;IAEA,EAAE,OAAO,QAAQ,IAAC;AAChB,UAAI,KAAK,KAAK;AACd,UAAI,KAAK,KAAK;AACd,aAAO,OAAO,GAAG;AACf,cAAM,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC,EAAE;AACpC,cAAM,KAAK;AACX,cAAM;MACR;AACA,aAAO,OAAO,GAAG;AACf,cAAM,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC,EAAE;AACpC,cAAM,KAAK;AACX,cAAM,KAAK;MACb;IACF;IAEA,CAAC,WAAQ;AACP,UAAI,KAAK,KAAK;AACd,UAAI,KAAK,KAAK;AACd,aAAO,OAAO,GAAG;AACf,cAAM,MAAM,KAAK,KAAK,MAAM,EAAE;AAC9B,cAAM,KAAK;AACX,cAAM,KAAK;MACb;AACA,aAAO,OAAO,GAAG;AACf,cAAM,MAAM,KAAK,KAAK,MAAM,EAAE;AAC9B,cAAM,KAAK;AACX,cAAM;MACR;IACF;;;;AC3OK,MAAM,aAAa,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;AAI1D,MAAM,aAAa,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;AAiB1D,MAAM,SAAS,CAAC,SAAS,OAAO;AAWhC,MAAM,QAAQ,CAAC,QAAQ,UAAU,UAAU,QAAQ,SAAS,MAAM;AAWlE,MAAM,iBAAiB,CAAC,KAAK,GAAG;AA8BhC,MAAM,SAAS,CAAC,MAA2B,UAAU;;;AC3DrD,MAAM,UAAU,CAAI,MAA6B,MAAM;AAEvD,MAAM,WAAW,CAAC,UAAyB,UAAU,UAAU,UAAU;AAEzE,MAAM,aAAa,CAAC,WAA2B,UAAU;AAEzD,MAAM,aAAa,CAAC,WAA2B,SAAS;AAExD,MAAM,mBAAmB,CAAC,MAAc,SAC7C,KAAK,QAAQ,OAAO,KAAK,KAAK,QAAQ,OAAO,IAAI,OAAO,IAAI,OAAO;AAE9D,MAAM,aAAa,CAAC,SAAwB;AACjD,YAAQ,MAAM;MACZ,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;IACX;EACF;AAIM,WAAU,WAAW,IAAU;AACnC,YAAQ,GAAG,YAAW,GAAI;MACxB,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT;AACE;IACJ;EACF;AAIM,WAAU,YAAY,KAAW;AACrC,QAAI,IAAI,WAAW;AAAG;AACtB,WAAO,iBAAiB,IAAI,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,GAAG,IAAI,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,CAAC;EACtG;AAEO,MAAM,aAAa,CAAC,WACxB,WAAW,WAAW,MAAM,CAAC,IAAI,WAAW,WAAW,MAAM,CAAC;AA8B1D,MAAM,UAAU,CAAC,SACtB,OAAO,IAAI,IACP,GAAG,WAAW,KAAK,IAAI,EAAE,YAAW,CAAE,IAAI,WAAW,KAAK,EAAE,CAAC,KAC7D,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,EAAE,KAAK,KAAK,YAAY,WAAW,KAAK,SAAS,IAAI;AAE5F,MAAM,gBAAgB,CAAC,OAAc,SAC1C,UAAU,UAAW,SAAS,MAAM,IAAI,IAAK,SAAS,MAAM,KAAK;AAE5D,MAAM,gBAAgB,CAAC,OAAc,SAC1C,UAAU,UAAW,SAAS,MAAM,IAAI,IAAK,SAAS,MAAM,KAAK;;;AC5FnE,MAAM,eAAe,CAAC,QAAgB,WAA+B;AACnE,QAAI,QAAQ,UAAU,MAAK;AAC3B,eAAW,SAAS,QAAQ;AAC1B,YAAM,KAAK,SAAS;AACpB,UAAI,KAAK,MAAM,KAAK,MAAM,KAAK,IAAI,WAAW,MAAM,IAAI,WAAW,EAAE,CAAC,KAAK,GAAG;AAC5E,gBAAQ,MAAM,KAAK,EAAE;MACvB;IACF;AACA,WAAO;EACT;AAEA,MAAM,WAAW,CAAI,MAAyC;AAC5D,UAAM,QAAQ,CAAA;AACd,aAAS,SAAS,GAAG,SAAS,IAAI;AAAU,YAAM,MAAM,IAAI,EAAE,MAAM;AACpE,WAAO;EACT;AAEA,MAAM,eAAe,SAAS,QAAM,aAAa,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;AAClF,MAAM,iBAAiB,SAAS,QAAM,aAAa,IAAI,CAAC,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC,CAAC;AAC1F,MAAM,eAAe;IACnB,OAAO,SAAS,QAAM,aAAa,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9C,OAAO,SAAS,QAAM,aAAa,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;;AAM3C,MAAM,cAAc,CAAC,WAA8B,aAAa,MAAM;AAKtE,MAAM,gBAAgB,CAAC,WAA8B,eAAe,MAAM;AAM1E,MAAM,cAAc,CAAC,OAAc,WAA8B,aAAa,KAAK,EAAE,MAAM;AAElG,MAAM,aAAa,SAAS,QAAM,UAAU,SAAS,WAAW,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC;AAChF,MAAM,aAAa,SAAS,QAAM,UAAU,SAAS,WAAW,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC;AAEhF,MAAM,aAAa,SAAS,QAAK;AAC/B,UAAM,OAAO,IAAI,UAAU,WAAa,UAAW;AACnD,UAAM,QAAQ,KAAK,WAAW,EAAE,IAAI,WAAW,EAAE;AACjD,YAAQ,SAAS,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,CAAC,KAAK,GAAG,QAAQ,EAAE;EACzE,CAAC;AAED,MAAM,kBAAkB,SAAS,QAAK;AACpC,UAAM,OAAO,IAAI,UAAU,WAAa,QAAW;AACnD,UAAM,QAAQ,KAAK,WAAW,EAAE,IAAI,WAAW,EAAE,IAAI;AACrD,YAAQ,SAAS,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,CAAC,KAAK,GAAG,QAAQ,EAAE;EACzE,CAAC;AAED,MAAM,YAAY,CAAC,KAAgB,OAAkB,aAAkC;AACrF,QAAI,UAAU,SAAS,UAAU,KAAK;AACtC,QAAI,UAAU,QAAQ,QAAO;AAC7B,cAAU,QAAQ,QAAQ,GAAG;AAC7B,cAAU,QAAQ,QAAQ,IAAI,QAAO,CAAE;AACvC,WAAO,QAAQ,IAAI,QAAQ,QAAO,CAAE,EAAE,UAAU,KAAK;EACvD;AAEA,MAAM,cAAc,CAAC,QAAgB,aACnC,UAAU,UAAU,WAAW,MAAM,GAAG,WAAW,MAAM,GAAG,QAAQ;AAEtE,MAAM,cAAc,CAAC,QAAgB,aAAkC;AACrE,UAAM,QAAQ,WAAW,MAAM;AAC/B,QAAI,UAAU,SAAS,UAAU,KAAK;AACtC,QAAI,UAAU,QAAQ,OAAM;AAC5B,cAAU,QAAQ,QAAQ,UAAU,WAAW,MAAM,CAAC;AACtD,cAAU,QAAQ,QAAQ,UAAU,WAAW,KAAK,MAAM,CAAC;AAC3D,WAAO,QAAQ,IAAI,QAAQ,OAAM,CAAE,EAAE,UAAU,KAAK;EACtD;AAMO,MAAM,gBAAgB,CAAC,QAAgB,aAAkC;AAC9E,UAAM,MAAM,UAAU,WAAW,MAAM;AACvC,WAAO,UAAU,KAAK,WAAW,MAAM,GAAG,QAAQ,EAAE,IAAI,UAAU,KAAK,gBAAgB,MAAM,GAAG,QAAQ,CAAC;EAC3G;AAMO,MAAM,cAAc,CAAC,QAAgB,aAC1C,YAAY,QAAQ,QAAQ,EAAE,IAAI,YAAY,QAAQ,QAAQ,CAAC;AAM1D,MAAM,eAAe,CAAC,QAAgB,aAC3C,cAAc,QAAQ,QAAQ,EAAE,IAAI,YAAY,QAAQ,QAAQ,CAAC;AAM5D,MAAM,UAAU,CAAC,OAAc,QAAgB,aAAkC;AACtF,YAAQ,MAAM,MAAM;MAClB,KAAK;AACH,eAAO,YAAY,MAAM,OAAO,MAAM;MACxC,KAAK;AACH,eAAO,cAAc,MAAM;MAC7B,KAAK;AACH,eAAO,cAAc,QAAQ,QAAQ;MACvC,KAAK;AACH,eAAO,YAAY,QAAQ,QAAQ;MACrC,KAAK;AACH,eAAO,aAAa,QAAQ,QAAQ;MACtC,KAAK;AACH,eAAO,YAAY,MAAM;IAC7B;EACF;AAMO,MAAM,MAAM,CAAC,GAAW,MAAwB;AACrD,UAAM,QAAQ,UAAU,WAAW,CAAC;AACpC,QAAI,WAAW,CAAC,EAAE,WAAW,KAAK;AAAG,aAAO,WAAW,CAAC,EAAE,KAAK,CAAC;AAChE,QAAI,gBAAgB,CAAC,EAAE,WAAW,KAAK;AAAG,aAAO,gBAAgB,CAAC,EAAE,KAAK,CAAC;AAC1E,QAAI,WAAW,CAAC,EAAE,WAAW,KAAK;AAAG,aAAO,WAAW,CAAC,EAAE,KAAK,CAAC;AAChE,QAAI,WAAW,CAAC,EAAE,WAAW,KAAK;AAAG,aAAO,WAAW,CAAC,EAAE,KAAK,CAAC;AAChE,WAAO,UAAU,MAAK;EACxB;AAMO,MAAM,UAAU,CAAC,GAAW,MACjC,IAAI,GAAG,CAAC,EACL,UAAU,UAAU,KAAI,EAAG,MAAM,CAAC,EAAE,IAAI,UAAU,KAAI,EAAG,MAAM,CAAC,CAAC,CAAC,EAClE,aAAY;;;AClJX,MAAO,QAAP,MAAO,OAAK;IAqBhB,cAAA;IAAuB;IAEvB,OAAO,UAAO;AACZ,YAAM,QAAQ,IAAI,OAAK;AACvB,YAAM,MAAK;AACX,aAAO;IACT;;;;IAKA,QAAK;AACH,WAAK,WAAW,IAAI,UAAU,OAAQ,UAAW;AACjD,WAAK,WAAW,UAAU,MAAK;AAC/B,WAAK,QAAQ,IAAI,UAAU,OAAQ,CAAC;AACpC,WAAK,QAAQ,IAAI,UAAU,GAAG,UAAW;AACzC,WAAK,OAAO,IAAI,UAAU,OAAQ,QAAW;AAC7C,WAAK,SAAS,IAAI,UAAU,IAAM,UAAW;AAC7C,WAAK,SAAS,IAAI,UAAU,IAAM,SAAW;AAC7C,WAAK,OAAO,IAAI,UAAU,KAAM,UAAW;AAC3C,WAAK,QAAQ,IAAI,UAAU,GAAK,SAAW;AAC3C,WAAK,OAAO,IAAI,UAAU,IAAM,SAAW;IAC7C;IAEA,OAAO,QAAK;AACV,YAAM,QAAQ,IAAI,OAAK;AACvB,YAAM,MAAK;AACX,aAAO;IACT;IAEA,QAAK;AACH,WAAK,WAAW,UAAU,MAAK;AAC/B,WAAK,WAAW,UAAU,MAAK;AAC/B,iBAAW,SAAS;AAAQ,aAAK,KAAK,IAAI,UAAU,MAAK;AACzD,iBAAW,QAAQ;AAAO,aAAK,IAAI,IAAI,UAAU,MAAK;IACxD;IAEA,QAAK;AACH,YAAM,QAAQ,IAAI,OAAK;AACvB,YAAM,WAAW,KAAK;AACtB,YAAM,WAAW,KAAK;AACtB,iBAAW,SAAS;AAAQ,cAAM,KAAK,IAAI,KAAK,KAAK;AACrD,iBAAW,QAAQ;AAAO,cAAM,IAAI,IAAI,KAAK,IAAI;AACjD,aAAO;IACT;IAEA,SAAS,QAAc;AACrB,UAAI,KAAK,MAAM,IAAI,MAAM;AAAG,eAAO;AACnC,UAAI,KAAK,MAAM,IAAI,MAAM;AAAG,eAAO;AACnC;IACF;IAEA,QAAQ,QAAc;AACpB,iBAAW,QAAQ,OAAO;AACxB,YAAI,KAAK,IAAI,EAAE,IAAI,MAAM;AAAG,iBAAO;MACrC;AACA;IACF;IAEA,IAAI,QAAc;AAChB,YAAM,QAAQ,KAAK,SAAS,MAAM;AAClC,UAAI,CAAC;AAAO;AACZ,YAAM,OAAO,KAAK,QAAQ,MAAM;AAChC,YAAM,WAAW,KAAK,SAAS,IAAI,MAAM;AACzC,aAAO,EAAE,OAAO,MAAM,SAAQ;IAChC;;;;IAKA,KAAK,QAAc;AACjB,YAAM,QAAQ,KAAK,IAAI,MAAM;AAC7B,UAAI,OAAO;AACT,aAAK,WAAW,KAAK,SAAS,QAAQ,MAAM;AAC5C,aAAK,MAAM,KAAK,IAAI,KAAK,MAAM,KAAK,EAAE,QAAQ,MAAM;AACpD,aAAK,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,EAAE,QAAQ,MAAM;AAClD,YAAI,MAAM;AAAU,eAAK,WAAW,KAAK,SAAS,QAAQ,MAAM;MAClE;AACA,aAAO;IACT;;;;;IAMA,IAAI,QAAgB,OAAY;AAC9B,YAAM,MAAM,KAAK,KAAK,MAAM;AAC5B,WAAK,WAAW,KAAK,SAAS,KAAK,MAAM;AACzC,WAAK,MAAM,KAAK,IAAI,KAAK,MAAM,KAAK,EAAE,KAAK,MAAM;AACjD,WAAK,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,EAAE,KAAK,MAAM;AAC/C,UAAI,MAAM;AAAU,aAAK,WAAW,KAAK,SAAS,KAAK,MAAM;AAC7D,aAAO;IACT;IAEA,IAAI,QAAc;AAChB,aAAO,KAAK,SAAS,IAAI,MAAM;IACjC;IAEA,EAAE,OAAO,QAAQ,IAAC;AAChB,iBAAW,UAAU,KAAK,UAAU;AAClC,cAAM,CAAC,QAAQ,KAAK,IAAI,MAAM,CAAE;MAClC;IACF;IAEA,OAAO,OAAc,MAAU;AAC7B,aAAO,KAAK,KAAK,EAAE,UAAU,KAAK,IAAI,CAAC;IACzC;IAEA,iBAAc;AACZ,aAAO,KAAK,KAAK,MAAM,KAAK,KAAK;IACnC;IAEA,mBAAgB;AACd,aAAO,KAAK,OAAO,MAAM,KAAK,KAAK;IACrC;IAEA,WAAQ;AACN,aAAO,KAAK,OAAO,MAAM,KAAK,IAAI,EAAE,MAAM,KAAK,IAAI;IACrD;IAEA,UAAO;AACL,aAAO,KAAK,OAAO,MAAM,KAAK,IAAI,EAAE,MAAM,KAAK,KAAK;IACtD;;;;IAKA,OAAO,OAAY;AACjB,aAAO,KAAK,OAAO,OAAO,MAAM,EAAE,aAAY;IAChD;;;;ACjIF,MAAY;AAAZ,GAAA,SAAYE,eAAY;AACtB,IAAAA,cAAA,OAAA,IAAA;AACA,IAAAA,cAAA,eAAA,IAAA;AACA,IAAAA,cAAA,iBAAA,IAAA;AACA,IAAAA,cAAA,OAAA,IAAA;AACA,IAAAA,cAAA,SAAA,IAAA;EACF,GANY,iBAAA,eAAY,CAAA,EAAA;AAQlB,MAAO,gBAAP,cAA6B,MAAK;;AAExC,MAAM,YAAY,CAAC,QAAgB,UAAiB,OAAc,aAChE,MAAM,QAAQ,EAAE,UACd,YAAY,QAAQ,QAAQ,EACzB,UAAU,MAAM,eAAc,CAAE,EAChC,MAAM,cAAc,QAAQ,QAAQ,EAAE,UAAU,MAAM,iBAAgB,CAAE,CAAC,EACzE,MAAM,cAAc,MAAM,EAAE,UAAU,MAAM,MAAM,CAAC,EACnD,MAAM,YAAY,MAAM,EAAE,UAAU,MAAM,IAAI,CAAC,EAC/C,MAAM,YAAY,SAAS,QAAQ,GAAG,MAAM,EAAE,UAAU,MAAM,IAAI,CAAC,CAAC;AAGrE,MAAO,UAAP,MAAO,SAAO;IAKlB,cAAA;IAAuB;IAEvB,OAAO,UAAO;AACZ,YAAM,UAAU,IAAI,SAAO;AAC3B,cAAQ,iBAAiB,UAAU,QAAO;AAC1C,cAAQ,OAAO;QACb,OAAO,EAAE,GAAG,GAAG,GAAG,EAAC;QACnB,OAAO,EAAE,GAAG,IAAI,GAAG,GAAE;;AAEvB,cAAQ,OAAO;QACb,OAAO,EAAE,GAAG,IAAI,UAAU,IAAK,CAAC,GAAG,GAAG,IAAI,UAAU,IAAM,CAAC,EAAC;QAC5D,OAAO,EAAE,GAAG,IAAI,UAAU,GAAG,SAAU,GAAG,GAAG,IAAI,UAAU,GAAG,UAAU,EAAC;;AAE3E,aAAO;IACT;IAEA,OAAO,QAAK;AACV,YAAM,UAAU,IAAI,SAAO;AAC3B,cAAQ,iBAAiB,UAAU,MAAK;AACxC,cAAQ,OAAO;QACb,OAAO,EAAE,GAAG,QAAW,GAAG,OAAS;QACnC,OAAO,EAAE,GAAG,QAAW,GAAG,OAAS;;AAErC,cAAQ,OAAO;QACb,OAAO,EAAE,GAAG,UAAU,MAAK,GAAI,GAAG,UAAU,MAAK,EAAE;QACnD,OAAO,EAAE,GAAG,UAAU,MAAK,GAAI,GAAG,UAAU,MAAK,EAAE;;AAErD,aAAO;IACT;IAEA,QAAK;AACH,YAAM,UAAU,IAAI,SAAO;AAC3B,cAAQ,iBAAiB,KAAK;AAC9B,cAAQ,OAAO;QACb,OAAO,EAAE,GAAG,KAAK,KAAK,MAAM,GAAG,GAAG,KAAK,KAAK,MAAM,EAAC;QACnD,OAAO,EAAE,GAAG,KAAK,KAAK,MAAM,GAAG,GAAG,KAAK,KAAK,MAAM,EAAC;;AAErD,cAAQ,OAAO;QACb,OAAO,EAAE,GAAG,KAAK,KAAK,MAAM,GAAG,GAAG,KAAK,KAAK,MAAM,EAAC;QACnD,OAAO,EAAE,GAAG,KAAK,KAAK,MAAM,GAAG,GAAG,KAAK,KAAK,MAAM,EAAC;;AAErD,aAAO;IACT;IAEQ,IAAI,OAAc,MAAoB,MAAc,MAAY;AACtE,YAAM,SAAS,cAAc,OAAO,IAAI;AACxC,YAAM,SAAS,cAAc,OAAO,IAAI;AACxC,WAAK,iBAAiB,KAAK,eAAe,KAAK,IAAI;AACnD,WAAK,KAAK,KAAK,EAAE,IAAI,IAAI;AACzB,WAAK,KAAK,KAAK,EAAE,IAAI,IAAI,QAAQ,MAAM,MAAM,EAC1C,KAAK,MAAM,EACX,MAAM,QAAQ,MAAM,MAAM,EAAE,KAAK,MAAM,CAAC,EACxC,QAAQ,IAAI,EACZ,QAAQ,IAAI;IACjB;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,UAAU,SAAQ,MAAK;AAC7B,YAAM,QAAQ,MAAM,eAAe,UAAU,MAAM,MAAM,IAAI;AAC7D,iBAAW,SAAS,QAAQ;AAC1B,cAAM,WAAW,UAAU,SAAS,KAAK;AACzC,cAAM,OAAO,MAAM,MAAM,OAAO,KAAK;AACrC,YAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,SAAS,IAAI,IAAI;AAAG;AAC3C,cAAM,OAAO,MAAM,UAAU,MAAM,MAAM,KAAK,CAAC,EAAE,UAAU,QAAQ;AACnE,cAAM,QAAQ,KAAK,MAAK;AACxB,YAAI,QAAQ,KAAK,KAAK,QAAQ;AAAM,kBAAQ,IAAI,OAAO,KAAK,MAAM,KAAK;AACvE,cAAM,QAAQ,KAAK,KAAI;AACvB,YAAI,QAAQ,KAAK,KAAK,OAAO;AAAO,kBAAQ,IAAI,OAAO,KAAK,MAAM,KAAK;MACzE;AACA,aAAO;IACT;IAEA,YAAY,QAAc;AACxB,UAAI,KAAK,eAAe,IAAI,MAAM,GAAG;AACnC,aAAK,iBAAiB,KAAK,eAAe,QAAQ,MAAM;AACxD,mBAAW,SAAS,QAAQ;AAC1B,qBAAW,QAAQ,gBAAgB;AACjC,gBAAI,KAAK,KAAK,KAAK,EAAE,IAAI,MAAM;AAAQ,mBAAK,KAAK,KAAK,EAAE,IAAI,IAAI;UAClE;QACF;MACF;IACF;IAEA,aAAa,OAAY;AACvB,WAAK,iBAAiB,KAAK,eAAe,KAAK,UAAU,SAAS,KAAK,CAAC;AACxE,WAAK,KAAK,KAAK,EAAE,IAAI;AACrB,WAAK,KAAK,KAAK,EAAE,IAAI;IACvB;;AAWI,MAAgB,WAAhB,MAAwB;IAU5B,YAA+B,OAAY;AAAZ,WAAA,QAAA;IAAe;IAE9C,QAAK;AACH,WAAK,QAAQ,MAAM,QAAO;AAC1B,WAAK,UAAU;AACf,WAAK,OAAO;AACZ,WAAK,UAAU,QAAQ,QAAO;AAC9B,WAAK,WAAW;AAChB,WAAK,kBAAkB;AACvB,WAAK,YAAY;AACjB,WAAK,YAAY;IACnB;IAEU,eAAe,OAAY;AACnC,WAAK,QAAQ,MAAM,MAAM,MAAK;AAC9B,WAAK,MAAM,WAAW,UAAU,MAAK;AACrC,WAAK,UAAU;AACf,WAAK,OAAO,MAAM;AAClB,WAAK,UAAU,QAAQ,UAAU,KAAK;AACtC,WAAK,WAAW,cAAc,MAAM,MAAM,QAAQ;AAClD,WAAK,kBAAkB;AACvB,WAAK,YAAY,MAAM;AACvB,WAAK,YAAY,MAAM;IACzB;;;;;;;;;;;;IAcA,cAAc,QAAgB,UAAiB,UAAmB;AAChE,aAAO,UAAU,QAAQ,UAAU,KAAK,OAAO,QAAQ;IACzD;IAEU,cAAc,QAAgB,UAAe;AACrD,WAAK,YAAY;AACjB,UAAI,SAAS,SAAS;AAAQ,aAAK,QAAQ,YAAY,MAAM;AAC7D,UAAI,KAAK;AAAS,aAAK,QAAQ,SAAS,SAAS,KAAK,CAAC,EAAE,SAAS,WAAW,SAAS,SAAS,IAAI;IACrG;IAEA,MAAG;AACD,YAAM,aAAa,KAAK,aAAY;AACpC,YAAM,OAAO,KAAK,MAAM,OAAO,KAAK,IAAI;AACxC,UAAI,CAAC,QAAQ,IAAI,GAAG;AAClB,eAAO,EAAE,MAAM,UAAU,UAAU,MAAK,GAAI,UAAU,UAAU,MAAK,GAAI,YAAY,aAAa,MAAK;MACzG;AACA,YAAM,UAAU,YAAY,MAAM,UAAU,MAAK,CAAE,EAChD,UAAU,KAAK,MAAM,eAAc,CAAE,EACrC,MAAM,cAAc,MAAM,UAAU,MAAK,CAAE,EAAE,UAAU,KAAK,MAAM,iBAAgB,CAAE,CAAC,EACrF,UAAU,KAAK,MAAM,SAAS,KAAK,IAAI,CAAC,CAAC;AAC5C,UAAI,WAAW,UAAU,MAAK;AAC9B,iBAAW,UAAU,SAAS;AAC5B,cAAM,IAAI,QAAQ,MAAM,MAAM,EAAE,UAAU,KAAK,MAAM,QAAQ;AAC7D,YAAI,CAAC,EAAE,YAAW;AAAI,qBAAW,SAAS,MAAM,CAAC;MACnD;AACA,YAAM,WAAW,KAAK,cAAc,MAAM,SAAS,KAAK,IAAI,GAAG,KAAK,MAAM,QAAQ;AAClF,aAAO;QACL;QACA;QACA;QACA;QACA,aAAa;;IAEjB;IAEA,QAAK;;AACH,YAAM,MAAM,IAAK,KAAa,YAAW;AACzC,UAAI,QAAQ,KAAK,MAAM,MAAK;AAC5B,UAAI,WAAU,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK;AACjC,UAAI,OAAO,KAAK;AAChB,UAAI,UAAU,KAAK,QAAQ,MAAK;AAChC,UAAI,WAAW,KAAK;AACpB,UAAI,mBAAkB,KAAA,KAAK,qBAAe,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK;AACjD,UAAI,YAAY,KAAK;AACrB,UAAI,YAAY,KAAK;AACrB,aAAO;IACT;IAEU,WAAQ;AAChB,UAAI,KAAK,MAAM,SAAS,QAAO;AAAI,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAC1F,UAAI,KAAK,MAAM,KAAK,KAAI,MAAO;AAAG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAEzF,UAAI,CAAC,QAAQ,KAAK,MAAM,OAAO,KAAK,IAAI,CAAC;AAAG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAEnG,YAAM,YAAY,KAAK,MAAM,OAAO,SAAS,KAAK,IAAI,CAAC;AACvD,UAAI,CAAC,QAAQ,SAAS;AAAG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAChF,UAAI,KAAK,cAAc,WAAW,KAAK,MAAM,KAAK,MAAM,QAAQ,EAAE,SAAQ,GAAI;AAC5E,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,aAAa,CAAC;MACjE;AAEA,UAAI,UAAU,UAAS,EAAG,WAAW,KAAK,MAAM,IAAI,GAAG;AACrD,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,eAAe,CAAC;MACnE;AAEA,aAAO,OAAO,GAAG,MAAS;IAC5B;IAEA,UAAU,MAAc;AACtB,aAAO,UAAU,MAAK;IACxB;IAEA,MAAM,QAAgB,KAAa;AACjC,YAAM,OAAO,KAAK,IAAG;AACrB,UAAI,IAAI;AAAY,eAAO,UAAU,MAAK;AAC1C,YAAM,QAAQ,KAAK,MAAM,IAAI,MAAM;AACnC,UAAI,CAAC,SAAS,MAAM,UAAU,KAAK;AAAM,eAAO,UAAU,MAAK;AAE/D,UAAI,QAAQ;AACZ,UAAI,MAAM,SAAS,QAAQ;AACzB,iBAAS,YAAY,KAAK,MAAM,MAAM,EAAE,UAAU,KAAK,MAAM,SAAS,KAAK,IAAI,CAAC,CAAC;AACjF,cAAM,QAAQ,KAAK,SAAS,UAAU,IAAI;AAC1C,cAAM,OAAO,SAAS;AACtB,YAAI,KAAK,QAAQ,OAAO,MAAM,CAAC,KAAK,MAAM,SAAS,IAAI,IAAI,GAAG;AAC5D,mBAAS,OAAO,KAAK,IAAI;AACzB,gBAAM,gBAAgB,KAAK,SAAS,UAAU,SAAS,KAAK,UAAU,KAAK;AAC3E,gBAAM,aAAa,OAAO;AAC1B,cAAI,iBAAiB,CAAC,KAAK,MAAM,SAAS,IAAI,UAAU,GAAG;AACzD,qBAAS,OAAO,KAAK,UAAU;UACjC;QACF;AACA,YAAI,QAAQ,KAAK,QAAQ,KAAK,aAAa,MAAM,QAAQ,GAAG,GAAG;AAC7D,kBAAQ,UAAU,WAAW,KAAK,QAAQ;QAC5C;MACF,WAAW,MAAM,SAAS;AAAU,iBAAS,cAAc,QAAQ,KAAK,MAAM,QAAQ;eAC7E,MAAM,SAAS;AAAU,iBAAS,cAAc,MAAM;eACtD,MAAM,SAAS;AAAQ,iBAAS,YAAY,QAAQ,KAAK,MAAM,QAAQ;eACvE,MAAM,SAAS;AAAS,iBAAS,aAAa,QAAQ,KAAK,MAAM,QAAQ;;AAC7E,iBAAS,YAAY,MAAM;AAEhC,eAAS,OAAO,KAAK,KAAK,MAAM,KAAK,IAAI,CAAC;AAE1C,UAAI,QAAQ,IAAI,IAAI,GAAG;AACrB,YAAI,MAAM,SAAS,QAAQ;AACzB,gBAAM,MAAM,KAAK,MAAM,SAAS,QAAQ,MAAM;AAC9C,qBAAW,MAAM,QAAQ;AACvB,gBAAI,KAAK,cAAc,IAAI,SAAS,KAAK,IAAI,GAAG,GAAG,EAAE,SAAQ;AAAI,uBAAS,OAAO,QAAQ,EAAE;UAC7F;AACA,iBAAO,OAAO,MAAM,aAAa,MAAM,KAAK,GAAG,CAAC,EAAE,MAAM,aAAa,MAAM,KAAK,GAAG,CAAC;QACtF;AAEA,YAAI,IAAI,SAAS,SAAQ,GAAI;AAC3B,gBAAM,UAAU,IAAI,SAAS,aAAY;AACzC,cAAI,CAAC,QAAQ,OAAO;AAAG,mBAAO,UAAU,MAAK;AAC7C,mBAAS,OAAO,UAAU,QAAQ,SAAS,IAAI,IAAI,EAAE,KAAK,OAAO,CAAC;QACpE;AAEA,YAAI,IAAI,SAAS,IAAI,MAAM;AAAG,mBAAS,OAAO,UAAU,IAAI,QAAQ,IAAI,IAAI,CAAC;MAC/E;AAEA,UAAI;AAAO,iBAAS,OAAO,MAAM,KAAK;AACtC,aAAO;IACT;IAEA,eAAY;AACV,aAAO;IACT;IAEA,eAAe,MAAc;AAC3B;IACF;IAEA,wBAAwB,OAAY;AAClC,UAAI,KAAK,MAAM,KAAK,EAAE,UAAU,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,eAAc,CAAE,CAAC,EAAE,SAAQ;AAAI,eAAO;AACvG,UAAI,KAAK,MAAM,KAAK,EAAE,WAAW,KAAK,MAAM,MAAM,GAAG;AACnD,eACE,KAAK,MAAM,KAAK,EAAE,KAAI,KAAM,KACzB,KAAK,MAAM,SAAS,KAAK,CAAC,EAAE,KAAK,KAAK,MAAM,IAAI,EAAE,KAAK,KAAK,MAAM,KAAK,EAAE,QAAO;MAEvF;AACA,UAAI,KAAK,MAAM,KAAK,EAAE,WAAW,KAAK,MAAM,MAAM,GAAG;AACnD,cAAM,YAAY,CAAC,KAAK,MAAM,OAAO,WAAW,UAAU,YAAW,CAAE,KAClE,CAAC,KAAK,MAAM,OAAO,WAAW,UAAU,aAAY,CAAE;AAC3D,eAAO,aAAa,KAAK,MAAM,KAAK,QAAO,KAAM,KAAK,MAAM,OAAO,QAAO;MAC5E;AACA,aAAO;IACT;;IAIA,UAAO;;AACL,aAAO;QACL,OAAO,KAAK,MAAM,MAAK;QACvB,UAAS,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK;QAC5B,MAAM,KAAK;QACX,gBAAgB,KAAK,QAAQ;QAC7B,UAAU,cAAc,IAAI;QAC5B,kBAAiB,KAAA,KAAK,qBAAe,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK;QAC5C,WAAW,KAAK,IAAI,KAAK,WAAW,GAAG;QACvC,WAAW,KAAK,IAAI,KAAK,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI;;IAEzD;IAEA,yBAAsB;AACpB,aAAO,OAAO,MAAM,WAAS,KAAK,wBAAwB,KAAK,CAAC;IAClE;IAEA,SAAS,KAAa;AACpB,YAAM,OAAO,KAAK,IAAG;AACrB,iBAAW,UAAU,KAAK,MAAM,KAAK,IAAI,GAAG;AAC1C,YAAI,KAAK,MAAM,QAAQ,GAAG,EAAE,SAAQ;AAAI,iBAAO;MACjD;AACA,aAAO,KAAK,UAAU,GAAG,EAAE,SAAQ;IACrC;IAEA,QAAQ,MAAY,KAAa;AAC/B,UAAI,OAAO,IAAI,GAAG;AAChB,YAAI,CAAC,KAAK,WAAW,KAAK,QAAQ,KAAK,IAAI,EAAE,KAAK,IAAI,KAAK;AAAG,iBAAO;AACrE,YAAI,KAAK,SAAS,UAAU,UAAU,UAAS,EAAG,IAAI,KAAK,EAAE;AAAG,iBAAO;AACvE,eAAO,KAAK,UAAU,GAAG,EAAE,IAAI,KAAK,EAAE;MACxC,OAAO;AACL,YAAI,KAAK,cAAc;AAAQ,iBAAO;AACtC,YAAI,KAAK,cAAc,UAAU,KAAK,UAAU;AAAa,iBAAO;AACpE,YAAI,CAAC,CAAC,KAAK,eAAe,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,UAAU,UAAS,EAAG,IAAI,KAAK,EAAE;AAAI,iBAAO;AACxG,cAAM,QAAQ,KAAK,MAAM,KAAK,MAAM,GAAG;AACvC,eAAO,MAAM,IAAI,KAAK,EAAE,KAAK,MAAM,IAAI,cAAc,MAAM,IAAI,EAAE,EAAE;MACrE;IACF;IAEA,UAAO;AACL,YAAM,OAAO,KAAK,MAAM,OAAO,KAAK,IAAI;AACxC,aAAO,QAAQ,IAAI,KAAK,KAAK,cAAc,MAAM,SAAS,KAAK,IAAI,GAAG,KAAK,MAAM,QAAQ,EAAE,SAAQ;IACrG;IAEA,MAAM,KAAa;AACjB,UAAI,MAAM,IAAI,aAAa,KAAK,aAAY;AAAI,eAAO;AACvD,aAAO,KAAK,uBAAsB,KAAM,CAAC,KAAK,SAAS,GAAG;IAC5D;IAEA,YAAY,KAAa;AACvB,YAAM,OAAO,KAAK,IAAG;AACrB,aAAO,CAAC,IAAI,cAAc,IAAI,SAAS,SAAQ,KAAM,CAAC,KAAK,SAAS,GAAG;IACzE;IAEA,YAAY,KAAa;AACvB,YAAM,OAAO,KAAK,IAAG;AACrB,aAAO,CAAC,IAAI,cAAc,IAAI,SAAS,QAAO,KAAM,CAAC,KAAK,SAAS,GAAG;IACxE;IAEA,QAAQ,KAAa;AACnB,YAAM,iBAAiB,KAAK,eAAe,GAAG;AAC9C,UAAI;AAAgB,eAAO;AAC3B,YAAM,OAAO,KAAK,IAAG;AACrB,UAAI,KAAK,YAAY,GAAG;AAAG,eAAO,EAAE,QAAQ,SAAS,KAAK,IAAI,EAAC;eACtD,KAAK,uBAAsB,KAAM,KAAK,YAAY,GAAG;AAAG,eAAO,EAAE,QAAQ,OAAS;;AACtF;IACP;IAEA,SAAS,KAAa;AACpB,YAAM,OAAO,KAAK,IAAG;AACrB,YAAM,IAAI,oBAAI,IAAG;AACjB,UAAI,IAAI;AAAY,eAAO;AAC3B,iBAAW,UAAU,KAAK,MAAM,KAAK,IAAI,GAAG;AAC1C,UAAE,IAAI,QAAQ,KAAK,MAAM,QAAQ,GAAG,CAAC;MACvC;AACA,aAAO;IACT;IAEA,KAAK,MAAU;AACb,YAAM,OAAO,KAAK;AAClB,YAAM,WAAW,KAAK;AACtB,YAAM,WAAW,aAAa,MAAM,IAAI;AAExC,WAAK,WAAW;AAChB,WAAK,aAAa;AAClB,UAAI,SAAS;AAAS,aAAK,aAAa;AACxC,WAAK,OAAO,SAAS,IAAI;AAEzB,UAAI,OAAO,IAAI,GAAG;AAChB,aAAK,MAAM,IAAI,KAAK,IAAI,EAAE,MAAM,KAAK,MAAM,OAAO,KAAI,CAAE;AACxD,YAAI,KAAK;AAAS,eAAK,QAAQ,IAAI,EAAE,KAAK,IAAI;AAC9C,YAAI,KAAK,SAAS;AAAQ,eAAK,YAAY;MAC7C,OAAO;AACL,cAAM,QAAQ,KAAK,MAAM,KAAK,KAAK,IAAI;AACvC,YAAI,CAAC;AAAO;AAEZ,YAAI;AACJ,YAAI,MAAM,SAAS,QAAQ;AACzB,eAAK,YAAY;AACjB,cAAI,KAAK,OAAO,UAAU;AACxB,wBAAY,KAAK,MAAM,KAAK,KAAK,MAAM,SAAS,UAAU,KAAK,EAAE;UACnE;AACA,gBAAM,QAAQ,KAAK,OAAO,KAAK;AAC/B,cAAI,KAAK,IAAI,KAAK,MAAM,MAAM,KAAK,KAAK,QAAQ,KAAK,QAAQ,IAAI;AAC/D,iBAAK,WAAY,KAAK,OAAO,KAAK,MAAO;UAC3C;AACA,cAAI,KAAK,WAAW;AAClB,kBAAM,OAAO,KAAK;AAClB,kBAAM,WAAW,CAAC,CAAC,KAAK;UAC1B;QACF,WAAW,MAAM,SAAS,QAAQ;AAChC,eAAK,QAAQ,YAAY,KAAK,IAAI;QACpC,WAAW,MAAM,SAAS,QAAQ;AAChC,cAAI,UAAU;AACZ,kBAAM,WAAW,KAAK,QAAQ,KAAK,IAAI,EAAE,QAAQ;AACjD,gBAAI,QAAQ,QAAQ,GAAG;AACrB,oBAAM,OAAO,KAAK,MAAM,KAAK,QAAQ;AACrC,mBAAK,MAAM,IAAI,cAAc,MAAM,QAAQ,GAAG,KAAK;AACnD,kBAAI;AAAM,qBAAK,MAAM,IAAI,cAAc,MAAM,QAAQ,GAAG,IAAI;YAC9D;UACF;AACA,eAAK,QAAQ,aAAa,IAAI;QAChC;AAEA,YAAI,CAAC,UAAU;AACb,gBAAM,UAAU,KAAK,MAAM,IAAI,KAAK,IAAI,KAAK,KAAK;AAClD,cAAI;AAAS,iBAAK,cAAc,KAAK,IAAI,OAAO;QAClD;MACF;AAEA,UAAI,KAAK,iBAAiB;AACxB,YAAI,KAAK,QAAO;AAAI,eAAK,gBAAgB,IAAI,IAAI,KAAK,IAAI,KAAK,gBAAgB,IAAI,IAAI,GAAG,CAAC;MAC7F;IACF;;AAGI,MAAO,QAAP,cAAqB,SAAQ;IACjC,cAAA;AACE,YAAM,OAAO;IACf;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;;AAGF,MAAM,gBAAgB,CAAC,KAAe,WAAkD;AACtF,QAAI,CAAC,QAAQ,MAAM;AAAG;AACtB,UAAM,SAAS,IAAI,SAAS,UAAU,IAAI;AAC1C,UAAM,UAAU,IAAI,SAAS,UAAU,IAAI;AAC3C,QAAI,WAAW,MAAM,MAAM;AAAQ;AACnC,QAAI,IAAI,MAAM,SAAS,IAAI,SAAS,OAAO;AAAG;AAC9C,UAAM,OAAO,SAAS;AACtB,QAAI,CAAC,IAAI,MAAM,KAAK,IAAI,IAAI,KAAK,CAAC,IAAI,MAAM,SAAS,IAAI,IAAI,CAAC,EAAE,IAAI,IAAI;AAAG;AAC3E,WAAO;EACT;AAEA,MAAM,gBAAgB,CAAC,QAAqC;AAC1D,QAAI,CAAC,QAAQ,IAAI,QAAQ;AAAG;AAC5B,UAAM,MAAM,IAAI,IAAG;AACnB,UAAM,WAAW,IAAI,MAAM,OAAO,IAAI,MAAM,MAAM;AAClD,UAAM,aAAa,SAAS,UAAU,YAAY,SAAS,IAAI,IAAI,GAAG,IAAI,QAAQ,CAAC;AACnF,eAAW,aAAa,YAAY;AAClC,UAAI,IAAI,MAAM,WAAW,GAAG,EAAE,IAAI,IAAI,QAAQ;AAAG,eAAO,IAAI;IAC9D;AACA;EACF;AAEA,MAAM,eAAe,CAAC,KAAe,UAAkB,QAAyB;AAC9E,QAAI,CAAC,QAAQ,IAAI,QAAQ;AAAG,aAAO;AACnC,QAAI,CAAC,YAAY,IAAI,MAAM,QAAQ,EAAE,IAAI,IAAI,QAAQ;AAAG,aAAO;AAC/D,QAAI,CAAC,QAAQ,IAAI,IAAI;AAAG,aAAO;AAC/B,UAAM,QAAQ,IAAI,SAAS,UAAU,IAAI;AACzC,UAAM,WAAW,IAAI,WAAW;AAChC,WAAO,IACJ,cACC,IAAI,MACJ,SAAS,IAAI,IAAI,GACjB,IAAI,MAAM,SAAS,OAAO,QAAQ,EAAE,OAAO,QAAQ,EAAE,KAAK,IAAI,QAAQ,CAAC,EAExE,QAAQ,QAAQ,EAChB,QAAO;EACZ;AAEA,MAAM,eAAe,CAAC,KAAe,MAAoB,QAA2B;AAClF,QAAI,CAAC,QAAQ,IAAI,IAAI,KAAK,IAAI,SAAS,SAAQ;AAAI,aAAO,UAAU,MAAK;AACzE,UAAM,OAAO,IAAI,QAAQ,KAAK,IAAI,IAAI,EAAE,IAAI;AAC5C,QAAI,CAAC,QAAQ,IAAI;AAAG,aAAO,UAAU,MAAK;AAC1C,QAAI,IAAI,QAAQ,KAAK,IAAI,IAAI,EAAE,IAAI,EAAE,WAAW,IAAI,MAAM,QAAQ;AAAG,aAAO,UAAU,MAAK;AAE3F,UAAM,SAAS,cAAc,IAAI,MAAM,IAAI;AAC3C,UAAM,WAAW,QAAQ,IAAI,MAAM,MAAM;AACzC,UAAM,MAAM,IAAI,MAAM,SAAS,QAAQ,IAAI,IAAI;AAC/C,eAAW,MAAM,UAAU;AACzB,UAAI,IAAI,cAAc,IAAI,SAAS,IAAI,IAAI,GAAG,GAAG,EAAE,SAAQ;AAAI,eAAO,UAAU,MAAK;IACvF;AAEA,UAAM,SAAS,cAAc,IAAI,MAAM,IAAI;AAC3C,UAAM,QAAQ,IAAI,MAAM,SAAS,OAAO,IAAI,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,MAAM;AAC5E,QAAI,IAAI,cAAc,QAAQ,SAAS,IAAI,IAAI,GAAG,KAAK,EAAE,SAAQ;AAAI,aAAO,UAAU,MAAK;AAE3F,WAAO,UAAU,WAAW,IAAI;EAClC;AAEO,MAAM,cAAc,CAAC,KAAe,QAAgB,QAA2B;AACpF,QAAI,IAAI;AAAY,aAAO,UAAU,MAAK;AAC1C,UAAM,QAAQ,IAAI,MAAM,IAAI,MAAM;AAClC,QAAI,CAAC,SAAS,MAAM,UAAU,IAAI;AAAM,aAAO,UAAU,MAAK;AAE9D,QAAI,SAAS,QAAQ,OAAO,QAAQ,IAAI,MAAM,QAAQ;AACtD,QAAI,MAAM,SAAS,QAAQ;AACzB,UAAI,iBAAiB,IAAI,MAAM,SAAS,IAAI,IAAI,CAAC;AACjD,UAAI,QAAQ,IAAI,QAAQ;AAAG,yBAAiB,eAAe,KAAK,IAAI,QAAQ;AAC5E,eAAS,OAAO,UAAU,cAAc;AACxC,YAAM,QAAQ,IAAI,SAAS,UAAU,IAAI;AACzC,YAAM,OAAO,SAAS;AACtB,UAAI,KAAK,QAAQ,OAAO,MAAM,CAAC,IAAI,MAAM,SAAS,IAAI,IAAI,GAAG;AAC3D,iBAAS,OAAO,KAAK,IAAI;AACzB,cAAM,gBAAgB,IAAI,SAAS,UAAU,SAAS,KAAK,UAAU,KAAK;AAC1E,cAAM,aAAa,OAAO;AAC1B,YAAI,iBAAiB,CAAC,IAAI,MAAM,SAAS,IAAI,UAAU,GAAG;AACxD,mBAAS,OAAO,KAAK,UAAU;QACjC;MACF;AACA,aAAO;IACT,OAAO;AACL,eAAS,OAAO,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC;IAC1C;AACA,QAAI,WAAW,IAAI;AAAM,aAAO,OAAO,MAAM,aAAa,KAAK,KAAK,GAAG,CAAC,EAAE,MAAM,aAAa,KAAK,KAAK,GAAG,CAAC;;AACtG,aAAO;EACd;AAYO,MAAM,eAAe,CAAC,KAAe,SAAwC;AAClF,QAAI,OAAO,IAAI;AAAG;AAClB,UAAM,QAAQ,KAAK,KAAK,KAAK;AAC7B,QAAI,KAAK,IAAI,KAAK,MAAM,KAAK,CAAC,IAAI,MAAM,IAAI,IAAI,EAAE,IAAI,KAAK,EAAE;AAAG;AAChE,QAAI,CAAC,IAAI,MAAM,KAAK,IAAI,KAAK,IAAI;AAAG;AACpC,WAAO,QAAQ,IAAI,MAAM;EAC3B;AAEO,MAAM,gBAAgB,CAAC,KAAe,SAAoB;AAC/D,UAAM,OAAO,aAAa,KAAK,IAAI;AACnC,QAAI,CAAC;AAAM,aAAO;AAClB,UAAM,WAAW,IAAI,QAAQ,KAAK,IAAI,IAAI,EAAE,IAAI;AAChD,WAAO;MACL,MAAO,KAAoB;MAC3B,IAAI,QAAQ,QAAQ,IAAI,WAAW,KAAK;;EAE5C;;;ACzmBM,MAAO,eAAP,MAAO,cAAY;IAQvB,cAAA;IAAuB;IAEvB,OAAO,QAAK;AACV,YAAM,IAAI,IAAI,cAAY;AAC1B,iBAAW,QAAQ;AAAO,UAAE,IAAI,IAAI;AACpC,aAAO;IACT;IAEA,OAAO,UAAU,OAAc,OAAY;AACzC,YAAM,IAAI,IAAI,cAAY;AAC1B,iBAAW,QAAQ;AAAO,UAAE,IAAI,IAAI,MAAM,OAAO,OAAO,IAAI,EAAE,KAAI;AAClE,aAAO;IACT;IAEA,QAAK;AACH,YAAM,IAAI,IAAI,cAAY;AAC1B,iBAAW,QAAQ;AAAO,UAAE,IAAI,IAAI,KAAK,IAAI;AAC7C,aAAO;IACT;IAEA,OAAO,OAAmB;AACxB,aAAO,MAAM,MAAM,UAAQ,KAAK,IAAI,MAAM,MAAM,IAAI,CAAC;IACvD;IAEA,IAAI,OAAmB;AACrB,YAAM,IAAI,IAAI,cAAY;AAC1B,iBAAW,QAAQ;AAAO,UAAE,IAAI,IAAI,KAAK,IAAI,IAAI,MAAM,IAAI;AAC3D,aAAO;IACT;IAEA,SAAS,OAAmB;AAC1B,YAAM,IAAI,IAAI,cAAY;AAC1B,iBAAW,QAAQ;AAAO,UAAE,IAAI,IAAI,KAAK,IAAI,IAAI,MAAM,IAAI;AAC3D,aAAO;IACT;IAEA,WAAQ;AACN,aAAO,MAAM,KAAK,UAAQ,KAAK,IAAI,IAAI,CAAC;IAC1C;IAEA,UAAO;AACL,aAAO,CAAC,KAAK,SAAQ;IACvB;IAEA,WAAQ;AACN,aAAO,KAAK,OAAO;IACrB;IAEA,cAAW;AACT,aAAO,KAAK,SAAS,KAAK,KAAK,SAAS,KAAK,KAAK,OAAO,KAAK,KAAK,QAAQ,KAAK,KAAK,OAAO;IAC9F;IAEA,OAAI;AACF,aAAO,KAAK,OAAO,KAAK,SAAS,KAAK,SAAS,KAAK,OAAO,KAAK,QAAQ,KAAK;IAC/E;;AAGI,MAAO,WAAP,MAAO,UAAQ;IACnB,YACS,OACA,OAAmB;AADnB,WAAA,QAAA;AACA,WAAA,QAAA;IACN;IAEH,OAAO,QAAK;AACV,aAAO,IAAI,UAAS,aAAa,MAAK,GAAI,aAAa,MAAK,CAAE;IAChE;IAEA,OAAO,UAAU,OAAY;AAC3B,aAAO,IAAI,UAAS,aAAa,UAAU,OAAO,OAAO,GAAG,aAAa,UAAU,OAAO,OAAO,CAAC;IACpG;IAEA,QAAK;AACH,aAAO,IAAI,UAAS,KAAK,MAAM,MAAK,GAAI,KAAK,MAAM,MAAK,CAAE;IAC5D;IAEA,OAAO,OAAe;AACpB,aAAO,KAAK,MAAM,OAAO,MAAM,KAAK,KAAK,KAAK,MAAM,OAAO,MAAM,KAAK;IACxE;IAEA,IAAI,OAAe;AACjB,aAAO,IAAI,UAAS,KAAK,MAAM,IAAI,MAAM,KAAK,GAAG,KAAK,MAAM,IAAI,MAAM,KAAK,CAAC;IAC9E;IAEA,SAAS,OAAe;AACtB,aAAO,IAAI,UAAS,KAAK,MAAM,SAAS,MAAM,KAAK,GAAG,KAAK,MAAM,SAAS,MAAM,KAAK,CAAC;IACxF;IAEA,MAAM,MAAU;AACd,aAAO,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI;IAC3C;IAEA,OAAI;AACF,aAAO,KAAK,MAAM,KAAI,IAAK,KAAK,MAAM,KAAI;IAC5C;IAEA,UAAO;AACL,aAAO,KAAK,MAAM,QAAO,KAAM,KAAK,MAAM,QAAO;IACnD;IAEA,WAAQ;AACN,aAAO,CAAC,KAAK,QAAO;IACtB;IAEA,WAAQ;AACN,aAAO,KAAK,MAAM,SAAQ,KAAM,KAAK,MAAM,SAAQ;IACrD;IAEA,cAAW;AACT,aAAO,KAAK,MAAM,YAAW,KAAM,KAAK,MAAM,YAAW;IAC3D;;AAGI,MAAO,kBAAP,MAAO,iBAAe;IAC1B,YACS,OACA,OAAa;AADb,WAAA,QAAA;AACA,WAAA,QAAA;IACN;IAEH,OAAO,UAAO;AACZ,aAAO,IAAI,iBAAgB,GAAG,CAAC;IACjC;IAEA,QAAK;AACH,aAAO,IAAI,iBAAgB,KAAK,OAAO,KAAK,KAAK;IACnD;IAEA,OAAO,OAAsB;AAC3B,aAAO,KAAK,UAAU,MAAM,SAAS,KAAK,UAAU,MAAM;IAC5D;;;;ACrIK,MAAM,oBAAoB;AAC1B,MAAM,cAAc,oBAAoB;AACxC,MAAM,cAAc,cAAc;AAClC,MAAM,kBAAkB;AACxB,MAAM,YAAY,kBAAkB;AACpC,MAAM,YAAY,YAAY;AAErC,MAAY;AAAZ,GAAA,SAAYC,aAAU;AACpB,IAAAA,YAAA,KAAA,IAAA;AACA,IAAAA,YAAA,OAAA,IAAA;AACA,IAAAA,YAAA,SAAA,IAAA;AACA,IAAAA,YAAA,MAAA,IAAA;AACA,IAAAA,YAAA,UAAA,IAAA;AACA,IAAAA,YAAA,UAAA,IAAA;AACA,IAAAA,YAAA,iBAAA,IAAA;AACA,IAAAA,YAAA,WAAA,IAAA;AACA,IAAAA,YAAA,WAAA,IAAA;EACF,GAVY,eAAA,aAAU,CAAA,EAAA;AAYhB,MAAO,WAAP,cAAwB,MAAK;;AAEnC,MAAM,aAAa,CAAC,UAAkB,QAAgB,MAAqB;AACzE,QAAI,QAAQ,SAAS,QAAQ,MAAM;AACnC,WAAO,MAAM,GAAG;AACd,UAAI,UAAU;AAAI;AAClB,cAAQ,SAAS,QAAQ,QAAQ,QAAQ,OAAO,MAAM;IACxD;AACA,WAAO;EACT;AAEA,MAAM,iBAAiB,CAAC,QAAqC,YAAY,KAAK,GAAG,IAAI,SAAS,KAAK,EAAE,IAAI;AAEzG,MAAM,cAAc,CAAC,OAAiC;AACpD,UAAM,OAAO,WAAW,EAAE;AAC1B,WAAO,QAAQ,EAAE,MAAM,OAAO,GAAG,YAAW,MAAO,KAAK,UAAU,QAAO;EAC3E;AAEO,MAAM,gBAAgB,CAAC,cAA8C;AAC1E,UAAM,QAAQ,MAAM,MAAK;AACzB,QAAI,OAAO;AACX,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,IAAI,UAAU,CAAC;AACrB,UAAI,MAAM,OAAO,SAAS,GAAG;AAC3B,eAAO;AACP;MACF,OAAO;AACL,cAAM,OAAO,SAAS,GAAG,EAAE;AAC3B,YAAI,OAAO;AAAG,kBAAQ;aACjB;AACH,cAAI,QAAQ,KAAK,OAAO;AAAG,mBAAO,OAAO,IAAI,IAAI,SAAS,WAAW,KAAK,CAAC;AAC3E,gBAAM,SAAS,OAAO,OAAO;AAC7B,gBAAM,QAAQ,YAAY,CAAC;AAC3B,cAAI,CAAC;AAAO,mBAAO,OAAO,IAAI,IAAI,SAAS,WAAW,KAAK,CAAC;AAC5D,cAAI,UAAU,IAAI,CAAC,MAAM,KAAK;AAC5B,kBAAM,WAAW;AACjB;UACF;AACA,gBAAM,IAAI,QAAQ,KAAK;AACvB;QACF;MACF;IACF;AACA,QAAI,SAAS,KAAK,SAAS;AAAG,aAAO,OAAO,IAAI,IAAI,SAAS,WAAW,KAAK,CAAC;AAC9E,WAAO,OAAO,GAAG,KAAK;EACxB;AAEO,MAAM,eAAe,CAAC,eAAkD;AAC7E,QAAI,WAAW,SAAS;AAAI,aAAO,OAAO,IAAI,IAAI,SAAS,WAAW,OAAO,CAAC;AAC9E,UAAM,UAAU,SAAS,MAAK;AAC9B,eAAW,KAAK,YAAY;AAC1B,YAAM,QAAQ,YAAY,CAAC;AAC3B,UAAI,CAAC;AAAO,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,OAAO,CAAC;AAC9D,cAAQ,MAAM,KAAK,EAAE,MAAM,IAAI;IACjC;AACA,WAAO,OAAO,GAAG,OAAO;EAC1B;AAEO,MAAM,mBAAmB,CAAC,OAAc,iBAAqD;AAClG,QAAI,iBAAiB,UAAU,MAAK;AACpC,QAAI,iBAAiB;AAAK,aAAO,OAAO,GAAG,cAAc;AAEzD,eAAW,KAAK,cAAc;AAC5B,YAAM,QAAQ,EAAE,YAAW;AAC3B,YAAM,QAAQ,MAAM,QAAQ,UAAU;AACtC,YAAM,OAAO,UAAU,UAAU,IAAI;AACrC,UAAI,OAAO,SAAS,SAAS,KAAK;AAChC,yBAAiB,eAAe,KAAK,iBAAiB,MAAM,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,GAAG,IAAI,CAAE;MACvG,WAAW,UAAU,OAAO,UAAU,KAAK;AACzC,cAAM,gBAAgB,MAAM,KAAK,EAAE,UAAU,UAAU,SAAS,KAAK,CAAC,EAAE,UAAU,MAAM,KAAK,MAAM,MAAM,IAAI,CAAC;AAC9G,cAAM,YAAY,UAAU,MAAM,cAAc,KAAI,IAAK,cAAc,MAAK;AAC5E,yBAAiB,eAAe,KAC9B,QAAQ,SAAS,KAAK,MAAM,KAAK,IAAI,SAAS,IAAI,YAAY,iBAAiB,UAAU,MAAM,IAAI,GAAG,IAAI,CAAE;MAEhH;AAAO,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,QAAQ,CAAC;IAC5D;AAEA,QAAI,OAAO,KAAK,WAAS,UAAU,SAAS,KAAK,EAAE,UAAU,cAAc,EAAE,KAAI,IAAK,CAAC,GAAG;AACxF,aAAO,OAAO,IAAI,IAAI,SAAS,WAAW,QAAQ,CAAC;IACrD;AAEA,WAAO,OAAO,GAAG,cAAc;EACjC;AAEO,MAAM,uBAAuB,CAAC,SAAmD;AACtF,UAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,QAAI,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,IAAI;AACzC,YAAM,QAAQ,eAAe,MAAM,CAAC,CAAC;AACrC,YAAM,QAAQ,eAAe,MAAM,CAAC,CAAC;AACrC,UAAI,CAAC,QAAQ,KAAK,KAAK,QAAQ,KAAK,CAAC,QAAQ,KAAK,KAAK,QAAQ,GAAG;AAChE,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,eAAe,CAAC;MAC5D;AACA,aAAO,OAAO,GAAG,IAAI,gBAAgB,IAAI,OAAO,IAAI,KAAK,CAAC;IAC5D,WAAW,MAAM,WAAW,GAAG;AAC7B,YAAM,QAAQ,eAAe,MAAM,CAAC,CAAC;AACrC,YAAM,QAAQ,eAAe,MAAM,CAAC,CAAC;AACrC,UAAI,CAAC,QAAQ,KAAK,KAAK,QAAQ,KAAK,CAAC,QAAQ,KAAK,KAAK,QAAQ,GAAG;AAChE,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,eAAe,CAAC;MAC5D;AACA,aAAO,OAAO,GAAG,IAAI,gBAAgB,OAAO,KAAK,CAAC;IACpD;AAAO,aAAO,OAAO,IAAI,IAAI,SAAS,WAAW,eAAe,CAAC;EACnE;AAEO,MAAM,WAAW,CAAC,QAAwC;AAC/D,UAAM,QAAQ,IAAI,MAAM,QAAQ;AAChC,UAAM,YAAY,MAAM,MAAK;AAG7B,QAAI;AACJ,QAAI,UAAU,OAAO,GAAmC,MAAS;AACjE,QAAI,UAAU,SAAS,GAAG,GAAG;AAC3B,YAAM,cAAc,UAAU,QAAQ,GAAG;AACzC,UAAI,gBAAgB;AAAI,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,GAAG,CAAC;AACtE,cAAQ,cAAc,UAAU,MAAM,GAAG,WAAW,CAAC;AACrD,gBAAU,aAAa,UAAU,MAAM,cAAc,GAAG,EAAE,CAAC;IAC7D,OAAO;AACL,YAAM,cAAc,WAAW,WAAW,KAAK,CAAC;AAChD,UAAI,gBAAgB;AAAI,gBAAQ,cAAc,SAAS;WAClD;AACH,gBAAQ,cAAc,UAAU,MAAM,GAAG,WAAW,CAAC;AACrD,kBAAU,aAAa,UAAU,MAAM,cAAc,CAAC,CAAC;MACzD;IACF;AAGA,QAAI;AACJ,UAAM,WAAW,MAAM,MAAK;AAC5B,QAAI,CAAC,QAAQ,QAAQ,KAAK,aAAa;AAAK,aAAO;aAC1C,aAAa;AAAK,aAAO;;AAC7B,aAAO,OAAO,IAAI,IAAI,SAAS,WAAW,IAAI,CAAC;AAEpD,WAAO,MAAM,MAAM,CAAAC,WAAQ;AAEzB,YAAM,eAAe,MAAM,MAAK;AAChC,YAAM,iBAAiB,QAAQ,YAAY,IAAI,iBAAiBA,QAAO,YAAY,IAAI,OAAO,GAAG,UAAU,MAAK,CAAE;AAGlH,YAAM,SAAS,MAAM,MAAK;AAC1B,UAAI;AACJ,UAAI,QAAQ,MAAM,KAAK,WAAW,KAAK;AACrC,mBAAW,YAAY,MAAM;AAC7B,YAAI,CAAC,QAAQ,QAAQ;AAAG,iBAAO,OAAO,IAAI,IAAI,SAAS,WAAW,QAAQ,CAAC;MAC7E;AAGA,UAAI,eAAe,MAAM,MAAK;AAC9B,UAAI;AACJ,UAAI,QAAQ,YAAY,KAAK,aAAa,SAAS,GAAG,GAAG;AACvD,+BAAuB,qBAAqB,YAAY;AACxD,uBAAe,MAAM,MAAK;MAC5B;AACA,YAAM,YAAY,QAAQ,YAAY,IAAI,eAAe,YAAY,IAAI;AACzE,UAAI,CAAC,QAAQ,SAAS;AAAG,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,SAAS,CAAC;AAE7E,YAAM,gBAAgB,MAAM,MAAK;AACjC,YAAM,YAAY,QAAQ,aAAa,IAAI,eAAe,aAAa,IAAI;AAC3E,UAAI,CAAC,QAAQ,SAAS;AAAG,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,SAAS,CAAC;AAE7E,YAAM,sBAAsB,MAAM,MAAK;AACvC,UAAI,kBAAiE,OAAO,GAAG,MAAS;AACxF,UAAI,QAAQ,mBAAmB,GAAG;AAChC,YAAI,QAAQ,oBAAoB;AAAG,iBAAO,OAAO,IAAI,IAAI,SAAS,WAAW,eAAe,CAAC;AAC7F,0BAAkB,qBAAqB,mBAAmB;MAC5D,WAAW,QAAQ,oBAAoB,GAAG;AACxC,0BAAkB;MACpB;AAEA,UAAI,MAAM,SAAS;AAAG,eAAO,OAAO,IAAI,IAAI,SAAS,WAAW,GAAG,CAAC;AAEpE,aAAO,QAAQ,MAAM,CAAAC,aACnB,eAAe,MAAM,CAAAC,oBACnB,gBAAgB,IAAI,CAAAC,qBAAkB;AACpC,eAAO;UACL,OAAAH;UACA,SAAAC;UACA;UACA,gBAAAC;UACA,iBAAAC;UACA;UACA;UACA,WAAW,KAAK,IAAI,GAAG,SAAS;;MAEpC,CAAC,CAAC,CACH;IAEL,CAAC;EACH;;;AClLM,MAAO,aAAP,cAA0B,SAAQ;IACtC,cAAA;AACE,YAAM,YAAY;IACpB;IAEA,QAAK;AACH,YAAM,MAAK;AACX,WAAK,UAAU,SAAS,MAAK;IAC/B;IAEU,eAAe,OAAY;AACnC,YAAM,eAAe,KAAK;AAC1B,WAAK,MAAM,WAAW,MAAM,MAAM,SAC/B,UAAU,MAAM,MAAM,QAAQ,EAC9B,KAAK,MAAM,MAAM,IAAI,EACrB,KAAK,MAAM,MAAM,IAAI;AACxB,WAAK,UAAU,MAAM,UAAU,MAAM,QAAQ,MAAK,IAAK,SAAS,MAAK;IACvE;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEU,WAAQ;AAChB,aAAO,MAAM,SAAQ,EAAG,MAAM,OAAI;;AAChC,aAAI,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,MAAM,MAAM,GAAG;AAC/B,iBAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;QACzD;AACA,eAAK,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,KAAI,MAAM,KAAK,KAAK,MAAM,SAAS,KAAI,IAAK,IAAI;AACjE,iBAAO,OAAO,IAAI,IAAI,cAAc,aAAa,OAAO,CAAC;QAC3D;AACA,eAAO,OAAO,GAAG,MAAS;MAC5B,CAAC;IACH;IAEA,wBAAwB,OAAY;AAGlC,UAAI,CAAC,KAAK;AAAS,eAAO,MAAM,wBAAwB,KAAK;AAC7D,aACE,KAAK,MAAM,SAAS,KAAI,IAAK,KAAK,QAAQ,KAAI,KAAM,KACjD,KAAK,MAAM,KAAK,QAAO,KACvB,KAAK,MAAM,SAAS,QAAO,KAC3B,KAAK,MAAM,eAAc,EAAG,QAAO,KACnC,KAAK,QAAQ,MAAM,MAAM,KAAK,KAC9B,KAAK,QAAQ,MAAM,MAAM,KAAK,KAC9B,KAAK,QAAQ,MAAM,OAAO,KAAK;IAEtC;IAEA,UAAU,KAAa;;AACrB,YAAM,OAAO,KAAK,MAAM,SACrB,WAAU,EACV,YACC,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAG,KAAK,IAAI,EAAE,YAAW,KACjC,UAAU,KAAI,MACd,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAG,KAAK,IAAI,EAAE,SAAQ,KAClC,UAAU,UAAS,EAAG,WAAU,IAChC,UAAU,MAAK,CAAE;AAGzB,YAAM,OAAO,KAAK,IAAG;AACrB,UAAI,QAAQ,IAAI,IAAI,KAAK,IAAI,SAAS,SAAQ,GAAI;AAChD,cAAM,UAAU,IAAI,SAAS,aAAY;AACzC,YAAI,CAAC,QAAQ,OAAO;AAAG,iBAAO,UAAU,MAAK;AAC7C,eAAO,KAAK,UAAU,QAAQ,SAAS,IAAI,IAAI,CAAC;MAClD;AAAO,eAAO;IAChB;;AAGI,MAAO,SAAP,cAAsB,SAAQ;IAClC,cAAA;AACE,YAAM,QAAQ;IAChB;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEU,WAAQ;AAEhB,UAAI,KAAK,MAAM,SAAS,QAAO;AAAI,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAC1F,UAAI,KAAK,MAAM,KAAK,KAAI,IAAK;AAAG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AACvF,YAAM,YAAY,KAAK,MAAM,OAAO,SAAS,KAAK,IAAI,CAAC;AACvD,UAAI,CAAC,QAAQ,SAAS;AAAG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAChF,UAAI,KAAK,cAAc,WAAW,KAAK,MAAM,KAAK,MAAM,QAAQ,EAAE,SAAQ,GAAI;AAC5E,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,aAAa,CAAC;MACjE;AACA,UAAI,UAAU,UAAS,EAAG,WAAW,KAAK,MAAM,IAAI,GAAG;AACrD,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,eAAe,CAAC;MACnE;AACA,aAAO,OAAO,GAAG,MAAS;IAC5B;IAEA,cAAc,QAAgB,UAAiB,UAAmB;AAChE,YAAM,gBAAgB,KAAK,MAAM,OAAO,UAAU,MAAM;AACxD,UAAI,cAAc,QAAO,KAAM,YAAY,MAAM,EAAE,WAAW,aAAa,GAAG;AAC5E,eAAO,UAAU,MAAK;MACxB;AACA,aAAO,MAAM,cAAc,QAAQ,UAAU,QAAQ;IACvD;IAEU,cAAc,QAAgB,UAAe;AACrD,YAAM,cAAc,QAAQ,QAAQ;AACpC,WAAK,MAAM,KAAK,MAAM;AACtB,iBAAW,WAAW,YAAY,MAAM,EAAE,UAAU,KAAK,MAAM,QAAQ,EAAE,KAAK,KAAK,MAAM,IAAI,GAAG;AAC9F,cAAM,QAAQ,KAAK,MAAM,KAAK,OAAO;AACrC,aAAI,UAAK,QAAL,UAAK,SAAA,SAAL,MAAO,UAAS;AAAQ,eAAK,QAAQ,YAAY,OAAO;AAC5D,aAAI,UAAK,QAAL,UAAK,SAAA,SAAL,MAAO,UAAS;AAAQ,eAAK,QAAQ,aAAa,MAAM,KAAK;MACnE;IACF;IAEA,wBAAwB,OAAY;AAGlC,UAAI,KAAK,MAAM,OAAO,SAAS,KAAK,GAAG,MAAM,EAAE,QAAO;AAAI,eAAO;AAGjE,UAAI,KAAK,MAAM,KAAK,EAAE,KAAK,KAAK,MAAM,IAAI,EAAE,QAAO;AAAI,eAAO;AAI9D,UAAI,KAAK,MAAM,SAAS,KAAK,CAAC,EAAE,KAAK,KAAK,MAAM,IAAI,EAAE,SAAQ,GAAI;AAEhE,YAAI,KAAK,MAAM,SAAS,OAAO,KAAK,MAAM,OAAO,MAAM,KAAK,MAAM,IAAI,CAAC,GAAG;AACxE,cAAI,CAAC,KAAK,MAAM,OAAO,UAAU,KAAK,MAAM,KAAK,EAAE,WAAW,UAAU,YAAW,CAAE,GAAG;AACtF,mBAAO,CAAC,KAAK,MAAM,OAAO,UAAU,KAAK,MAAM,KAAK,EAAE,WAAW,UAAU,aAAY,CAAE;UAC3F;AACA,cAAI,CAAC,KAAK,MAAM,OAAO,UAAU,KAAK,MAAM,KAAK,EAAE,WAAW,UAAU,aAAY,CAAE,GAAG;AACvF,mBAAO,CAAC,KAAK,MAAM,OAAO,UAAU,KAAK,MAAM,KAAK,EAAE,WAAW,UAAU,YAAW,CAAE;UAC1F;QACF;AACA,eAAO;MACT;AAGA,UAAI,KAAK,MAAM,MAAM,SAAQ,KAAM,KAAK,MAAM,KAAK,SAAQ;AAAI,eAAO;AAGtE,UAAI,KAAK,MAAM,OAAO,MAAM,KAAK,MAAM,MAAM,EAAE,MAAM,KAAK,MAAM,IAAI,EAAE,KAAI,MAAO;AAAG,eAAO;AAG3F,UAAI,KAAK,MAAM,SAAS,OAAO,KAAK,MAAM,OAAO,MAAM,KAAK,MAAM,IAAI,CAAC,GAAG;AACxE,eAAO,KAAK,MAAM,OAAO,KAAI,KAAM;MACrC;AAEA,aAAO;IACT;IAEA,MAAM,QAAgB,KAAa;AACjC,YAAM,OAAO,KAAK,IAAG;AACrB,UAAI,QAAQ,UAAU,MAAK;AAC3B,iBAAW,MAAM,YAAY,MAAM,QAAQ,GAAG,GAAG;AAC/C,cAAM,QAAQ,KAAK,MAAK;AACxB,cAAM,KAAK,EAAE,MAAM,QAAQ,GAAE,CAAE;AAC/B,cAAM,UAAU,MAAM,MAAM,OAAO,KAAK,IAAI;AAC5C,YACE,QAAQ,OAAO,MACX,CAAC,QAAQ,MAAM,MAAM,OAAO,MAAM,IAAI,CAAC,KACtC,MAAM,cAAc,SAAS,MAAM,MAAM,MAAM,MAAM,QAAQ,EAAE,QAAO,IAC3E;AACA,kBAAQ,MAAM,KAAK,EAAE;QACvB;MACF;AACA,aAAO;IACT;IAEA,eAAY;AACV,aAAO,CAAC,CAAC,KAAK,eAAc;IAC9B;IAEA,eAAe,MAAc;AAC3B,iBAAW,SAAS,QAAQ;AAC1B,YAAI,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,QAAO;AAAI,iBAAO,EAAE,QAAQ,SAAS,KAAK,EAAC;MAClF;AACA;IACF;;AAGI,MAAO,YAAP,cAAyB,SAAQ;IACrC,cAAA;AACE,YAAM,WAAW;IACnB;IAEA,QAAK;AACH,YAAM,MAAK;AACX,WAAK,UAAU,QAAQ,MAAK;IAC9B;IAEU,eAAe,OAAY;AACnC,YAAM,eAAe,KAAK;AAC1B,WAAK,UAAU,QAAQ,MAAK;IAC9B;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEU,WAAQ;AAChB,UAAI,KAAK,MAAM,SAAS,QAAO;AAAI,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAC1F,UAAI,UAAU,UAAS,EAAG,WAAW,KAAK,MAAM,IAAI,GAAG;AACrD,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,eAAe,CAAC;MACnE;AACA,aAAO,OAAO,GAAG,MAAS;IAC5B;IAEA,cAAc,SAAiB,WAAkB,WAAoB;AACnE,aAAO,UAAU,MAAK;IACxB;IAEA,MAAG;AACD,YAAM,MAAM,MAAM,IAAG;AACrB,UACE,QAAQ,KAAK,QAAQ,KAClB,YAAY,SAAS,KAAK,IAAI,GAAG,KAAK,QAAQ,EAAE,WAAW,KAAK,MAAM,OAAO,KAAK,MAAM,MAAM,CAAC,GAClG;AACA,YAAI,cAAc;AAClB,eAAO;MACT;AACA,YAAM,QAAQ,KAAK,MAAM,SAAS,KAAK,IAAI,CAAC;AAC5C,iBAAW,QAAQ,KAAK,MAAM,KAAK,IAAI,GAAG;AACxC,YAAI,YAAY,MAAM,MAAM,GAAG,EAAE,WAAW,KAAK,GAAG;AAClD,cAAI,cAAc;AAClB,iBAAO;QACT;MACF;AACA,aAAO;IACT;IAEA,MAAM,QAAgB,KAAa;AACjC,YAAM,OAAO,KAAK,IAAG;AACrB,YAAM,QAAQ,YAAY,MAAM,QAAQ,GAAG;AAC3C,YAAM,QAAQ,KAAK,MAAM,SAAS,KAAK,IAAI,CAAC;AAC5C,aAAO,MAAM,UACX,IAAI,cACA,QAAQ,KAAK,QAAQ,KAAK,KAAK,MAAM,QAAQ,MAAM,MAAM,SACvD,MAAM,KAAK,KAAK,QAAQ,IACxB,QACF,UAAU,KAAI,CAAE;IAExB;IAEA,wBAAwB,OAAY;AAClC,UAAI,KAAK,MAAM,KAAK,EAAE,QAAO;AAAI,eAAO;AACxC,UAAI,KAAK,MAAM,SAAS,KAAK,CAAC,EAAE,QAAO;AAAI,eAAO;AAClD,UAAI,KAAK,MAAM,SAAS,OAAO,KAAK,MAAM,MAAM,GAAG;AACjD,cAAM,gBAAgB,KAAK,MAAM,KAAK,EAAE,WAAW,UAAU,aAAY,CAAE;AAC3E,cAAM,eAAe,KAAK,MAAM,KAAK,EAAE,WAAW,UAAU,YAAW,CAAE;AACzE,cAAM,gBAAgB,KAAK,MAAM,SAAS,KAAK,CAAC,EAAE,WAAW,UAAU,aAAY,CAAE;AACrF,cAAM,iBAAiB,KAAK,MAAM,SAAS,KAAK,CAAC,EAAE,WAAW,UAAU,YAAW,CAAE;AACrF,eAAQ,iBAAiB,iBAAmB,gBAAgB;MAC9D;AACA,UAAI,KAAK,MAAM,SAAS,OAAO,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,SAAS,KAAI,MAAO,GAAG;AACrF,eACG,KAAK,MAAM,MAAM,WAAW,UAAU,aAAY,CAAE,MAC/C,KAAK,MAAM,MAAM,WAAW,UAAU,YAAW,CAAE,OAClD,KAAK,SAAS;MAEzB;AACA,aAAO;IACT;IAEA,eAAY;AACV,aAAO,KAAK,MAAM,KAAK,IAAI,EAAE,QAAO;IACtC;IAEA,eAAe,KAAa;AAC1B,YAAM,OAAO,KAAK,IAAG;AACrB,UAAI,IAAI,cAAc,KAAK,YAAY,GAAG,GAAG;AAC3C,eAAO,EAAE,QAAQ,KAAK,KAAI;MAC5B;AACA;IACF;;AAGI,MAAO,gBAAP,cAA6B,SAAQ;IACzC,cAAA;AACE,YAAM,eAAe;IACvB;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEA,wBAAwB,QAAa;AACnC,aAAO;IACT;IAEA,eAAY;AACV,aAAO,KAAK,MAAM,KAAK,WAAW,UAAU,OAAM,CAAE;IACtD;IAEA,eAAe,MAAc;AAC3B,iBAAW,SAAS,QAAQ;AAC1B,YAAI,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,WAAW,UAAU,OAAM,CAAE;AAAG,iBAAO,EAAE,QAAQ,MAAK;MAC7F;AACA;IACF;;AAGI,MAAO,aAAP,cAA0B,SAAQ;IACtC,cAAA;AACE,YAAM,QAAQ;IAChB;IAEA,QAAK;AACH,YAAM,MAAK;AACX,WAAK,kBAAkB,gBAAgB,QAAO;IAChD;IAEU,eAAe,OAAY;;AACnC,YAAM,eAAe,KAAK;AAC1B,WAAK,oBAAkB,KAAA,MAAM,qBAAe,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK,MAAM,gBAAgB,QAAO;IAClF;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEA,wBAAwB,OAAY;AAClC,aAAO,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,OAAO,KAAK,MAAM,KAAK,CAAC;IAClE;IAEA,eAAY;AACV,aAAO,CAAC,CAAC,KAAK,oBAAoB,KAAK,gBAAgB,SAAS,KAAK,KAAK,gBAAgB,SAAS;IACrG;IAEA,eAAe,MAAc;AAC3B,UAAI,KAAK,iBAAiB;AACxB,mBAAW,SAAS,QAAQ;AAC1B,cAAI,KAAK,gBAAgB,KAAK,KAAK;AAAG,mBAAO,EAAE,QAAQ,MAAK;QAC9D;MACF;AACA;IACF;;AAGF,MAAM,mBAAmB,MAAY;AACnC,UAAM,QAAQ,MAAM,MAAK;AACzB,UAAM,WAAW,IAAI,UAAU,OAAQ,CAAC;AACxC,UAAM,WAAW,UAAU,MAAK;AAChC,UAAM,QAAQ,IAAI,UAAU,OAAQ,CAAC;AACrC,UAAM,QAAQ,IAAI,UAAU,MAAQ,CAAC;AACrC,UAAM,OAAO,UAAU,MAAK;AAC5B,UAAM,SAAS,IAAI,UAAU,MAAQ,CAAC;AACtC,UAAM,SAAS,IAAI,UAAU,MAAQ,CAAC;AACtC,UAAM,OAAO,IAAI,UAAU,OAAQ,CAAC;AACpC,UAAM,QAAQ,IAAI,UAAU,KAAQ,CAAC;AACrC,UAAM,OAAO,IAAI,UAAU,OAAQ,CAAC;AACpC,WAAO;EACT;AAEM,MAAO,cAAP,cAA2B,SAAQ;IACvC,cAAA;AACE,YAAM,aAAa;IACrB;IAEA,QAAK;AACH,WAAK,QAAQ,iBAAgB;AAC7B,WAAK,UAAU;AACf,WAAK,OAAO;AACZ,WAAK,UAAU,QAAQ,MAAK;AAC5B,WAAK,WAAW;AAChB,WAAK,kBAAkB;AACvB,WAAK,YAAY;AACjB,WAAK,YAAY;IACnB;IAEA,eAAe,OAAY;AACzB,YAAM,eAAe,KAAK;AAC1B,WAAK,UAAU,QAAQ,MAAK;IAC9B;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEU,WAAQ;AAChB,UAAI,KAAK,QAAO,KAAM,KAAK,MAAM,KAAK,SAAQ;AAAI,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,OAAO,CAAC;AAC3G,aAAO,MAAM,SAAQ;IACvB;IAEA,MAAM,QAAgB,KAAa;AACjC,YAAM,OAAO,KAAK,IAAG;AAGrB,UAAI,WAAW,IAAI;AAAM,eAAO,MAAM,MAAM,QAAQ,GAAG;AAGvD,UAAI,QAAQ,UAAU,MAAK;AAC3B,iBAAW,MAAM,MAAM,MAAM,QAAQ,GAAG,GAAG;AAEzC,cAAM,OAAO,EAAE,MAAM,QAAQ,GAAE;AAC/B,cAAM,QAAQ,KAAK,MAAK;AACxB,cAAM,KAAK,IAAI;AACf,YAAI,CAAC,MAAM,QAAO;AAAI,kBAAQ,MAAM,KAAK,EAAE;MAC7C;AACA,aAAO;IACT;IAEA,wBAAwB,QAAa;AACnC,aAAO;IACT;IAEA,eAAY;AACV,YAAM,OAAO,UAAU,SAAS,CAAC;AACjC,YAAM,SAAS,KAAK,MAAM,KAAK,UAAU,IAAI;AAC7C,UAAI,OAAO,QAAO;AAAI,eAAO;AAC7B,UAAI,KAAK,SAAS,WAAW,OAAO,WAAW,KAAK,MAAM,KAAK;AAAG,eAAO;AAGzE,YAAM,YAAY,KAAK,MAAM,OAAO,OAAO;AAC3C,UAAI,QAAQ,SAAS,GAAG;AACtB,cAAM,MAAM,KAAK,MAAM,SAAS,QAAQ,SAAS;AACjD,mBAAW,UAAU,YAAY,SAAS,EAAE,UAAU,IAAI,EAAE,KAAK,KAAK,MAAM,KAAK,GAAG;AAClF,cAAI,KAAK,cAAc,QAAQ,SAAS,GAAG,EAAE,QAAO;AAAI,mBAAO;QACjE;MACF;AACA,aAAO;IACT;IAEA,eAAe,KAAa;AAC1B,UAAI,MAAM,CAAC,IAAI,aAAa,CAAC,KAAK,aAAY;AAAI;AAClD,YAAM,OAAO,UAAU,SAAS,CAAC;AACjC,YAAM,cAAc,KAAK,MAAM,OAAO,SAAS,MAAM,EAAE,WAAW,IAAI;AACtE,YAAM,cAAc,KAAK,MAAM,OAAO,SAAS,MAAM,EAAE,WAAW,IAAI;AACtE,UAAI,eAAe,CAAC;AAAa,eAAO,EAAE,QAAQ,QAAO;AACzD,UAAI,eAAe,CAAC;AAAa,eAAO,EAAE,QAAQ,QAAO;AACzD,aAAO,EAAE,QAAQ,OAAS;IAC5B;;AAGF,MAAM,aAAa,MAAY;AAC7B,UAAM,QAAQ,MAAM,MAAK;AACzB,UAAM,WAAW,IAAI,UAAU,YAAa,UAAW;AACvD,UAAM,WAAW,UAAU,MAAK;AAChC,UAAM,QAAQ,IAAI,UAAU,YAAa,GAAW;AACpD,UAAM,QAAQ,IAAI,UAAU,GAAG,UAAW;AAC1C,UAAM,OAAO,IAAI,UAAU,YAAa,QAAW;AACnD,UAAM,SAAS,IAAI,UAAU,GAAG,UAAW;AAC3C,UAAM,SAAS,IAAI,UAAU,GAAG,SAAW;AAC3C,UAAM,OAAO,IAAI,UAAU,GAAG,UAAW;AACzC,UAAM,QAAQ,IAAI,UAAU,GAAG,SAAW;AAC1C,UAAM,OAAO,IAAI,UAAU,GAAG,SAAW;AACzC,WAAO;EACT;AAEM,MAAO,QAAP,cAAqB,SAAQ;IACjC,cAAA;AACE,YAAM,OAAO;IACf;IAEA,QAAK;AACH,WAAK,QAAQ,WAAU;AACvB,WAAK,UAAU;AACf,WAAK,OAAO;AACZ,WAAK,UAAU,QAAQ,QAAO;AAC9B,WAAK,QAAQ,aAAa,OAAO;AACjC,WAAK,WAAW;AAChB,WAAK,kBAAkB;AACvB,WAAK,YAAY;AACjB,WAAK,YAAY;IACnB;IAEA,OAAO,UAAO;AACZ,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,MAAK;AACT,aAAO;IACT;IAEA,OAAO,UAAU,OAAY;AAC3B,YAAM,MAAM,IAAI,KAAI;AACpB,UAAI,eAAe,KAAK;AACxB,aAAO,IAAI,SAAQ,EAAG,IAAI,OAAK,GAAG;IACpC;IAEA,QAAK;AACH,aAAO,MAAM,MAAK;IACpB;IAEU,WAAQ;AAChB,UAAI,KAAK,MAAM,SAAS,QAAO;AAAI,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAC1F,UAAI,KAAK,MAAM,KAAK,KAAI,MAAO;AAAG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,KAAK,CAAC;AAEzF,YAAM,YAAY,KAAK,MAAM,OAAO,SAAS,KAAK,IAAI,CAAC;AACvD,UAAI,QAAQ,SAAS,KAAK,KAAK,cAAc,WAAW,KAAK,MAAM,KAAK,MAAM,QAAQ,EAAE,SAAQ,GAAI;AAClG,eAAO,OAAO,IAAI,IAAI,cAAc,aAAa,aAAa,CAAC;MACjE;AACA,iBAAW,SAAS,QAAQ;AAC1B,cAAM,YAAY,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,QAAO,IACtD,UAAU,SAAS,SAAS,KAAK,CAAC,IAClC,UAAU,UAAS;AACvB,YAAI,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,WAAW,SAAS,GAAG;AAC1D,iBAAO,OAAO,IAAI,IAAI,cAAc,aAAa,eAAe,CAAC;QACnE;MACF;AACA,aAAO,OAAO,GAAG,MAAS;IAC5B;IAEA,wBAAwB,OAAY;AAElC,UAAI,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,SAAQ;AAAI,eAAO;AAGxD,YAAM,sBAAsB,CAAC,gBAA2C,gBAAgB,UAAU,SAAS;AAC3G,YAAM,iBAAiB,CAAC,gBACtB,gBAAgB,UAAU,UAAU,aAAY,IAAK,UAAU,YAAW;AAE5E,YAAM,gBAAgB,CAAC,SAAe;AACpC,cAAM,UAAU,KAAK,MAAM,OAAO,MAAM,QAAQ;AAChD,eAAO,QAAQ,WAAW,UAAU,YAAW,CAAE,KAAK,QAAQ,WAAW,UAAU,aAAY,CAAE;MACnG;AAKA,YAAM,QAAQ,aAAa,UAAU,KAAK,OAAO,KAAK;AACtD,YAAM,eAAe,CAAC,gBACpB,eAAe,WAAW,EAAE,UAAU,KAAK,MAAM,OAAO,OAAO,QAAQ,CAAC,EAAE,KAAI;AAChF,YAAM,mBAAgC,aAAa,OAAO,KAAK,IAAI,UAAU;AAC7E,YAAM,WAAW,MAAM,OACnB,MAAM,SACN,MAAM,OACN,MAAM,QACN,KAAK,IAAI,aAAa,MAAM,GAAG,CAAC,IAChC,KAAK,IAAI,aAAa,OAAO,GAAG,CAAC;AAErC,YAAM,SAAS,aAAa,UAAU,KAAK,OAAO,SAAS,KAAK,CAAC;AACjE,YAAM,gBAAgB,CAAC,gBACrB,eAAe,WAAW,EACvB,UAAU,KAAK,MAAM,OAAO,SAAS,KAAK,GAAG,QAAQ,CAAC,EACtD,KAAI;AACT,YAAM,YAAY,OAAO,KAAI;AAC7B,YAAM,kBAAkB,CAAC,UAAkB,YAAY;AAEvD,UAAI,aAAa;AAAG,eAAO;AAC3B,UAAI,YAAY,GAAG;AAEjB,eAAO;MACT;AACA,WAAK,MAAM,QAAQ,KAAK,MAAM,SAAS,MAAM,YAAY,GAAG;AAG1D,eAAO;MACT;AACA,UAAI,MAAM,QAAQ,KAAK,YAAY,GAAG;AAOpC,YACE,EACE,aAAa,KACV,MAAM,SAAS,KACf,MAAM,WAAW,KACjB,gBAAgB,cAAc,gBAAgB,CAAC,MAAM,IAE1D;AACA,iBAAO;QACT;MACF;AAEA,UAAI,aAAa,GAAG;AAClB,YAAI,cAAc,GAAG;AAEnB,iBAAO;QACT,WAAW,MAAM,UAAU,GAAG;AAQ5B,iBAAO,EAAE,OAAO,QAAQ,KAAK,OAAO,QAAQ,KAAK,cAAc,OAAO,KAAK,KAAK,cAAc,MAAM,KAAK;QAC3G,WAAW,MAAM,SAAS,GAAG;AAG3B,gBAAM,aAAa,KAAK,MAAM,OAAO,OAAO,MAAM,EAAE,KAAI;AACxD,gBAAM,iBAAiB,KAAK,MAAK;AACjC,yBAAe,MAAM,IAAI,YAAY,EAAE,OAAO,MAAM,QAAO,CAAE;AAC7D,gBAAM,kBAAkB,KAAK,MAAK;AAClC,0BAAgB,MAAM,IAAI,YAAY,EAAE,OAAO,MAAM,SAAQ,CAAE;AAC/D,iBAAO,eAAe,wBAAwB,KAAK,KAAK,gBAAgB,wBAAwB,KAAK;QACvG,WAAW,MAAM,SAAS,GAAG;AAK3B,iBAAO,EACL,OAAO,QAAQ,KACX,OAAO,QAAQ,KAAK,OAAO,QAAQ,KACnC,OAAO,QAAQ,KAAK,OAAO,UAAU,KACrC,OAAO,QAAQ,KAAK,OAAO,UAAU;QAE7C,WAAW,MAAM,WAAW,GAAG;AAE7B,iBAAO;;;;;;;;;;;WAYL,cAAc,oBAAoB,gBAAgB,CAAC,KAAK,KACpD,cAAc,oBAAoB,gBAAgB,CAAC,KAAK,KAAK,OAAO,QAAQ,KAC7E,OAAO,QAAQ;QAEtB,WAAW,MAAM,WAAW,GAAG;AAE7B,iBAAO;;;;;WAML,aAAa,MACT,OAAO,UAAU,KAChB,OAAO,QAAQ,KACd,OAAO,QAAQ,KAAK,OAAO,UAAU,KACrC,OAAO,QAAQ,KAAK,OAAO,UAAU,KACrC,OAAO,UAAU,KAAK,OAAO,UAAU,KACvC,OAAO,QAAQ,KAAK,OAAO,QAAQ,KACnC,OAAO,UAAU,KAAK,OAAO,QAAQ,KACrC,OAAO,UAAU,KAAK,OAAO,QAAQ,KACrC,cAAc,SAAS,KAAK,CAAC,KAAK,OAAO,QAAQ,OACnD,cAAc,MAAM,IAAI,KAAK,gBAAgB,cAAc,MAAM,CAAC,KAAK,OACvE,cAAc,OAAO,IAAI,KAAK,gBAAgB,cAAc,OAAO,CAAC,KAAK;QAEjF;MAGF,WAAW,aAAa,GAAG;AACzB,YAAI,cAAc,GAAG;AAEnB,iBAAO;QACT,WAAW,MAAM,WAAW,GAAG;AAI7B,iBAAO,OAAO,OAAO,OAAO,SAAS,OAAO,SAAS;QACvD,WAAW,cAAc,KAAK,GAAG;AAC/B,iBAAO;;WAGL,OAAO,QAAQ,KACZ,OAAO,UAAU,KAIhB,OAAO,UAAU,KAAK,OAAO,OAAO,OAAO,SAAS;QAE5D,WAAW,MAAM,UAAU,KAAK,MAAM,UAAU,GAAG;AAEjD,iBAAO;;WAGL,OAAO,QAAQ,KACZ,cAAc,oBAAoB,gBAAgB,CAAC,KAAK,KAIxD,gBAAgB,cAAc,gBAAgB,CAAC,KAAK;QAE3D,OAAO;AAIL,iBAAO;;;;;WAMJ,OAAO,QAAQ,KAAK,cAAc,oBAAoB,gBAAgB,CAAC,KAAK,KACzE,OAAO,QAAQ,KAAK,OAAO,UAAU,KACrC,cAAc,oBAAoB,gBAAgB,CAAC,KAAK,KAAK,OAAO,UAAU,KAC/E,cAAc,oBAAoB,gBAAgB,CAAC,KAAK,KACxD,OAAO,UAAU,KACjB,OAAO,QAAQ;QAGtB;MACF,WAAW,aAAa,GAAG;AAGzB,YAAK,MAAM,WAAW,KAAK,MAAM,WAAW,KAAM,MAAM,WAAW,KAAK,cAAc,KAAK,GAAG;AAC5F,iBAAO;QACT,OAAO;AAKL,iBAAO,cAAc;QACvB;MACF;AAEA,aAAO;IACT;IAEA,eAAY;AACV,aAAO,KAAK,MAAM,MAAM,QAAO,KAAM,KAAK,MAAM,MAAM,QAAO;IAC/D;IAEA,eAAe,MAAc;AAC3B,UAAI,KAAK,MAAM,MAAM,QAAO;AAAI,eAAO,EAAE,QAAQ,QAAO;AACxD,UAAI,KAAK,MAAM,MAAM,QAAO;AAAI,eAAO,EAAE,QAAQ,QAAO;AACxD;IACF;;AAGK,MAAM,kBAAkB,CAAC,UAA0B;AACxD,YAAQ,OAAO;MACb,KAAK;AACH,eAAO,MAAM,QAAO;MACtB,KAAK;AACH,eAAO,UAAU,QAAO;MAC1B,KAAK;AACH,eAAO,OAAO,QAAO;MACvB,KAAK;AACH,eAAO,MAAM,QAAO;MACtB,KAAK;AACH,eAAO,YAAY,QAAO;MAC5B,KAAK;AACH,eAAO,cAAc,QAAO;MAC9B,KAAK;AACH,eAAO,WAAW,QAAO;MAC3B,KAAK;AACH,eAAO,WAAW,QAAO;IAC7B;EACF;AAEO,MAAM,gBAAgB,CAAC,OAAc,UAAiD;AAC3F,YAAQ,OAAO;MACb,KAAK;AACH,eAAO,MAAM,UAAU,KAAK;MAC9B,KAAK;AACH,eAAO,UAAU,UAAU,KAAK;MAClC,KAAK;AACH,eAAO,OAAO,UAAU,KAAK;MAC/B,KAAK;AACH,eAAO,MAAM,UAAU,KAAK;MAC9B,KAAK;AACH,eAAO,YAAY,UAAU,KAAK;MACpC,KAAK;AACH,eAAO,cAAc,UAAU,KAAK;MACtC,KAAK;AACH,eAAO,WAAW,UAAU,KAAK;MACnC,KAAK;AACH,eAAO,WAAW,UAAU,KAAK;IACrC;EACF;;;AC9uBO,MAAM,cAAc,CAAI,cAAyC,oBAA6B;IACnG,SAAS,YAAW;IACpB,OAAO,IAAI,KAAI;;AAGX,MAAO,OAAP,MAAW;IAAjB,cAAA;AACE,WAAA,WAA2B,CAAA;IAoB7B;IAlBE,CAAC,gBAAa;AACZ,UAAI,OAAgB;AACpB,aAAO,KAAK,SAAS,QAAQ;AAC3B,cAAM,QAAQ,KAAK,SAAS,CAAC;AAC7B,cAAM;AACN,eAAO;MACT;IACF;IAEA,CAAC,WAAQ;AACP,iBAAW,SAAS,KAAK,cAAa;AAAI,cAAM,MAAM;IACxD;IAEA,MAAG;AACD,UAAI,OAAgB;AACpB,aAAO,KAAK,SAAS;AAAQ,eAAO,KAAK,SAAS,CAAC;AACnD,aAAO;IACT;;AAgOK,MAAM,iBAAiB,MAC5B,oBAAI,IAAI;IACN,CAAC,SAAS,GAAG;IACb,CAAC,QAAQ,GAAG;IACZ,CAAC,QAAQ,YAAY;IACrB,CAAC,SAAS,GAAG;IACb,CAAC,SAAS,GAAG;IACb,CAAC,SAAS,GAAG;IACb,CAAC,UAAU,GAAG;GACf;AAiPI,MAAM,eAAe,CAAC,YAAkD;AAC7E,aAAS,WAAW,SAAS,YAAW,GAAI;MAC1C,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;AACH,eAAO;MACT,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO;MACT;AACE;IACJ;EACF;AAuBO,MAAM,mBAAmB,CAAC,YAA4E;AAC3G,UAAM,QAAQ,aAAa,QAAQ,IAAI,SAAS,CAAC;AACjD,QAAI,CAAC;AAAO,aAAO,OAAO,IAAI,IAAI,cAAc,aAAa,OAAO,CAAC;AACrE,UAAM,MAAM,QAAQ,IAAI,KAAK;AAC7B,QAAI;AAAK,aAAO,SAAS,GAAG,EAAE,MAAM,WAAS,cAAc,OAAO,KAAK,CAAC;;AACnE,aAAO,OAAO,GAAG,gBAAgB,KAAK,CAAC;EAC9C;;;AC7mBO,MAAM,WAAW,CAAC,KAAe,QAAiC;AACvE,UAAM,MAAM,IAAI,IAAG;AAGnB,UAAM,QAAQ,IAAI,MAAM,yEAAyE;AAUjG,QAAI,CAAC,OAAO;AAEV,UAAIC;AACJ,UAAI,QAAQ,SAAS,QAAQ,UAAU,QAAQ;AAAQ,QAAAA,gBAAe;eAC7D,QAAQ,WAAW,QAAQ,YAAY,QAAQ;AAAU,QAAAA,gBAAe;AACjF,UAAIA,eAAc;AAChB,cAAM,OAAO,IAAI,QAAQ,KAAK,IAAI,IAAI,EAAEA,aAAY;AACpD,YAAI,CAAC,QAAQ,IAAI,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,IAAI,MAAM,IAAI,MAAM,GAAG,EAAE,IAAI,IAAI;AAAG;AACjF,eAAO;UACL,MAAM,IAAI;UACV,IAAI;;MAER;AAGA,YAAMC,SAAQ,IAAI,MAAM,uCAAuC;AAG/D,UAAI,CAACA;AAAO;AACZ,YAAM,OAAO;QACX,MAAMA,OAAM,CAAC,IAAI,WAAWA,OAAM,CAAC,CAAC,IAAI;QACxC,IAAI,YAAYA,OAAM,CAAC,CAAC;;AAE1B,aAAO,IAAI,QAAQ,MAAM,GAAG,IAAI,OAAO;IACzC;AACA,UAAM,OAAO,MAAM,CAAC,IAAI,WAAW,MAAM,CAAC,CAAC,IAAI;AAC/C,UAAM,KAAK,YAAY,MAAM,CAAC,CAAC;AAE/B,UAAM,YAAY,MAAM,CAAC,IAAI,WAAW,MAAM,CAAC,CAAC,IAAI;AACpD,QAAI,CAAC,CAAC,eAAe,SAAS,UAAU,UAAU,UAAS,EAAG,IAAI,EAAE;AAAI;AACxE,QAAI,cAAc,UAAU,IAAI,UAAU;AAAa;AAEvD,QAAI,aAAa,IAAI,MAAM,OAAO,IAAI,MAAM,IAAI;AAChD,QAAI,SAAS,UAAU,CAAC,MAAM,CAAC;AAAG,mBAAa,WAAW,UAAU,UAAU,SAAS,WAAW,EAAE,CAAC,CAAC;aAC7F,MAAM,CAAC;AAAG,mBAAa,WAAW,UAAU,UAAU,SAAS,MAAM,CAAC,EAAE,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,CAAC,CAAC;AACnH,QAAI,MAAM,CAAC;AAAG,mBAAa,WAAW,UAAU,UAAU,SAAS,MAAM,CAAC,EAAE,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,CAAC,CAAC;AAG9G,UAAM,cAAc,SAAS,SAAS,UAAU,SAAS,WAAW,EAAE,CAAC,IAAI,UAAU,MAAK;AAC1F,iBAAa,WAAW,UACtB,YAAY,MAAM,QAAQ,EAAE,OAAO,SAAS,IAAI,IAAI,GAAG,KAAI,GAAI,IAAI,IAAI,MAAM,QAAQ,CAAC,CAAC;AAIzF,QAAI;AACJ,eAAW,aAAa,YAAY;AAClC,UAAI,IAAI,MAAM,WAAW,GAAG,EAAE,IAAI,EAAE,GAAG;AACrC,YAAI,QAAQ,IAAI;AAAG;AACnB,eAAO;MACT;IACF;AACA,QAAI,CAAC,QAAQ,IAAI;AAAG;AAEpB,WAAO;MACL;MACA;MACA;;EAEJ;;;ACrJA,MAAU;AAAV,IAAUC,4BAAV;AACE,UAAM,aAAa;AA4CnB,UAAM,iBAAiB,MAAgB;AAjDzC;AAkDI,cAAQ,KAAK,kCAAkC;AAG/C,YAAM,gBAAgB,SAAS,cAAc,UAAU;AACvD,UAAI,CAAC,eAAe;AAClB,eAAO,CAAC;AAAA,MACV;AAGA,YAAM,eAAe,cAAc,iBAAiB,MAAM;AAE1D,YAAM,OAAO,YAAY;AACzB,YAAM,MAAM,iBAAiB,KAAK,OAAO,EAAE,OAAO;AAClD,YAAM,WAAqB,CAAC;AAE5B,iBAAW,UAAU,cAAc;AACjC,cAAM,QAAO,YAAO,gBAAP,mBAAoB;AACjC,YAAI,MAAM;AACR,gBAAM,YAAY,SAAS,KAAK,IAAI;AACpC,cAAI,CAAC,WAAW;AACd,oBAAQ,KAAK,2BAA2B,IAAI,GAAG;AAC/C;AAAA,UACF;AACA,mBAAS,KAAK,QAAQ,SAAS,CAAC;AAChC,cAAI,KAAK,SAAS;AAAA,QACpB;AAAA,MACF;AAEA,cAAQ,KAAK,gBAAgB,IAAI,SAAS;AAC1C,aAAO;AAAA,IACT;AAEA,UAAM,iBAAiB,CAAO,QAAgB;AAC5C,UAAI;AACF,cAAM,QAAQ,MAAM,OAAO,KAAK,UAAU;AAC1C,cAAM,iBAAiB,MAAM,MAAM,MAAM,GAAG;AAG5C,YAAI,gBAAgB;AAClB,kBAAQ,IAAI,cAAc,GAAG;AAC7B,iBAAO;AAAA,QACT;AAGA,gBAAQ,IAAI,yBAAyB,GAAG;AACxC,cAAM,WAAW,MAAM,GAAG,eAAe;AAAA,UACvC,QAAQ;AAAA,UACR;AAAA,UACA,cAAc;AAAA,QAChB,CAAC;AAGD,cAAM,SAAS,SAAS,iBAAiB,6BAA6B,MAAM;AAC5E,cAAM,aAAa,WAAW,MAAM,OAAO;AAC3C,cAAM,oBAAoB,IAAI,SAAS,SAAS,cAAc;AAAA,UAC5D;AAAA,UACA;AAAA,UACA,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD,CAAC;AAED,cAAM,MAAM,IAAI,KAAK,iBAAiB;AAGtC,eAAO,MAAM,MAAM,MAAM,GAAG;AAAA,MAC9B,SAAS,OAAO;AACd,gBAAQ,MAAM,gBAAgB,KAAK;AACnC,cAAM;AAAA,MACR;AAAA,IACF;AAEA,UAAM,oBAAoB,CAAC,SAAwB;AAEjD,UAAI,YAAY,SAAS,eAAe,kBAAkB;AAC1D,UAAI,CAAC,WAAW;AACd,oBAAY,SAAS,cAAc,KAAK;AACxC,kBAAU,KAAK;AACf,kBAAU,MAAM,YAAY;AAC5B,kBAAU,MAAM,UAAU;AAC1B,kBAAU,MAAM,iBAAiB;AACjC,kBAAU,MAAM,WAAW;AAC3B,kBAAU,MAAM,aAAa;AAC7B,kBAAU,MAAM,WAAW;AAC3B,kBAAU,MAAM,aAAa;AAC7B,kBAAU,MAAM,WAAW;AAC3B,iBAAS,KAAK,QAAQ,SAAS;AAAA,MACjC;AAEA,gBAAU,cAAc,OAAO,aAAa,IAAI,KAAK;AAAA,IACvD;AAEO,IAAMA,wBAAA,OAAO,MAAY;AAC9B,cAAQ,KAAK,yCAAyC;AAEtD,YAAM,aAAa,SAAS;AAC5B,YAAM,SAAS,EAAE,WAAW,MAAM,SAAS,KAAK;AAEhD,YAAM,WAA6B,CACjC,eACA,qBACG;AACH,mBAAW,YAAY,eAAe;AACpC,cAAI,SAAS,SAAS,aAAa;AACjC,uBAAW,QAAQ,SAAS,YAAY;AACtC,kBAAI,gBAAgB,eAAe,KAAK,QAAQ,gBAAgB,GAAG;AACjE,wBAAQ,KAAK,2CAA2C;AACxD,sBAAM,SAAS,eAAe;AAC9B,oBAAI,OAAO,SAAS,GAAG;AACrB,wBAAM,MAAM,wDAAwD,OAAO,KAAK,GAAG,CAAC;AACpF,wBAAM,OAAO,MAAM,eAAe,GAAG;AACrC,sBAAI,6BAAM,IAAI;AACZ,0BAAM,gBAAiB,MAAM,KAAK,KAAK;AACvC,wBAAI,cAAc,MAAM,WAAW,GAAG;AACpC,8BAAQ;AAAA,wBACN;AAAA,sBACF;AACA,wCAAkB,IAAI;AACtB,uCAAiB,WAAW;AAC5B;AAAA,oBACF;AACA,sCAAkB,cAAc,MAAM,CAAC,EAAE,GAAG;AAC5C,4BAAQ,KAAK,aAAa,cAAc,MAAM,CAAC,EAAE,GAAG;AAAA,kBACtD,OAAO;AACL,4BAAQ,KAAK,qDAAqD;AAAA,kBACpE;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,YAAM,WAAW,IAAI,iBAAiB,QAAQ;AAC9C,eAAS,QAAQ,YAAY,MAAM;AAGnC,YAAM,gBAAgB,eAAe;AACrC,UAAI,cAAc,SAAS,GAAG;AAC5B,cAAM,MAAM,wDAAwD,cAAc,KAAK,GAAG,CAAC;AAC3F,cAAM,OAAO,MAAM,eAAe,GAAG;AACrC,YAAI,MAAM;AACR,gBAAM,gBAAiB,MAAM,KAAK,KAAK;AACvC,cAAI,cAAc,MAAM,SAAS,GAAG;AAClC,8BAAkB,cAAc,MAAM,CAAC,EAAE,GAAG;AAC5C,oBAAQ,KAAK,aAAa,cAAc,MAAM,CAAC,EAAE,GAAG;AAAA,UACtD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,KAjMQ;AAoMV,yBAAuB,KAAK;",
  "names": ["Result", "res", "IllegalSetup", "InvalidFen", "board", "pockets", "castlingRights", "remainingChecks", "castlingSide", "match", "LichessOpeningExplorer"]
}
